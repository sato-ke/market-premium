"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8],{7762:(e,t,i)=>{i.d(t,{A:()=>d});var r=i(37),s=i(3675),a=i(6077),o=i(8119),n=i(5432);class d extends r.A{describe(){return this.deepExtend(super.describe(),{id:"hitbtc",name:"HitBTC",countries:["HK"],rateLimit:3.333,version:"3",has:{CORS:!1,spot:!0,margin:!0,swap:!0,future:!1,option:void 0,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,closePosition:!1,createDepositAddress:!0,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:void 0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!0,fetchLeverageTiers:void 0,fetchLiquidations:!1,fetchMarginMode:"emulated",fetchMarginModes:!0,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyLiquidations:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!1,fetchOpenInterests:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!0,fetchPositions:!0,fetchPremiumIndexOHLCV:!0,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:"emulated",fetchWithdrawals:!0,reduceMargin:!0,sandbox:!0,setLeverage:!0,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},precisionMode:s.kb,urls:{logo:"https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg",test:{public:"https://api.demo.hitbtc.com/api/3",private:"https://api.demo.hitbtc.com/api/3"},api:{public:"https://api.hitbtc.com/api/3",private:"https://api.hitbtc.com/api/3"},www:"https://hitbtc.com",referral:"https://hitbtc.com/?ref_id=5a5d39a65d466",doc:["https://api.hitbtc.com","https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv2.md"],fees:["https://hitbtc.com/fees-and-limits","https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits"]},api:{public:{get:{"public/currency":10,"public/currency/{currency}":10,"public/symbol":10,"public/symbol/{symbol}":10,"public/ticker":10,"public/ticker/{symbol}":10,"public/price/rate":10,"public/price/history":10,"public/price/ticker":10,"public/price/ticker/{symbol}":10,"public/trades":10,"public/trades/{symbol}":10,"public/orderbook":10,"public/orderbook/{symbol}":10,"public/candles":10,"public/candles/{symbol}":10,"public/converted/candles":10,"public/converted/candles/{symbol}":10,"public/futures/info":10,"public/futures/info/{symbol}":10,"public/futures/history/funding":10,"public/futures/history/funding/{symbol}":10,"public/futures/candles/index_price":10,"public/futures/candles/index_price/{symbol}":10,"public/futures/candles/mark_price":10,"public/futures/candles/mark_price/{symbol}":10,"public/futures/candles/premium_index":10,"public/futures/candles/premium_index/{symbol}":10,"public/futures/candles/open_interest":10,"public/futures/candles/open_interest/{symbol}":10}},private:{get:{"spot/balance":15,"spot/balance/{currency}":15,"spot/order":1,"spot/order/{client_order_id}":1,"spot/fee":15,"spot/fee/{symbol}":15,"spot/history/order":15,"spot/history/trade":15,"margin/account":1,"margin/account/isolated/{symbol}":1,"margin/account/cross/{currency}":1,"margin/order":1,"margin/order/{client_order_id}":1,"margin/config":15,"margin/history/order":15,"margin/history/trade":15,"margin/history/positions":15,"margin/history/clearing":15,"futures/balance":15,"futures/balance/{currency}":15,"futures/account":1,"futures/account/isolated/{symbol}":1,"futures/order":1,"futures/order/{client_order_id}":1,"futures/config":15,"futures/fee":15,"futures/fee/{symbol}":15,"futures/history/order":15,"futures/history/trade":15,"futures/history/positions":15,"futures/history/clearing":15,"wallet/balance":30,"wallet/balance/{currency}":30,"wallet/crypto/address":30,"wallet/crypto/address/recent-deposit":30,"wallet/crypto/address/recent-withdraw":30,"wallet/crypto/address/check-mine":30,"wallet/transactions":30,"wallet/transactions/{tx_id}":30,"wallet/crypto/fee/estimate":30,"wallet/airdrops":30,"wallet/amount-locks":30,"sub-account":15,"sub-account/acl":15,"sub-account/balance/{subAccID}":15,"sub-account/crypto/address/{subAccID}/{currency}":15},post:{"spot/order":1,"spot/order/list":1,"margin/order":1,"margin/order/list":1,"futures/order":1,"futures/order/list":1,"wallet/crypto/address":30,"wallet/crypto/withdraw":30,"wallet/convert":30,"wallet/transfer":30,"wallet/internal/withdraw":30,"wallet/crypto/check-offchain-available":30,"wallet/crypto/fees/estimate":30,"wallet/airdrops/{id}/claim":30,"sub-account/freeze":15,"sub-account/activate":15,"sub-account/transfer":15,"sub-account/acl":15},patch:{"spot/order/{client_order_id}":1,"margin/order/{client_order_id}":1,"futures/order/{client_order_id}":1},delete:{"spot/order":1,"spot/order/{client_order_id}":1,"margin/position":1,"margin/position/isolated/{symbol}":1,"margin/order":1,"margin/order/{client_order_id}":1,"futures/position":1,"futures/position/{margin_mode}/{symbol}":1,"futures/order":1,"futures/order/{client_order_id}":1,"wallet/crypto/withdraw/{id}":30},put:{"margin/account/isolated/{symbol}":1,"futures/account/isolated/{symbol}":1,"wallet/crypto/withdraw/{id}":30}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0009"),maker:this.parseNumber("0.0009"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.0009")],[this.parseNumber("10"),this.parseNumber("0.0007")],[this.parseNumber("100"),this.parseNumber("0.0006")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0003")],[this.parseNumber("5000"),this.parseNumber("0.0002")],[this.parseNumber("10000"),this.parseNumber("0.0001")],[this.parseNumber("20000"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.0001")],[this.parseNumber("100000"),this.parseNumber("-0.0001")]],taker:[[this.parseNumber("0"),this.parseNumber("0.0009")],[this.parseNumber("10"),this.parseNumber("0.0008")],[this.parseNumber("100"),this.parseNumber("0.0007")],[this.parseNumber("500"),this.parseNumber("0.0007")],[this.parseNumber("1000"),this.parseNumber("0.0006")],[this.parseNumber("5000"),this.parseNumber("0.0006")],[this.parseNumber("10000"),this.parseNumber("0.0005")],[this.parseNumber("20000"),this.parseNumber("0.0004")],[this.parseNumber("50000"),this.parseNumber("0.0003")],[this.parseNumber("100000"),this.parseNumber("0.0002")]]}}},timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"D7","1M":"1M"},exceptions:{exact:{429:o.RateLimitExceeded,500:o.ExchangeError,503:o.ExchangeNotAvailable,504:o.ExchangeNotAvailable,600:o.PermissionDenied,800:o.ExchangeError,1002:o.AuthenticationError,1003:o.PermissionDenied,1004:o.AuthenticationError,1005:o.AuthenticationError,2001:o.BadSymbol,2002:o.BadRequest,2003:o.BadRequest,2010:o.BadRequest,2011:o.BadRequest,2012:o.BadRequest,2020:o.BadRequest,2022:o.BadRequest,2024:o.InvalidOrder,10001:o.BadRequest,10021:o.AccountSuspended,10022:o.BadRequest,20001:o.InsufficientFunds,20002:o.OrderNotFound,20003:o.ExchangeError,20004:o.ExchangeError,20005:o.ExchangeError,20006:o.ExchangeError,20007:o.ExchangeError,20008:o.InvalidOrder,20009:o.InvalidOrder,20010:o.OnMaintenance,20011:o.ExchangeError,20012:o.ExchangeError,20014:o.ExchangeError,20016:o.ExchangeError,20018:o.ExchangeError,20031:o.ExchangeError,20032:o.ExchangeError,20033:o.ExchangeError,20034:o.ExchangeError,20040:o.ExchangeError,20041:o.ExchangeError,20042:o.ExchangeError,20043:o.ExchangeError,20044:o.PermissionDenied,20045:o.InvalidOrder,20047:o.InvalidOrder,20048:o.InvalidOrder,20049:o.InvalidOrder,20080:o.ExchangeError,21001:o.ExchangeError,21003:o.AccountSuspended,21004:o.AccountSuspended,22004:o.ExchangeError,22008:o.ExchangeError},broad:{}},options:{defaultNetwork:"ERC20",defaultNetworks:{ETH:"ETH",USDT:"TRC20"},networks:{BTC:"btc",OMNI:"BTC",ETH:"eth",ERC20:"ETH",ETC:"ETC",BEP20:"BSC",TRC20:"TRX",NEAR:"NEAR",DGB:"DGB",AE:"AE",AR:"AR",ADA:"ADA",CHZ:"CHZ",ABBC:"ABBC",ALGO:"ALGO",APT:"APT",ATOM:"ATOM",AVAXC:"AVAC",AVAXX:"AVAX",BSV:"BCHSV",BEP2:"BNB",CELO:"CELO",CKB:"CKB",CTXC:"CTXC",DASH:"DASH",DCR:"DCR",DOGE:"doge",EGLD:"EGLD",EOS:"EOS",ETHW:"ETHW",EVER:"EVER",FET:"FET",FIL:"FIL",FLOW:"FLOW",GLMR:"GLMR",GRIN:"GRIN",HBAR:"HBAR",HIVE:"HIVE",HYDRA:"HYDRA",ICP:"ICP",ICX:"ICX",IOST:"IOST",IOTA:"IOTA",IOTX:"IOTX",KAVA:"KAVA",KLAY:"KIM",KOMODO:"KMD",KSM:"KSM",LSK:"LSK",LTC:"ltc",MINA:"MINA",MOVR:"MOVR",NANO:"NANO",NEO:"NEO",ONE:"ONE",ONT:"ONT",OPTIMISM:"OP",PLCU:"PLCU",MATIC:"POLYGON",QTUM:"QTUM",REI:"REI",OASIS:"ROSE",RVN:"RVN",SC:"SC",SCRT:"SCRT",SOL:"SOL",STEEM:"STEEM",THETA:"Theta",TRUE:"TRUE",VET:"VET",VSYS:"VSYS",WAVES:"WAVES",WAX:"WAX",XCH:"XCH",XEC:"XEC",NEM:"XEM",XLM:"XLM",XMR:"xmr",XRD:"XRD",XRP:"XRP",XTZ:"XTZ",XVG:"XVG",XYM:"XYM",ZEC:"ZEC",ZEN:"ZEN",ZIL:"ZIL"},accountsByType:{spot:"spot",funding:"wallet",swap:"derivatives",future:"derivatives"},withdraw:{includeFee:!1}},commonCurrencies:{AUTO:"Cube",BCC:"BCC",BDP:"BidiPass",BET:"DAO.Casino",BIT:"BitRewards",BOX:"BOX Token",CPT:"Cryptaur",GET:"Themis",GMT:"GMT Token",HSR:"HC",IQ:"IQ.Cash",LNC:"LinkerCoin",PLA:"PlayChip",PNT:"Penta",SBTC:"Super Bitcoin",STEPN:"GMT",STX:"STOX",TV:"Tokenville",XMT:"MTL",XPNT:"PNT"}})}nonce(){return this.milliseconds()}async fetchMarkets(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=await this.publicGetPublicSymbol(e),i=[],r=Object.keys(t);for(let e=0;e<r.length;e++){let s,o,n,d,h;let l=r[e];if(l.endsWith("_BQX"))continue;let c=this.safeValue(t,l),p=this.safeString(c,"type"),u=this.safeInteger(c,"expiry"),m="futures"===p,f="spot"===p,g=this.safeBool(c,"margin_trading",!1),v=f&&g,y=void 0!==u,w=m&&!y,b=this.safeString2(c,"base_currency","underlying"),k=this.safeString(c,"quote_currency"),M=this.safeString(c,"fee_currency"),S=this.safeCurrencyCode(b),O=this.safeCurrencyCode(k),T=this.safeCurrencyCode(M),P=S+"/"+O,x="spot";m&&(n=this.parseNumber("1"),s=M,o=this.safeCurrencyCode(s),h=!(d=void 0!==O&&O===o),P=P+":"+o,y?(P=P+"-"+u,x="future"):x="swap");let A=this.safeString(c,"quantity_increment"),C=this.safeString(c,"tick_size"),E=this.parseNumber(A),N=this.parseNumber(C);i.push({id:l,symbol:P,base:S,quote:O,settle:o,baseId:b,quoteId:k,settleId:s,type:x,spot:f,margin:v,swap:w,future:y,option:!1,active:!0,contract:m,linear:d,inverse:h,taker:this.safeNumber(c,"take_rate"),maker:this.safeNumber(c,"make_rate"),contractSize:n,expiry:u,expiryDatetime:void 0,strike:void 0,optionType:void 0,feeCurrency:T,precision:{amount:E,price:N},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(c,"max_initial_leverage",1)},amount:{min:E,max:void 0},price:{min:N,max:void 0},cost:{min:this.parseNumber(a.Y.stringMul(A,C)),max:void 0}},created:void 0,info:c})}return i}async fetchCurrencies(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=await this.publicGetPublicCurrency(e),i={},r=Object.keys(t);for(let e=0;e<r.length;e++){let s,a,o;let n=r[e],d=this.safeCurrencyCode(n),h=t[n],l=this.safeString(h,"full_name"),c=this.safeNumber(h,"precision_transfer"),p=this.safeBool(h,"payin_enabled",!1),u=this.safeBool(h,"payout_enabled",!1),m=this.safeBool(h,"transfer_enabled",!1),f=p&&u&&m,g=this.safeValue(h,"networks",[]),v={};for(let e=0;e<g.length;e++){let t=g[e],i=this.safeString2(t,"protocol","network"),r=this.networkIdToCode(i);r=void 0!==r?r.toUpperCase():void 0,s=this.safeNumber(t,"payout_fee");let n=this.safeNumber(t,"precision_payout"),d=this.safeBool(t,"payin_enabled",!1),h=this.safeBool(t,"payout_enabled",!1),l=d&&h;d&&!a?a=!0:d||(a=!1),h&&!o?o=!0:h||(o=!1),v[r]={info:t,id:i,network:r,fee:s,active:l,deposit:d,withdraw:h,precision:n,limits:{withdraw:{min:void 0,max:void 0}}}}let y=Object.keys(v).length;i[d]={info:h,code:d,id:n,precision:c,name:l,active:f,deposit:a,withdraw:o,networks:v,fee:y<=1?s:void 0,limits:{amount:{min:void 0,max:void 0}}}}return i}async createDepositAddress(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let i={currency:this.currency(e).id},r=this.safeStringUpper(t,"network");if(void 0!==r&&"USDT"===e){let e=this.safeValue(this.options,"networks"),s=this.safeString(e,r);void 0!==s&&(i.currency=s),t=this.omit(t,"network")}let s=await this.privatePostWalletCryptoAddress(this.extend(i,t)),a=this.safeString(s,"currency");return{currency:this.safeCurrencyCode(a),address:this.safeString(s,"address"),tag:this.safeString(s,"payment_id"),network:void 0,info:s}}async fetchDepositAddress(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let i={currency:this.currency(e).id},r=this.safeStringUpper(t,"network");if(void 0!==r&&"USDT"===e){let e=this.safeValue(this.options,"networks"),s=this.safeString(e,r);void 0!==s&&(i.currency=s),t=this.omit(t,"network")}let s=await this.privateGetWalletCryptoAddress(this.extend(i,t)),a=this.safeValue(s,0),o=this.safeString(a,"address"),n=this.safeString(a,"currency"),d=this.safeString(a,"payment_id");return{info:s,currency:this.safeCurrencyCode(n),network:void 0,address:o,tag:d}}parseBalance(e){let t={info:e};for(let i=0;i<e.length;i++){let r=e[i],s=this.safeString(r,"currency"),a=this.safeCurrencyCode(s),o=this.account();o.free=this.safeString(r,"available"),o.used=this.safeString(r,"reserved"),t[a]=o}return this.safeBalance(t)}async fetchBalance(){let e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=this.safeStringLower(t,"type","spot");t=this.omit(t,["type"]);let r=this.safeValue(this.options,"accountsByType",{}),s=this.safeString(r,i,i);if("wallet"===s)e=await this.privateGetWalletBalance(t);else if("spot"===s)e=await this.privateGetSpotBalance(t);else if("derivatives"===s)e=await this.privateGetFuturesBalance(t);else{let e=Object.keys(r);throw new o.BadRequest(this.id+" fetchBalance() type parameter must be one of "+e.join(", "))}return this.parseBalance(e)}async fetchTicker(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let i=this.market(e),r={symbol:i.id},s=await this.publicGetPublicTickerSymbol(this.extend(r,t));return this.parseTicker(s,i)}async fetchTickers(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let i={};if(void 0!==(e=this.marketSymbols(e))){let t=this.marketIds(e).join(",");i.symbols=t}let r=await this.publicGetPublicTicker(this.extend(i,t)),s={},a=Object.keys(r);for(let e=0;e<a.length;e++){let t=a[e],i=this.safeMarket(t),o=i.symbol,n=r[t];s[o]=this.parseTicker(n,i)}return this.filterByArrayTickers(s,"symbol",e)}parseTicker(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=this.parse8601(e.timestamp),r=this.safeSymbol(void 0,t),s=this.safeString(e,"volume"),a=this.safeString(e,"volume_quote"),o=this.safeString(e,"open"),n=this.safeString(e,"last");return this.safeTicker({symbol:r,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:o,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:s,quoteVolume:a,info:e},t)}async fetchTrades(e){let t,i,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};await this.loadMarkets();let o={};if(void 0!==s&&(o.limit=Math.min(s,1e3)),void 0!==r&&(o.from=r),void 0!==e?(t=this.market(e),o.symbol=t.id,i=await this.publicGetPublicTradesSymbol(this.extend(o,a))):i=await this.publicGetPublicTrades(this.extend(o,a)),void 0!==e)return this.parseTrades(i,t);let n=[],d=Object.keys(i);for(let e=0;e<d.length;e++){let t=d[e],r=this.market(t),s=i[t],a=this.parseTrades(s,r);n=this.arrayConcat(n,a)}return n}async fetchMyTrades(){let e,t,i,r,s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};await this.loadMarkets();let h={};if(void 0!==s&&(e=this.market(s),h.symbol=e.id),void 0!==n&&(h.limit=n),void 0!==a&&(h.from=a),[t,d]=this.handleMarketTypeAndParams("fetchMyTrades",e,d),[i,d]=this.handleMarginModeAndParams("fetchMyTrades",d),d=this.omit(d,["marginMode","margin"]),void 0!==i)r=await this.privateGetMarginHistoryTrade(this.extend(h,d));else if("spot"===t)r=await this.privateGetSpotHistoryTrade(this.extend(h,d));else if("swap"===t)r=await this.privateGetFuturesHistoryTrade(this.extend(h,d));else if("margin"===t)r=await this.privateGetMarginHistoryTrade(this.extend(h,d));else throw new o.NotSupported(this.id+" fetchMyTrades() not support this market type");return this.parseTrades(r,e,a,n)}parseTrade(e){let t,i,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,s=this.parse8601(e.timestamp),a=this.safeString(e,"symbol"),o=(r=this.safeMarket(a,r)).symbol,n=this.safeString(e,"fee"),d=this.safeValue(e,"taker");if(i=void 0!==d?d?"taker":"maker":"taker",void 0!==n){let e=this.safeValue(r,"info",{}),i=this.safeString(e,"fee_currency");t={cost:n,currency:this.safeCurrencyCode(i)}}let h=this.safeString2(e,"clientOrderId","client_order_id"),l=this.safeString(e,"price"),c=this.safeString2(e,"quantity","qty"),p=this.safeString(e,"side"),u=this.safeString(e,"id");return this.safeTrade({info:e,id:u,order:h,timestamp:s,datetime:this.iso8601(s),symbol:o,type:void 0,side:p,takerOrMaker:i,price:l,amount:c,cost:void 0,fee:t},r)}async fetchTransactionsHelper(e,t,i,r,s){let a;await this.loadMarkets();let o={types:e};void 0!==t&&(a=this.currency(t),o.currencies=a.id),void 0!==i&&(o.from=this.iso8601(i)),void 0!==r&&(o.limit=r);let n=await this.privateGetWalletTransactions(this.extend(o,s));return this.parseTransactions(n,a,i,r,s)}parseTransactionStatus(e){return this.safeString({CREATED:"pending",PENDING:"pending",FAILED:"failed",ROLLED_BACK:"failed",SUCCESS:"ok"},e,e)}parseTransactionType(e){return this.safeString({DEPOSIT:"deposit",WITHDRAW:"withdrawal"},e,e)}parseTransaction(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1];let t=this.safeString2(e,"operation_id","id"),i=this.parse8601(this.safeString(e,"created_at")),r=this.parse8601(this.safeString(e,"updated_at")),s=this.parseTransactionType(this.safeString(e,"type")),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeValue(e,"native",{}),n=this.safeString(o,"currency"),d=this.safeCurrencyCode(n),h=this.safeString(o,"hash"),l=this.safeString(o,"address"),c=this.safeString(o,"payment_id"),p=this.safeValue(o,"senders"),u=this.safeString(p,0),m=this.safeNumber(o,"amount"),f=this.safeString(e,"subtype"),g={currency:void 0,cost:void 0,rate:void 0},v=this.safeNumber(o,"fee");return void 0!==v&&(g.currency=d,g.cost=v),{info:e,id:t,txid:h,type:s,currency:d,network:void 0,amount:m,status:a,timestamp:i,datetime:this.iso8601(i),address:l,addressFrom:u,addressTo:l,tag:c,tagFrom:void 0,tagTo:c,updated:r,comment:void 0,internal:"OFFCHAIN"===f,fee:g}}async fetchDepositsWithdrawals(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return await this.fetchTransactionsHelper("DEPOSIT,WITHDRAW",e,t,i,r)}async fetchDeposits(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return await this.fetchTransactionsHelper("DEPOSIT",e,t,i,r)}async fetchWithdrawals(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return await this.fetchTransactionsHelper("WITHDRAW",e,t,i,r)}async fetchOrderBooks(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};await this.loadMarkets();let r={};if(void 0!==e){let t=this.marketIds(e);r.symbols=t.join(",")}void 0!==t&&(r.depth=t);let s=await this.publicGetPublicOrderbook(this.extend(r,i)),a={},o=Object.keys(s);for(let e=0;e<o.length;e++){let t=o[e],i=s[t],r=this.safeSymbol(t),n=this.parse8601(this.safeString(i,"timestamp"));a[r]=this.parseOrderBook(s[t],r,n,"bid","ask")}return a}async fetchOrderBook(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};await this.loadMarkets();let r={symbol:this.market(e).id};void 0!==t&&(r.depth=t);let s=await this.publicGetPublicOrderbookSymbol(this.extend(r,i)),a=this.parse8601(this.safeString(s,"timestamp"));return this.parseOrderBook(s,e,a,"bid","ask")}parseTradingFee(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=this.safeNumber(e,"take_rate"),r=this.safeNumber(e,"make_rate"),s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t),taker:i,maker:r,percentage:void 0,tierBased:void 0}}async fetchTradingFee(e){let t,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let r=this.market(e),s={symbol:r.id};if("spot"===r.type)t=await this.privateGetSpotFeeSymbol(this.extend(s,i));else if("swap"===r.type)t=await this.privateGetFuturesFeeSymbol(this.extend(s,i));else throw new o.NotSupported(this.id+" fetchTradingFee() not support this market type");return this.parseTradingFee(t,r)}async fetchTradingFees(){let e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};await this.loadMarkets();let[i,r]=this.handleMarketTypeAndParams("fetchTradingFees",void 0,t);if("spot"===i)e=await this.privateGetSpotFee(r);else if("swap"===i)e=await this.privateGetFuturesFee(r);else throw new o.NotSupported(this.id+" fetchTradingFees() not support this market type");let s={};for(let t=0;t<e.length;t++){let i=this.parseTradingFee(e[t]);s[i.symbol]=i}return s}async fetchOHLCV(e){let t,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"1m",r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:void 0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};await this.loadMarkets();let o=!1;if([o,a]=this.handleOptionAndParams(a,"fetchOHLCV","paginate"),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,r,s,i,a,1e3);let n=this.market(e),d={symbol:n.id,period:this.safeString(this.timeframes,i,i)};void 0!==r&&(d.from=this.iso8601(r)),[d,a]=this.handleUntilOption("until",d,a),void 0!==s&&(d.limit=Math.min(s,1e3));let h=this.safeString(a,"price");return a=this.omit(a,"price"),t="mark"===h?await this.publicGetPublicFuturesCandlesMarkPriceSymbol(this.extend(d,a)):"index"===h?await this.publicGetPublicFuturesCandlesIndexPriceSymbol(this.extend(d,a)):"premiumIndex"===h?await this.publicGetPublicFuturesCandlesPremiumIndexSymbol(this.extend(d,a)):await this.publicGetPublicCandlesSymbol(this.extend(d,a)),this.parseOHLCVs(t,n,i,r,s)}parseOHLCV(e){return arguments.length>1&&void 0!==arguments[1]&&arguments[1],[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"max"),this.safeNumber(e,"min"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchClosedOrders(){let e,t,i,r,s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};await this.loadMarkets();let h={};if(void 0!==s&&(e=this.market(s),h.symbol=e.id),void 0!==a&&(h.from=this.iso8601(a)),void 0!==n&&(h.limit=n),[t,d]=this.handleMarketTypeAndParams("fetchClosedOrders",e,d),[i,d]=this.handleMarginModeAndParams("fetchClosedOrders",d),d=this.omit(d,["marginMode","margin"]),void 0!==i)r=await this.privateGetMarginHistoryOrder(this.extend(h,d));else if("spot"===t)r=await this.privateGetSpotHistoryOrder(this.extend(h,d));else if("swap"===t)r=await this.privateGetFuturesHistoryOrder(this.extend(h,d));else if("margin"===t)r=await this.privateGetMarginHistoryOrder(this.extend(h,d));else throw new o.NotSupported(this.id+" fetchClosedOrders() not support this market type");let l=this.parseOrders(r,e,a,n);return this.filterByArray(l,"status",["closed","canceled"],!1)}async fetchOrder(e){let t,i,r,s,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};await this.loadMarkets(),void 0!==a&&(t=this.market(a));let d={client_order_id:e};if([i,n]=this.handleMarketTypeAndParams("fetchOrder",t,n),[r,n]=this.handleMarginModeAndParams("fetchOrder",n),n=this.omit(n,["marginMode","margin"]),void 0!==r)s=await this.privateGetMarginHistoryOrder(this.extend(d,n));else if("spot"===i)s=await this.privateGetSpotHistoryOrder(this.extend(d,n));else if("swap"===i)s=await this.privateGetFuturesHistoryOrder(this.extend(d,n));else if("margin"===i)s=await this.privateGetMarginHistoryOrder(this.extend(d,n));else throw new o.NotSupported(this.id+" fetchOrder() not support this market type");let h=this.safeDict(s,0);return this.parseOrder(h,t)}async fetchOrderTrades(e){let t,i,r,s,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:void 0,h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};await this.loadMarkets(),void 0!==a&&(t=this.market(a));let l={order_id:e};if([i,h]=this.handleMarketTypeAndParams("fetchOrderTrades",t,h),[r,h]=this.handleMarginModeAndParams("fetchOrderTrades",h),h=this.omit(h,["marginMode","margin"]),void 0!==r)s=await this.privateGetMarginHistoryTrade(this.extend(l,h));else if("spot"===i)s=await this.privateGetSpotHistoryTrade(this.extend(l,h));else if("swap"===i)s=await this.privateGetFuturesHistoryTrade(this.extend(l,h));else if("margin"===i)s=await this.privateGetMarginHistoryTrade(this.extend(l,h));else throw new o.NotSupported(this.id+" fetchOrderTrades() not support this market type");return this.parseTrades(s,t,n,d)}async fetchOpenOrders(){let e,t,i,r,s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};await this.loadMarkets();let h={};if(void 0!==s&&(e=this.market(s),h.symbol=e.id),[t,d]=this.handleMarketTypeAndParams("fetchOpenOrders",e,d),[i,d]=this.handleMarginModeAndParams("fetchOpenOrders",d),d=this.omit(d,["marginMode","margin"]),void 0!==i)r=await this.privateGetMarginOrder(this.extend(h,d));else if("spot"===t)r=await this.privateGetSpotOrder(this.extend(h,d));else if("swap"===t)r=await this.privateGetFuturesOrder(this.extend(h,d));else if("margin"===t)r=await this.privateGetMarginOrder(this.extend(h,d));else throw new o.NotSupported(this.id+" fetchOpenOrders() not support this market type");return this.parseOrders(r,e,a,n)}async fetchOpenOrder(e){let t,i,r,s,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};await this.loadMarkets(),void 0!==a&&(t=this.market(a));let d={client_order_id:e};if([i,n]=this.handleMarketTypeAndParams("fetchOpenOrder",t,n),[r,n]=this.handleMarginModeAndParams("fetchOpenOrder",n),n=this.omit(n,["marginMode","margin"]),void 0!==r)s=await this.privateGetMarginOrderClientOrderId(this.extend(d,n));else if("spot"===i)s=await this.privateGetSpotOrderClientOrderId(this.extend(d,n));else if("swap"===i)s=await this.privateGetFuturesOrderClientOrderId(this.extend(d,n));else if("margin"===i)s=await this.privateGetMarginOrderClientOrderId(this.extend(d,n));else throw new o.NotSupported(this.id+" fetchOpenOrder() not support this market type");return this.parseOrder(s,t)}async cancelAllOrders(){let e,t,i,r,s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let n={};if(void 0!==s&&(e=this.market(s),n.symbol=e.id),[t,a]=this.handleMarketTypeAndParams("cancelAllOrders",e,a),[i,a]=this.handleMarginModeAndParams("cancelAllOrders",a),a=this.omit(a,["marginMode","margin"]),void 0!==i)r=await this.privateDeleteMarginOrder(this.extend(n,a));else if("spot"===t)r=await this.privateDeleteSpotOrder(this.extend(n,a));else if("swap"===t)r=await this.privateDeleteFuturesOrder(this.extend(n,a));else if("margin"===t)r=await this.privateDeleteMarginOrder(this.extend(n,a));else throw new o.NotSupported(this.id+" cancelAllOrders() not support this market type");return this.parseOrders(r,e)}async cancelOrder(e){let t,i,r,s,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};await this.loadMarkets();let d={client_order_id:e};if(void 0!==a&&(t=this.market(a)),[i,n]=this.handleMarketTypeAndParams("cancelOrder",t,n),[r,n]=this.handleMarginModeAndParams("cancelOrder",n),n=this.omit(n,["marginMode","margin"]),void 0!==r)s=await this.privateDeleteMarginOrderClientOrderId(this.extend(d,n));else if("spot"===i)s=await this.privateDeleteSpotOrderClientOrderId(this.extend(d,n));else if("swap"===i)s=await this.privateDeleteFuturesOrderClientOrderId(this.extend(d,n));else if("margin"===i)s=await this.privateDeleteMarginOrderClientOrderId(this.extend(d,n));else throw new o.NotSupported(this.id+" cancelOrder() not support this market type");return this.parseOrder(s,t)}async editOrder(e,t,i,r){let s,a,n,d,h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0,l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:void 0,c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:{};await this.loadMarkets();let p={client_order_id:e,quantity:this.amountToPrecision(t,h)};if("limit"===i||"stopLimit"===i){if(void 0===l)throw new o.ExchangeError(this.id+" editOrder() limit order requires price");p.price=this.priceToPrecision(t,l)}if(void 0!==t&&(s=this.market(t)),[a,c]=this.handleMarketTypeAndParams("editOrder",s,c),[n,c]=this.handleMarginModeAndParams("editOrder",c),c=this.omit(c,["marginMode","margin"]),void 0!==n)d=await this.privatePatchMarginOrderClientOrderId(this.extend(p,c));else if("spot"===a)d=await this.privatePatchSpotOrderClientOrderId(this.extend(p,c));else if("swap"===a)d=await this.privatePatchFuturesOrderClientOrderId(this.extend(p,c));else if("margin"===a)d=await this.privatePatchMarginOrderClientOrderId(this.extend(p,c));else throw new o.NotSupported(this.id+" editOrder() not support this market type");return this.parseOrder(d,s)}async createOrder(e,t,i,r){let s,a,o,n,d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0,h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};await this.loadMarkets();let l=this.market(e);return[a,h]=this.handleMarketTypeAndParams("createOrder",l,h),[o,h]=this.handleMarginModeAndParams("createOrder",h),[s,h]=this.createOrderRequest(l,a,t,i,r,d,o,h),n="swap"===a?await this.privatePostFuturesOrder(this.extend(s,h)):"margin"===a||void 0!==o?await this.privatePostMarginOrder(this.extend(s,h)):await this.privatePostSpotOrder(this.extend(s,h)),this.parseOrder(n,l)}createOrderRequest(e,t,i,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:void 0,n=arguments.length>6&&void 0!==arguments[6]?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:{},h="limit"===i,l=this.safeValue(d,"reduceOnly"),c=this.safeString(d,"timeInForce"),p=this.safeNumberN(d,["triggerPrice","stopPrice","stop_price"]),u=this.isPostOnly("market"===i,void 0,d),m={type:i,side:r,quantity:this.amountToPrecision(e.symbol,s),symbol:e.id};if(void 0!==l&&"swap"!==e.type&&"margin"!==e.type)throw new o.InvalidOrder(this.id+" createOrder() does not support reduce_only for "+e.type+" orders, reduce_only orders are supported for swap and margin markets only");if(!0===l&&(m.reduce_only=l),u&&(m.post_only=!0),void 0!==c&&(m.time_in_force=c),h||"stopLimit"===i||"takeProfitLimit"===i){if(void 0===a)throw new o.ExchangeError(this.id+" createOrder() requires a price argument for limit orders");m.price=this.priceToPrecision(e.symbol,a)}if("GTD"===c&&void 0===this.safeString(d,"expire_time"))throw new o.ExchangeError(this.id+" createOrder() requires an expire_time parameter for a GTD order");if(void 0!==p)m.stop_price=this.priceToPrecision(e.symbol,p),h?m.type="stopLimit":"market"===i&&(m.type="stopMarket");else if("stopLimit"===i||"stopMarket"===i||"takeProfitLimit"===i||"takeProfitMarket"===i)throw new o.ExchangeError(this.id+" createOrder() requires a triggerPrice parameter for stop-loss and take-profit orders");return d=this.omit(d,["triggerPrice","timeInForce","stopPrice","stop_price","reduceOnly","postOnly"]),"swap"===t&&(void 0===n&&(n="cross"),m.margin_mode=n),[m,d]}parseOrderStatus(e){return this.safeString({new:"open",suspended:"open",partiallyFilled:"open",filled:"closed",canceled:"canceled",expired:"failed"},e,e)}parseOrder(e){let t,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,r=this.safeString(e,"client_order_id"),s=this.safeString(e,"side"),a=this.safeString(e,"type"),o=this.safeString(e,"quantity"),n=this.safeString(e,"price"),d=this.safeString(e,"price_average"),h=this.safeString(e,"created_at"),l=this.parse8601(h),c=this.safeString(e,"updated_at");c!==h&&(t=this.parse8601(c));let p=this.safeString(e,"quantity_cumulative"),u=this.parseOrderStatus(this.safeString(e,"status")),m=this.safeString(e,"symbol"),f=(i=this.safeMarket(m,i)).symbol,g=this.safeValue(e,"post_only"),v=this.safeString(e,"time_in_force"),y=this.safeValue(e,"trades");return this.safeOrder({info:e,id:r,clientOrderId:r,timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:t,lastUpdateTimestamp:t,symbol:f,price:n,amount:o,type:a,side:s,timeInForce:v,postOnly:g,reduceOnly:this.safeValue(e,"reduce_only"),filled:p,remaining:void 0,cost:void 0,status:u,average:d,trades:y,fee:void 0,triggerPrice:this.safeString(e,"stop_price"),takeProfitPrice:void 0,stopLossPrice:void 0},i)}async fetchMarginModes(){let e,t,i,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(await this.loadMarkets(),void 0!==r&&(r=this.marketSymbols(r),e=this.market(r[0])),[t,s]=this.handleMarketTypeAndParams("fetchMarginMode",e,s),"margin"===t)i=await this.privateGetMarginConfig(s);else if("swap"===t)i=await this.privateGetFuturesConfig(s);else throw new o.BadSymbol(this.id+" fetchMarginModes () supports swap contracts and margin only");let a=this.safeList(i,"config",[]);return this.parseMarginModes(a,r,"symbol")}parseMarginMode(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(i,t),marginMode:this.safeStringLower(e,"margin_mode")}}async transfer(e,t,i,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};await this.loadMarkets();let a=this.currency(e),n=this.currencyToPrecision(e,t),d=this.safeValue(this.options,"accountsByType",{});i=i.toLowerCase(),r=r.toLowerCase();let h=this.safeString(d,i,i),l=this.safeString(d,r,r);if(h===l)throw new o.BadRequest(this.id+" transfer() fromAccount and toAccount arguments cannot be the same account");let c={currency:a.id,amount:n,source:h,destination:l},p=await this.privatePostWalletTransfer(this.extend(c,s));return this.parseTransfer(p,a)}parseTransfer(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;return{id:this.safeString(e,0),timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0,info:e}}async convertCurrencyNetwork(e,t,i,r,s){if(await this.loadMarkets(),"USDT"!==e)throw new o.ExchangeError(this.id+" convertCurrencyNetwork() only supports USDT currently");let a=this.safeValue(this.options,"networks",{});if(i=i.toUpperCase(),r=r.toUpperCase(),i=this.safeString(a,i),r=this.safeString(a,r),i===r)throw new o.BadRequest(this.id+" convertCurrencyNetwork() fromNetwork cannot be the same as toNetwork");if(void 0===i||void 0===r){let e=Object.keys(a);throw new o.ArgumentsRequired(this.id+" convertCurrencyNetwork() requires a fromNetwork parameter and a toNetwork parameter, supported networks are "+e.join(", "))}let n={from_currency:i,to_currency:r,amount:this.currencyToPrecision(e,t)};return{info:await this.privatePostWalletConvert(this.extend(n,s))}}async withdraw(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:void 0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};[r,s]=this.handleWithdrawTagAndParams(r,s),await this.loadMarkets(),this.checkAddress(i);let a=this.currency(e),o={currency:a.id,amount:t,address:i};void 0!==r&&(o.payment_id=r);let n=this.safeValue(this.options,"networks",{}),d=this.safeStringUpper(s,"network");if(void 0!==d&&"USDT"===e){let e=this.safeString(n,d);void 0!==e&&(o.network_code=e),s=this.omit(s,"network")}let h=this.safeValue(this.options,"withdraw",{});this.safeBool(h,"includeFee",!1)&&(o.include_fee=!0);let l=await this.privatePostWalletCryptoWithdraw(this.extend(o,s));return this.parseTransaction(l,a)}async fetchFundingRates(){let e,t,i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let s={};if(void 0!==i){i=this.marketSymbols(i),e=this.market(i[0]);let t=this.marketIds(i);s.symbols=t.join(",")}if([t,r]=this.handleMarketTypeAndParams("fetchFundingRates",e,r),"swap"!==t)throw new o.NotSupported(this.id+" fetchFundingRates() does not support "+t+" markets");let a=await this.publicGetPublicFuturesInfo(this.extend(s,r)),n=Object.keys(a),d={};for(let e=0;e<n.length;e++){let t=this.safeString(n,e),i=this.safeValue(a,t),r=this.market(t),s=r.symbol,o=this.parseFundingRate(i,r);d[s]=o}return this.filterByArray(d,"symbol",i)}async fetchFundingRateHistory(){let e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};await this.loadMarkets();let a=!1;if([a,s]=this.handleOptionAndParams(s,"fetchFundingRateHistory","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",t,i,r,"8h",s,1e3);let o={};[o,s]=this.handleUntilOption("until",o,s),void 0!==t&&(t=(e=this.market(t)).symbol,o.symbols=e.id),void 0!==i&&(o.from=i),void 0!==r&&(o.limit=r);let n=await this.publicGetPublicFuturesHistoryFunding(this.extend(o,s)),d=Object.keys(n),h=[];for(let e=0;e<d.length;e++){let t=d[e],i=this.safeMarket(t),r=n[t];for(let e=0;e<r.length;e++){let t=r[e],s=this.safeSymbol(i.symbol),a=this.safeNumber(t,"funding_rate"),o=this.safeString(t,"timestamp");h.push({info:t,symbol:s,fundingRate:a,timestamp:this.parse8601(o),datetime:o})}}let l=this.sortBy(h,"timestamp");return this.filterBySymbolSinceLimit(l,t,i,r)}async fetchPositions(){let e,t,i;arguments.length>0&&void 0!==arguments[0]&&arguments[0];let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let s={};if([e,r]=this.handleMarketTypeAndParams("fetchPositions",void 0,r),"spot"===e&&(e="swap"),[t,r]=this.handleMarginModeAndParams("fetchPositions",r),r=this.omit(r,["marginMode","margin"]),void 0!==t)i=await this.privateGetMarginAccount(this.extend(s,r));else if("swap"===e)i=await this.privateGetFuturesAccount(this.extend(s,r));else if("margin"===e)i=await this.privateGetMarginAccount(this.extend(s,r));else throw new o.NotSupported(this.id+" fetchPositions() not support this market type");let a=[];for(let e=0;e<i.length;e++)a.push(this.parsePosition(i[e]));return a}async fetchPosition(e){let t,i,r,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let a=this.market(e),n={symbol:a.id};if([t,s]=this.handleMarketTypeAndParams("fetchPosition",void 0,s),[i,s]=this.handleMarginModeAndParams("fetchPosition",s),s=this.omit(s,["marginMode","margin"]),void 0!==i)r=await this.privateGetMarginAccountIsolatedSymbol(this.extend(n,s));else if("swap"===t)r=await this.privateGetFuturesAccountIsolatedSymbol(this.extend(n,s));else if("margin"===t)r=await this.privateGetMarginAccountIsolatedSymbol(this.extend(n,s));else throw new o.NotSupported(this.id+" fetchPosition() not support this market type");return this.parsePosition(r,a)}parsePosition(e){let t,i,r,s,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,o=this.safeString(e,"type"),n=this.safeNumber(e,"leverage"),d=this.safeString(e,"updated_at"),h=this.safeValue(e,"positions",[]);for(let e=0;e<h.length;e++){let s=h[e];t=this.safeNumber(s,"price_liquidation"),i=this.safeNumber(s,"price_entry"),r=this.safeNumber(s,"quantity")}let l=this.safeValue(e,"currencies",[]);for(let e=0;e<l.length;e++){let t=l[e];s=this.safeNumber(t,"margin_balance")}let c=this.safeString(e,"symbol"),p=(a=this.safeMarket(c,a)).symbol;return this.safePosition({info:e,id:void 0,symbol:p,notional:void 0,marginMode:o,marginType:o,liquidationPrice:t,entryPrice:i,unrealizedPnl:void 0,percentage:void 0,contracts:r,contractSize:void 0,markPrice:void 0,lastPrice:void 0,side:void 0,hedged:void 0,timestamp:this.parse8601(d),datetime:d,lastUpdateTimestamp:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:s,initialMargin:void 0,initialMarginPercentage:void 0,leverage:n,marginRatio:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}parseOpenInterest(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=this.safeString(e,"timestamp"),r=this.safeNumber(e,"open_interest");return this.safeOpenInterest({symbol:this.safeSymbol(void 0,t),openInterestAmount:void 0,openInterestValue:r,timestamp:this.parse8601(i),datetime:i,info:e},t)}async fetchOpenInterests(){let e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let r={};void 0!==(t=this.marketSymbols(t))&&(e=this.marketIds(t),r.symbols=e.join(","));let s=await this.publicGetPublicFuturesInfo(this.extend(r,i)),a=[],o=Object.keys(s);for(let e=0;e<o.length;e++){let t=o[e],i=this.safeMarket(t);a.push(this.parseOpenInterest(s[t],i))}return this.filterByArray(a,"symbol",t)}async fetchOpenInterest(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let i=this.market(e);if(!i.swap)throw new o.BadSymbol(this.id+" fetchOpenInterest() supports swap contracts only");let r={symbol:i.id},s=await this.publicGetPublicFuturesInfoSymbol(this.extend(r,t));return this.parseOpenInterest(s,i)}async fetchFundingRate(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let i=this.market(e);if(!i.swap)throw new o.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");let r={symbol:i.id},s=await this.publicGetPublicFuturesInfoSymbol(this.extend(r,t));return this.parseFundingRate(s,i)}parseFundingRate(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=this.safeString(e,"next_funding_time"),r=this.safeString(e,"timestamp");return{info:e,symbol:this.safeSymbol(void 0,t),markPrice:this.safeNumber(e,"mark_price"),indexPrice:this.safeNumber(e,"index_price"),interestRate:this.safeNumber(e,"interest_rate"),estimatedSettlePrice:void 0,timestamp:this.parse8601(r),datetime:r,fundingRate:this.safeNumber(e,"funding_rate"),fundingTimestamp:this.parse8601(i),fundingDatetime:i,nextFundingRate:this.safeNumber(e,"indicative_funding_rate"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0,interval:void 0}}async modifyMarginHelper(e,t,i){let r,s,a,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};await this.loadMarkets();let d=this.market(e),h=this.safeString(n,"leverage");if(d.swap&&void 0===h)throw new o.ArgumentsRequired(this.id+" modifyMarginHelper() requires a leverage parameter for swap markets");let l=this.numberToString(t);t="0"!==l?this.amountToPrecision(e,l):"0";let c={symbol:d.id,margin_balance:t};if(void 0!==h&&(c.leverage=h),[r,n]=this.handleMarketTypeAndParams("modifyMarginHelper",d,n),[s,n]=this.handleMarginModeAndParams("modifyMarginHelper",n),"swap"===r)a=await this.privatePutFuturesAccountIsolatedSymbol(this.extend(c,n));else if("margin"===r||"spot"===r||"isolated"===s)a=await this.privatePutMarginAccountIsolatedSymbol(this.extend(c,n));else throw new o.NotSupported(this.id+" modifyMarginHelper() not support this market type");return this.extend(this.parseMarginModification(a,d),{amount:this.parseNumber(t),type:i})}parseMarginModification(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=this.safeValue(e,"currencies",[]),r=this.safeValue(i,0),s=this.safeString(e,"updated_at");return{info:e,symbol:t.symbol,type:void 0,marginMode:"isolated",amount:void 0,total:void 0,code:this.safeString(r,"code"),status:void 0,timestamp:this.parse8601(s),datetime:s}}async reduceMargin(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("0"!==this.numberToString(t))throw new o.BadRequest(this.id+" reduceMargin() on hitbtc requires the amount to be 0 and that will remove the entire margin amount");return await this.modifyMarginHelper(e,t,"reduce",i)}async addMargin(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return await this.modifyMarginHelper(e,t,"add",i)}async fetchLeverage(e){let t,i,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let s=this.market(e),a={symbol:s.id};if([t,r]=this.handleMarginModeAndParams("fetchLeverage",r),r=this.omit(r,["marginMode","margin"]),void 0!==t)i=await this.privateGetMarginAccountIsolatedSymbol(this.extend(a,r));else if("spot"===s.type)i=await this.privateGetMarginAccountIsolatedSymbol(this.extend(a,r));else if("swap"===s.type)i=await this.privateGetFuturesAccountIsolatedSymbol(this.extend(a,r));else if("margin"===s.type)i=await this.privateGetMarginAccountIsolatedSymbol(this.extend(a,r));else throw new o.NotSupported(this.id+" fetchLeverage() not support this market type");return this.parseLeverage(i,s)}parseLeverage(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=this.safeString(e,"symbol"),r=this.safeInteger(e,"leverage");return{info:e,symbol:this.safeSymbol(i,t),marginMode:this.safeStringLower(e,"type"),longLeverage:r,shortLeverage:r}}async setLeverage(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(void 0===t)throw new o.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");if(await this.loadMarkets(),void 0===i.margin_balance)throw new o.ArgumentsRequired(this.id+" setLeverage() requires a margin_balance parameter that will transfer margin to the specified trading pair");let r=this.market(t),s=this.safeNumber(i,"margin_balance"),a=this.safeInteger(r.limits.leverage,"max",50);if("swap"!==r.type)throw new o.BadSymbol(this.id+" setLeverage() supports swap contracts only");if(e<1||e>a)throw new o.BadRequest(this.id+" setLeverage() leverage should be between 1 and "+a.toString()+" for "+t);let n={symbol:r.id,leverage:e.toString(),margin_balance:this.amountToPrecision(t,s)};return await this.privatePutFuturesAccountIsolatedSymbol(this.extend(n,i))}async fetchDepositWithdrawFees(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.loadMarkets();let i=await this.publicGetPublicCurrency(t);return this.parseDepositWithdrawFees(i,e)}parseDepositWithdrawFee(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1];let t=this.safeValue(e,"networks",[]),i=this.depositWithdrawFee(e);for(let e=0;e<t.length;e++){let r=t[e],s=this.safeString(r,"network"),a=this.networkIdToCode(s);a=void 0!==a?a.toUpperCase():void 0;let o=this.safeNumber(r,"payout_fee"),n=this.safeValue(r,"default"),d={fee:o,percentage:void 0===o&&void 0};!0===n&&(i.withdraw=d),i.networks[a]={withdraw:d,deposit:{fee:void 0,percentage:void 0}}}return i}async closePosition(e){let t;arguments.length>1&&void 0!==arguments[1]&&arguments[1];let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};await this.loadMarkets(),[t,i]=this.handleMarginModeAndParams("closePosition",i,"cross");let r=this.market(e),s={symbol:r.id,margin_mode:t},a=await this.privateDeleteFuturesPositionMarginModeSymbol(this.extend(s,i));return this.parseOrder(a,r)}handleMarginModeAndParams(e){let t,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,s=this.safeString(this.options,"defaultType"),a=this.safeBool(i,"margin",!1);return[t,i]=super.handleMarginModeAndParams(e,i,r),void 0===t&&("margin"===s||!0===a)&&(t="isolated"),[t,i]}handleErrors(e,t,i,r,s,a,n,d,h){let l=this.safeValue(n,"error"),c=this.safeString(l,"code");if(void 0!==c){let e=this.id+" "+a,t=this.safeString2(l,"message","description");throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwBroadlyMatchedException(this.exceptions.broad,t,e),new o.ExchangeError(e)}}sign(e){let t,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"public",r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"GET",s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:void 0,d=this.omit(s,this.extractParams(e)),h=this.implodeParams(e,s),l=this.urls.api[i]+"/"+h,c=Object.keys(d).length;if(a={"Content-Type":"application/json"},"GET"===r?c&&(l+=t="?"+this.urlencode(d)):o=this.json(s),"private"===i){this.checkRequiredCredentials();let e=this.nonce().toString(),i=[r,"/api/3/"+h];"GET"===r?void 0!==t&&i.push(t):i.push(o),i.push(e);let s=i.join(""),d=this.hmac(this.encode(s),this.encode(this.secret),n.s,"hex"),l=this.apiKey+":"+d+":"+e,c=this.stringToBase64(l);a.Authorization="HS256 "+c}return{url:l,method:r,body:o,headers:a}}}}}]);