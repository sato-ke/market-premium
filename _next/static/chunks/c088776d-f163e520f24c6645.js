"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[938],{357:(e,t,i)=>{i.d(t,{A:()=>d});var s=i(854),r=i(8119),a=i(3675),o=i(6077),n=i(5432);class d extends s.A{describe(){return this.deepExtend(super.describe(),{id:"mexc",name:"MEXC Global",countries:["SC"],rateLimit:50,version:"v3",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!0,borrowCrossMargin:!1,borrowIsolatedMargin:!1,borrowMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:void 0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!0,createMarketSellOrderWithCost:!0,createOrder:!0,createOrders:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,createTriggerOrder:!0,deposit:void 0,editOrder:void 0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowInterest:!1,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchCanceledOrders:!0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingInterval:!0,fetchFundingIntervals:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!0,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchIsolatedPositions:!1,fetchL2OrderBook:!0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverage:!0,fetchLeverages:!1,fetchLeverageTiers:!0,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!1,fetchOpenInterestHistory:!1,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:"emulated",fetchPositionHistory:"emulated",fetchPositionMode:!0,fetchPositions:!0,fetchPositionsHistory:!0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTradingLimits:void 0,fetchTransactionFee:"emulated",fetchTransactionFees:!0,fetchTransactions:void 0,fetchTransfer:!0,fetchTransfers:!0,fetchWithdrawal:void 0,fetchWithdrawals:!0,reduceMargin:!0,repayCrossMargin:!1,repayIsolatedMargin:!1,setLeverage:!0,setMarginMode:!0,setPositionMode:!0,signIn:void 0,transfer:void 0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg",api:{spot:{public:"https://api.mexc.com",private:"https://api.mexc.com"},spot2:{public:"https://www.mexc.com/open/api/v2",private:"https://www.mexc.com/open/api/v2"},contract:{public:"https://contract.mexc.com/api/v1/contract",private:"https://contract.mexc.com/api/v1/private"},broker:{private:"https://api.mexc.com/api/v3/broker"}},www:"https://www.mexc.com/",doc:["https://mexcdevelop.github.io/apidocs/"],fees:["https://www.mexc.com/fee"],referral:"https://www.mexc.com/register?inviteCode=mexc-1FQ1GNu1"},api:{spot:{public:{get:{ping:1,time:1,exchangeInfo:10,depth:1,trades:5,historicalTrades:1,aggTrades:1,klines:1,avgPrice:1,"ticker/24hr":1,"ticker/price":1,"ticker/bookTicker":1,"etf/info":1}},private:{get:{order:2,openOrders:3,allOrders:10,account:10,myTrades:10,tradeFee:10,"sub-account/list":1,"sub-account/apiKey":1,"capital/config/getall":10,"capital/deposit/hisrec":1,"capital/withdraw/history":1,"capital/withdraw/address":10,"capital/deposit/address":10,"capital/transfer":1,"capital/transfer/tranId":1,"capital/transfer/internal":1,"capital/sub-account/universalTransfer":1,"capital/convert":1,"capital/convert/list":1,"margin/loan":1,"margin/allOrders":1,"margin/myTrades":1,"margin/openOrders":1,"margin/maxTransferable":1,"margin/priceIndex":1,"margin/order":1,"margin/isolated/account":1,"margin/maxBorrowable":1,"margin/repay":1,"margin/isolated/pair":1,"margin/forceLiquidationRec":1,"margin/isolatedMarginData":1,"margin/isolatedMarginTier":1,"rebate/taxQuery":1,"rebate/detail":1,"rebate/detail/kickback":1,"rebate/referCode":1,"rebate/affiliate/commission":1,"rebate/affiliate/withdraw":1,"rebate/affiliate/commission/detail":1,"mxDeduct/enable":1,userDataStream:1,selfSymbols:1},post:{order:1,"order/test":1,"sub-account/virtualSubAccount":1,"sub-account/apiKey":1,"sub-account/futures":1,"sub-account/margin":1,batchOrders:10,"capital/withdraw/apply":1,"capital/withdraw":1,"capital/transfer":1,"capital/transfer/internal":1,"capital/deposit/address":1,"capital/sub-account/universalTransfer":1,"capital/convert":10,"mxDeduct/enable":1,userDataStream:1},put:{userDataStream:1},delete:{order:1,openOrders:1,"sub-account/apiKey":1,"margin/order":1,"margin/openOrders":1,userDataStream:1,"capital/withdraw":1}}},contract:{public:{get:{ping:2,detail:100,support_currencies:2,"depth/{symbol}":2,"depth_commits/{symbol}/{limit}":2,"index_price/{symbol}":2,"fair_price/{symbol}":2,"funding_rate/{symbol}":2,"kline/{symbol}":2,"kline/index_price/{symbol}":2,"kline/fair_price/{symbol}":2,"deals/{symbol}":2,ticker:2,risk_reverse:2,"risk_reverse/history":2,"funding_rate/history":2}},private:{get:{"account/assets":2,"account/asset/{currency}":2,"account/transfer_record":2,"position/list/history_positions":2,"position/open_positions":2,"position/funding_records":2,"position/position_mode":2,"order/list/open_orders/{symbol}":2,"order/list/history_orders":2,"order/external/{symbol}/{external_oid}":2,"order/get/{order_id}":2,"order/batch_query":8,"order/deal_details/{order_id}":2,"order/list/order_deals":2,"planorder/list/orders":2,"stoporder/list/orders":2,"stoporder/order_details/{stop_order_id}":2,"account/risk_limit":2,"account/tiered_fee_rate":2,"position/leverage":2},post:{"position/change_margin":2,"position/change_leverage":2,"position/change_position_mode":2,"order/submit":2,"order/submit_batch":40,"order/cancel":2,"order/cancel_with_external":2,"order/cancel_all":2,"account/change_risk_level":2,"planorder/place":2,"planorder/cancel":2,"planorder/cancel_all":2,"stoporder/cancel":2,"stoporder/cancel_all":2,"stoporder/change_price":2,"stoporder/change_plan_price":2}}},spot2:{public:{get:{"market/symbols":1,"market/coin/list":2,"common/timestamp":1,"common/ping":2,"market/ticker":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/api_default_symbols":2}},private:{get:{"account/info":1,"order/open_orders":1,"order/list":1,"order/query":1,"order/deals":1,"order/deal_detail":1,"asset/deposit/address/list":2,"asset/deposit/list":2,"asset/address/list":2,"asset/withdraw/list":2,"asset/internal/transfer/record":10,"account/balance":10,"asset/internal/transfer/info":10,"market/api_symbols":2},post:{"order/place":1,"order/place_batch":1,"order/advanced/place_batch":1,"asset/withdraw":2,"asset/internal/transfer":10},delete:{"order/cancel":1,"order/cancel_by_symbol":1,"asset/withdraw":2}}},broker:{private:{get:{"sub-account/universalTransfer":1,"sub-account/list":1,"sub-account/apiKey":1,"capital/deposit/subAddress":1,"capital/deposit/subHisrec":1,"capital/deposit/subHisrec/getall":1},post:{"sub-account/virtualSubAccount":1,"sub-account/apiKey":1,"capital/deposit/subAddress":1,"capital/withdraw/apply":1,"sub-account/universalTransfer":1,"sub-account/futures":1},delete:{"sub-account/apiKey":1}}}},precisionMode:a.kb,timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","8h":"8h","1d":"1d","1w":"1w","1M":"1M"},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},options:{adjustForTimeDifference:!1,timeDifference:0,unavailableContracts:{"BTC/USDT:USDT":!0,"LTC/USDT:USDT":!0,"ETH/USDT:USDT":!0},fetchMarkets:{types:{spot:!0,swap:{linear:!0,inverse:!1}}},timeframes:{spot:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"60m","4h":"4h","1d":"1d","1w":"1W","1M":"1M"},swap:{"1m":"Min1","5m":"Min5","15m":"Min15","30m":"Min30","1h":"Min60","4h":"Hour4","8h":"Hour8","1d":"Day1","1w":"Week1","1M":"Month1"}},defaultType:"spot",defaultNetwork:"ETH",defaultNetworks:{ETH:"ETH",USDT:"ERC20",USDC:"ERC20",BTC:"BTC",LTC:"LTC"},networks:{ZKSYNC:"ZKSYNCERA",TRC20:"TRX",TON:"TONCOIN",AVAXC:"AVAX_CCHAIN",ERC20:"ETH",ACA:"ACALA",BEP20:"BSC",OPTIMISM:"OP",ASTR:"ASTAR",BTM:"BTM2",CRC20:"CRONOS",ETHF:"ETF",HRC20:"HECO",OASIS:"ROSE",OKC:"OKT",RSK:"RBTC"},networksById:{"BNB Smart Chain(BEP20-RACAV1)":"BSC","BNB Smart Chain(BEP20-RACAV2)":"BSC","BNB Smart Chain(BEP20)":"BSC"},recvWindow:5e3,maxTimeTillEnd:0x1cf7c57ff,broker:"CCXT"},features:{default:{sandbox:!1,createOrder:{marginMode:!0,triggerPrice:!1,triggerDirection:!1,triggerPriceType:{last:!1,mark:!1,index:!1},stopLossPrice:!1,takeProfitPrice:!1,attachedStopLossTakeProfit:void 0,timeInForce:{IOC:!0,FOK:!0,PO:!0,GTD:!1},hedged:!0,trailing:!1,leverage:!0,marketBuyByCost:!0,marketBuyRequiresPrice:!1,selfTradePrevention:!1,iceberg:!1},createOrders:{max:20},fetchMyTrades:{marginMode:!1,limit:100,daysBack:30,untilDays:void 0},fetchOrder:{marginMode:!1,trigger:!1,trailing:!1},fetchOpenOrders:{marginMode:!0,limit:void 0,trigger:!1,trailing:!1},fetchOrders:{marginMode:!0,limit:1e3,daysBack:7,untilDays:7,trigger:!1,trailing:!1},fetchClosedOrders:{marginMode:!0,limit:1e3,daysBack:7,daysBackCanceled:7,untilDays:7,trigger:!1,trailing:!1},fetchOHLCV:{limit:1e3}},spot:{extends:"default"},forDerivs:{extends:"default",createOrder:{triggerPrice:!0,triggerPriceType:{last:!0,mark:!0,index:!0},triggerDirection:!0,stopLossPrice:!1,takeProfitPrice:!1,hedged:!0,leverage:!0,marketBuyByCost:!1},createOrders:void 0,fetchMyTrades:{marginMode:!1,limit:100,daysBack:90,untilDays:90},fetchOrder:{marginMode:!1},fetchOpenOrders:{marginMode:!1,limit:100,trigger:!0,trailing:!1},fetchOrders:{marginMode:!1,limit:100,daysBack:90,untilDays:90,trigger:!0,trailing:!1},fetchClosedOrders:{marginMode:!1,limit:100,daysBack:90,daysBackCanceled:void 0,untilDays:90,trigger:!0,trailing:!1},fetchOHLCV:{limit:2e3}},swap:{linear:{extends:"forDerivs"},inverse:{extends:"forDerivs"}},future:{linear:void 0,inverse:void 0}},commonCurrencies:{BEYONDPROTOCOL:"BEYOND",BIFI:"BIFIF",BYN:"BEYONDFI",COFI:"COFIX",DFI:"DFISTARTER",DFT:"DFUTURE",DRK:"DRK",EGC:"EGORASCREDIT",FLUX1:"FLUX",FLUX:"FLUX1",FREE:"FREEROSSDAO",GAS:"GASDAO",GASNEO:"GAS",GMT:"GMTTOKEN",STEPN:"GMT",HERO:"STEPHERO",MIMO:"MIMOSA",PROS:"PROSFINANCE",SIN:"SINCITYTOKEN",SOUL:"SOULSWAP"},exceptions:{exact:{"-1128":r.BadRequest,"-2011":r.BadRequest,"-1121":r.BadSymbol,10101:r.InsufficientFunds,2009:r.InvalidOrder,2011:r.BadRequest,30004:r.InsufficientFunds,33333:r.BadRequest,44444:r.BadRequest,1002:r.InvalidOrder,30019:r.BadRequest,30005:r.InvalidOrder,2003:r.InvalidOrder,2005:r.InsufficientFunds,400:r.BadRequest,600:r.BadRequest,70011:r.PermissionDenied,88004:r.InsufficientFunds,88009:r.ExchangeError,88013:r.InvalidOrder,88015:r.InsufficientFunds,700003:r.InvalidNonce,26:r.ExchangeError,602:r.AuthenticationError,10001:r.AuthenticationError,10007:r.BadSymbol,10015:r.BadRequest,10072:r.BadRequest,10073:r.BadRequest,10095:r.InvalidOrder,10096:r.InvalidOrder,10097:r.InvalidOrder,10098:r.InvalidOrder,10099:r.BadRequest,10100:r.BadRequest,10102:r.InvalidOrder,10103:r.ExchangeError,10200:r.BadRequest,10201:r.BadRequest,10202:r.BadRequest,10206:r.BadRequest,10211:r.BadRequest,10212:r.BadRequest,10216:r.ExchangeError,10219:r.ExchangeError,10222:r.BadRequest,10232:r.BadRequest,10259:r.ExchangeError,10265:r.ExchangeError,10268:r.BadRequest,20001:r.ExchangeError,20002:r.ExchangeError,22222:r.BadRequest,3e4:r.ExchangeError,30001:r.InvalidOrder,30002:r.InvalidOrder,30003:r.InvalidOrder,30010:r.InvalidOrder,30014:r.InvalidOrder,30016:r.InvalidOrder,30018:r.AccountSuspended,30020:r.AuthenticationError,30021:r.BadRequest,30025:r.InvalidOrder,30026:r.BadRequest,30027:r.InvalidOrder,30028:r.InvalidOrder,30029:r.InvalidOrder,30032:r.InvalidOrder,30041:r.InvalidOrder,60005:r.ExchangeError,700001:r.AuthenticationError,700002:r.AuthenticationError,700004:r.BadRequest,700005:r.InvalidNonce,700006:r.BadRequest,700007:r.AuthenticationError,700008:r.BadRequest,700013:r.AuthenticationError,730001:r.BadRequest,730002:r.BadRequest,73e4:r.ExchangeError,730003:r.ExchangeError,730100:r.ExchangeError,730600:r.BadRequest,730601:r.BadRequest,730602:r.BadRequest,730700:r.BadRequest,730701:r.BadRequest,730702:r.BadRequest,730703:r.BadRequest,730704:r.BadRequest,730705:r.BadRequest,730706:r.BadRequest,730707:r.BadRequest,730101:r.BadRequest,140001:r.BadRequest,140002:r.AuthenticationError},broad:{"Order quantity error, please try to modify.":r.BadRequest,"Combination of optional parameters invalid":r.BadRequest,"api market order is disabled":r.BadRequest,"Contract not allow place order!":r.InvalidOrder,Oversold:r.InsufficientFunds,"Insufficient position":r.InsufficientFunds,"Insufficient balance!":r.InsufficientFunds,"Bid price is great than max allow price":r.InvalidOrder,"Invalid symbol.":r.BadSymbol,"Param error!":r.BadRequest,maintenance:r.OnMaintenance}}})}async fetchStatus(e={}){let t,i,s;let[r,a]=this.handleMarketTypeAndParams("fetchStatus",void 0,e);return"spot"===r?i=Object.keys(t=await this.spotPublicGetPing(a)).length?this.json(t):"ok":"swap"===r&&(t=await this.contractPublicGetPing(a),i=this.safeValue(t,"success")?"ok":this.json(t),s=this.safeInteger(t,"data")),{status:i,updated:s,url:void 0,eta:void 0,info:t}}async fetchTime(e={}){let t;let[i,s]=this.handleMarketTypeAndParams("fetchTime",void 0,e);return"spot"===i?(t=await this.spotPublicGetTime(s),this.safeInteger(t,"serverTime")):"swap"===i?(t=await this.contractPublicGetPing(s),this.safeInteger(t,"data")):void 0}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;let t=await this.spotPrivateGetCapitalConfigGetall(e),i={};for(let e=0;e<t.length;e++){let s,r,a;let n=t[e],d=this.safeString(n,"coin"),h=this.safeCurrencyCode(d),l=this.safeString(n,"name"),c=!1,f=!1,u=!1,m={},p=this.safeValue(n,"networkList",[]);for(let e=0;e<p.length;e++){let t=p[e],i=this.safeString2(t,"netWork","network"),n=this.networkIdToCode(i),d=this.safeBool(t,"depositEnable",!1),h=this.safeBool(t,"withdrawEnable",!1),l=d&&h;c=l||c;let g=this.safeString(t,"withdrawMin"),v=this.safeString(t,"withdrawMax");r=void 0===r?g:r,a=void 0===a?v:a;let y=this.safeNumber(t,"withdrawFee");s=void 0===s?y:s,o.Y.stringGt(r,g)&&(r=g),o.Y.stringLt(a,v)&&(a=v),d&&(f=!0),h&&(u=!0),m[n]={info:t,id:i,network:n,active:l,deposit:d,withdraw:h,fee:y,precision:void 0,limits:{withdraw:{min:g,max:v}}}}let g=Object.keys(m).length;if(1===g||"NONE"in m){let e=this.safeValue2(m,"NONE",g-1);void 0!==e&&(s=e.fee)}i[h]={info:n,id:d,code:h,name:l,active:c,deposit:f,withdraw:u,fee:s,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:r,max:a}},networks:m}}return i}async fetchMarkets(e={}){this.options.adjustForTimeDifference&&await this.loadTimeDifference();let t=this.fetchSpotMarkets(e),i=this.fetchSwapMarkets(e),[s,r]=await Promise.all([t,i]);return this.arrayConcat(s,r)}async fetchSpotMarkets(e={}){let t=await this.spotPublicGetExchangeInfo(e),i=this.safeValue(t,"symbols",[]),s=[];for(let e=0;e<i.length;e++){let t=i[e],r=this.safeString(t,"symbol"),a=this.safeString(t,"baseAsset"),o=this.safeString(t,"quoteAsset"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h=this.safeString(t,"status"),l=this.safeValue(t,"isSpotTradingAllowed"),c=!1;"1"===h&&l&&(c=!0);let f=this.safeValue(t,"isMarginTradingAllowed"),u=this.safeNumber(t,"makerCommission"),m=this.safeNumber(t,"takerCommission"),p=this.safeNumber(t,"maxQuoteAmount");s.push({id:r,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:f,swap:!1,future:!1,option:!1,active:c,contract:!1,linear:void 0,inverse:void 0,taker:m,maker:u,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"baseAssetPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"quoteAssetPrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"baseSizePrecision"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(t,"quoteAmountPrecision"),max:p}},created:void 0,info:t})}return s}async fetchSwapMarkets(e={}){let t=this.rateLimit;this.setProperty(this,"rateLimit",10);let i=await this.contractPublicGetDetail(e);this.setProperty(this,"rateLimit",t);let s=this.safeValue(i,"data",[]),r=[];for(let e=0;e<s.length;e++){let t=s[e],i=this.safeString(t,"symbol"),a=this.safeString(t,"baseCoin"),o=this.safeString(t,"quoteCoin"),n=this.safeString(t,"settleCoin"),d=this.safeCurrencyCode(a),h=this.safeCurrencyCode(o),l=this.safeCurrencyCode(n),c=this.safeString(t,"state");r.push({id:i,symbol:d+"/"+h+":"+l,base:d,quote:h,settle:l,baseId:a,quoteId:o,settleId:n,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:"0"===c,contract:!0,linear:!0,inverse:!1,taker:this.safeNumber(t,"takerFeeRate"),maker:this.safeNumber(t,"makerFeeRate"),contractSize:this.safeNumber(t,"contractSize"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(t,"volUnit"),price:this.safeNumber(t,"priceUnit")},limits:{leverage:{min:this.safeNumber(t,"minLeverage"),max:this.safeNumber(t,"maxLeverage")},amount:{min:this.safeNumber(t,"minVol"),max:this.safeNumber(t,"maxVol")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return r}async fetchOrderBook(e,t,i={}){let s;await this.loadMarkets();let r=this.market(e),a={symbol:r.id};if(void 0!==t&&(a.limit=t),r.spot){let t=await this.spotPublicGetDepth(this.extend(a,i)),r=this.safeInteger(t,"timestamp");(s=this.parseOrderBook(t,e,r)).nonce=this.safeInteger(t,"lastUpdateId")}else if(r.swap){let t=await this.contractPublicGetDepthSymbol(this.extend(a,i)),r=this.safeValue(t,"data"),o=this.safeInteger(r,"timestamp");(s=this.parseOrderBook(r,e,o)).nonce=this.safeInteger(r,"version")}return s}parseBidAsk(e,t=0,i=1,s=2){let r=this.safeNumber(e,t),a=this.safeNumber(e,i),o=this.safeNumber(e,2);return void 0!==o?[r,a,o]:[r,a]}async fetchTrades(e,t,i,s={}){let a;await this.loadMarkets();let o=this.market(e),n={symbol:o.id};if(void 0!==i&&(n.limit=i),o.spot){let e=this.safeIntegerN(s,["endTime","until"]);if(void 0!==t&&(n.startTime=t,void 0===e))throw new r.ArgumentsRequired(this.id+" fetchTrades() requires an until parameter when since is provided");if(void 0!==e){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchTrades() requires a since parameter when until is provided");n.endTime=e}let i=this.safeString(this.options,"fetchTradesMethod","spotPublicGetAggTrades");if(i=this.safeString(s,"method",i),s=this.omit(s,["method"]),"spotPublicGetAggTrades"===i)a=await this.spotPublicGetAggTrades(this.extend(n,s));else if("spotPublicGetHistoricalTrades"===i)a=await this.spotPublicGetHistoricalTrades(this.extend(n,s));else if("spotPublicGetTrades"===i)a=await this.spotPublicGetTrades(this.extend(n,s));else throw new r.NotSupported(this.id+" fetchTrades() not support this method")}else if(o.swap){let e=await this.contractPublicGetDealsSymbol(this.extend(n,s));a=this.safeValue(e,"data")}return this.parseTrades(a,o,t,i)}parseTrade(e,t){let i,s,r,a,o,n,d,h,l,c;let f=void 0;if("v"in e)s=this.safeInteger(e,"t"),a=(t=this.safeMarket(void 0,t)).symbol,h=this.safeString(e,"p"),l=this.safeString(e,"v"),n=this.parseOrderSide(this.safeString(e,"T")),d="taker";else{let f=this.safeString(e,"symbol");if(a=(t=this.safeMarket(f,t)).symbol,i=this.safeString2(e,"id","a"),h=this.safeString2(e,"price","p"),r=this.safeString(e,"orderId"),"positionMode"in e)s=this.safeInteger(e,"timestamp"),l=this.safeString(e,"vol"),n=this.parseOrderSide(this.safeString(e,"side")),o={cost:this.safeString(e,"fee"),currency:this.safeCurrencyCode(this.safeString(e,"feeCurrency"))},d=this.safeValue(e,"taker")?"taker":"maker";else{s=this.safeInteger2(e,"time","T"),l=this.safeString2(e,"qty","q"),c=this.safeString(e,"quoteQty");let t=this.safeValue(e,"isBuyer"),i=this.safeValue(e,"isMaker"),r=this.safeValue2(e,"isBuyerMaker","m");void 0!==i&&(d=i?"maker":"taker"),void 0!==t&&(n=t?"buy":"sell"),void 0!==r&&(n=r?"sell":"buy",d="taker");let a=this.safeString(e,"commissionAsset");void 0!==a&&(o={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(a)})}}return void 0===i&&(i=this.syntheticTradeId(t,s,n,l,h,f,d)),this.safeTrade({id:i,order:r,timestamp:s,datetime:this.iso8601(s),symbol:a,type:f,side:n,takerOrMaker:d,price:h,amount:l,cost:c,fee:o,info:e},t)}syntheticTradeId(e,t,i,s,r,a,o){let n="";return void 0!==t&&(n=this.numberToString(t)+"-"+this.safeString(e,"id","_"),void 0!==i&&(n+="-"+i),void 0!==s&&(n+="-"+this.numberToString(s)),void 0!==r&&(n+="-"+this.numberToString(r)),void 0!==o&&(n+="-"+o),void 0!==a&&(n+="-"+a)),n}async fetchOHLCV(e,t="1m",i,s,a={}){let o;await this.loadMarkets();let n=this.market(e),d=n.spot?1e3:2e3,h=!1;if([h,a]=this.handleOptionAndParams(a,"fetchOHLCV","paginate",!1),h)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,i,s,t,a,d);let l=this.safeValue(this.options,"timeframes",{}),c=this.safeValue(l,n.type,{}),f=this.safeString(c,t),u=1e3*this.parseTimeframe(t),m={symbol:n.id,interval:f};if(n.spot){let e=this.safeIntegerN(a,["until","endTime"]);if(void 0!==i&&(m.startTime=i,void 0===e)){let e=this.sum(i,d*u),t=this.milliseconds();m.endTime=Math.min(e,t)}void 0!==s&&(m.limit=s),void 0!==e&&(a=this.omit(a,["until"]),m.endTime=e),o=await this.spotPublicGetKlines(this.extend(m,a))}else if(n.swap){let e;let t=this.safeIntegerProductN(a,["until","endTime"],.001);void 0!==i&&(m.start=this.parseToInt(i/1e3)),void 0!==t&&(a=this.omit(a,["until"]),m.end=t);let s=this.safeString(a,"price","default");if(a=this.omit(a,"price"),"default"===s)e=await this.contractPublicGetKlineSymbol(this.extend(m,a));else if("index"===s)e=await this.contractPublicGetKlineIndexPriceSymbol(this.extend(m,a));else if("mark"===s)e=await this.contractPublicGetKlineFairPriceSymbol(this.extend(m,a));else throw new r.NotSupported(this.id+" fetchOHLCV() not support this price type, [default, index, mark]");let n=this.safeValue(e,"data");o=this.convertTradingViewToOHLCV(n,"time","open","high","low","close","vol")}return this.parseOHLCVs(o,n,t,i,s)}parseOHLCV(e,t){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchTickers(e,t={}){let i,s;await this.loadMarkets();let r={},a=!1;if(void 0!==e){a=1===e.length;let t=this.safeString(e,0);i=this.market(t)}let[o,n]=this.handleMarketTypeAndParams("fetchTickers",i,t);if(a&&(r.symbol=i.id),"spot"===o)s=await this.spotPublicGetTicker24hr(this.extend(r,n));else if("swap"===o){let e=await this.contractPublicGetTicker(this.extend(r,n));s=this.safeValue(e,"data",[])}return a&&(s=[s]),this.parseTickers(s,e)}async fetchTicker(e,t={}){let i;await this.loadMarkets();let s=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchTicker",s,t),o={symbol:s.id};if("spot"===r)i=await this.spotPublicGetTicker24hr(this.extend(o,a));else if("swap"===r){let e=await this.contractPublicGetTicker(this.extend(o,a));i=this.safeValue(e,"data",{})}return this.parseTicker(i,s)}parseTicker(e,t){let i,s,r,a,n,d,h,l,c,f,u,m,p;let g=this.safeString(e,"symbol");return t=this.safeMarket(g,t),this.safeValue(t,"swap")||"timestamp"in e?(i=this.safeInteger(e,"timestamp"),s=this.safeString(e,"bid1"),r=this.safeString(e,"ask1"),d=this.safeString(e,"volume24"),h=this.safeString(e,"amount24"),c=this.safeString(e,"high24Price"),f=this.safeString(e,"lower24Price"),m=this.safeString(e,"riseFallValue"),u=this.safeString(e,"riseFallRate")):(i=this.safeInteger(e,"closeTime"),s=this.safeString(e,"bidPrice"),r=this.safeString(e,"askPrice"),a=this.safeString(e,"bidQty"),n=this.safeString(e,"askQty"),o.Y.stringEq(a,"0")&&(a=void 0),o.Y.stringEq(n,"0")&&(n=void 0),d=this.safeString(e,"volume"),h=this.safeString(e,"quoteVolume"),l=this.safeString(e,"openPrice"),c=this.safeString(e,"highPrice"),f=this.safeString(e,"lowPrice"),p=this.safeString(e,"prevClosePrice"),m=this.safeString(e,"priceChange"),u=this.safeString(e,"priceChangePercent")),u=o.Y.stringMul(u,"100"),this.safeTicker({symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),open:l,high:c,low:f,close:this.safeString(e,"lastPrice"),bid:s,bidVolume:a,ask:r,askVolume:n,vwap:void 0,previousClose:p,change:m,percentage:u,average:void 0,baseVolume:d,quoteVolume:h,info:e},t)}async fetchBidsAsks(e,t={}){let i,s;await this.loadMarkets();let a=!1;void 0!==e&&(a=1===e.length,i=this.market(e[0]));let[o,n]=this.handleMarketTypeAndParams("fetchBidsAsks",i,t);if("spot"===o)s=await this.spotPublicGetTickerBookTicker(n);else if("swap"===o)throw new r.NotSupported(this.id+" fetchBidsAsks() is not available for "+o+" markets");return a&&(s=[s]),this.parseTickers(s,e)}async createMarketBuyOrderWithCost(e,t,i={}){if(await this.loadMarkets(),!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return await this.createOrder(e,"market","buy",0,void 0,this.extend({cost:t},i))}async createMarketSellOrderWithCost(e,t,i={}){if(await this.loadMarkets(),!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return await this.createOrder(e,"market","sell",0,void 0,this.extend({cost:t},i))}async createOrder(e,t,i,s,r,a={}){await this.loadMarkets();let o=this.market(e),[n,d]=this.handleMarginModeAndParams("createOrder",a);return o.spot?await this.createSpotOrder(o,t,i,s,r,n,d):await this.createSwapOrder(o,t,i,s,r,n,d)}createSpotOrderRequest(e,t,i,s,a,n,d={}){let h;let l=e.symbol,c=i.toUpperCase(),f={symbol:e.id,side:c,type:t.toUpperCase()};if("market"===t){let e=this.safeNumber2(d,"cost","quoteOrderQty");if(d=this.omit(d,"cost"),void 0!==e)s=e,f.quoteOrderQty=this.costToPrecision(l,s);else if(void 0===a)f.quantity=this.amountToPrecision(l,s);else{let e=this.numberToString(s),t=this.numberToString(a);s=o.Y.stringMul(e,t),f.quoteOrderQty=this.costToPrecision(l,s)}}else f.quantity=this.amountToPrecision(l,s);void 0!==a&&(f.price=this.priceToPrecision(l,a));let u=this.safeString(d,"clientOrderId");if(void 0!==u&&(f.newClientOrderId=u,d=this.omit(d,["type","clientOrderId"])),void 0!==n&&"isolated"!==n)throw new r.BadRequest(this.id+" createOrder() does not support marginMode "+n+" for spot-margin trading");return[h,d]=this.handlePostOnly("market"===t,"LIMIT_MAKER"===t,d),h&&(f.type="LIMIT_MAKER"),this.extend(f,d)}async createSpotOrder(e,t,i,s,r,a,o={}){let n;await this.loadMarkets();let d=this.safeBool(o,"test",!1);o=this.omit(o,"test");let h=this.createSpotOrderRequest(e,t,i,s,r,a,o);n=d?await this.spotPrivatePostOrderTest(h):await this.spotPrivatePostOrder(h);let l=this.parseOrder(n,e);return l.side=i,l.type=t,void 0===this.safeString(l,"price")&&(l.price=r),void 0===this.safeString(l,"amount")&&(l.amount=s),l}async createSwapOrder(e,t,i,s,a,o,n={}){let d,h,l,c;await this.loadMarkets();let f=e.symbol,u=this.safeValue(this.options,"unavailableContracts",{});if(this.safeBool(u,f,!1))throw new r.NotSupported(this.id+" createSwapOrder() does not support yet this symbol:"+f);if(void 0!==o){if("cross"===o)d=2;else if("isolated"===o)d=1;else throw new r.ArgumentsRequired(this.id+' createSwapOrder() marginMode parameter should be either "cross" or "isolated"')}else d=this.safeInteger(n,"openType",2);if("limit"!==t&&"market"!==t&&1!==t&&2!==t&&3!==t&&4!==t&&5!==t&&6!==t)throw new r.InvalidOrder(this.id+" createSwapOrder() order type must either limit, market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for market orders or 6 to convert market price to current price");[h,n]=this.handlePostOnly("market"===t,2===t,n),h?t=2:"limit"===t?t=1:"market"===t&&(t=6);let m={symbol:e.id,vol:parseFloat(this.amountToPrecision(f,s)),type:t,openType:d};if(5!==t&&6!==t&&"market"!==t&&(m.price=parseFloat(this.priceToPrecision(f,a))),1===d&&void 0===this.safeInteger(n,"leverage"))throw new r.ArgumentsRequired(this.id+" createSwapOrder() requires a leverage parameter for isolated margin orders");let p=this.safeBool(n,"reduceOnly",!1);this.safeBool(n,"hedged",!1)?(p&&(n=this.omit(n,"reduceOnly"),i="buy"===i?"sell":"buy"),l="buy"===i?1:3,m.positionMode=1):l=p?"buy"===i?2:4:"buy"===i?1:3,m.side=l;let g=this.safeString2(n,"clientOrderId","externalOid");void 0!==g&&(m.externalOid=g);let v=this.safeNumber2(n,"triggerPrice","stopPrice");n=this.omit(n,["clientOrderId","externalOid","postOnly","stopPrice","triggerPrice","hedged"]),v?(m.triggerPrice=this.priceToPrecision(f,v),m.triggerType=this.safeInteger(n,"triggerType",1),m.executeCycle=this.safeInteger(n,"executeCycle",1),m.trend=this.safeInteger(n,"trend",1),m.orderType=this.safeInteger(n,"orderType",1),c=await this.contractPrivatePostPlanorderPlace(this.extend(m,n))):c=await this.contractPrivatePostOrderSubmit(this.extend(m,n));let y=this.safeString(c,"data");return this.safeOrder({id:y},e)}async createOrders(e,t={}){let i;await this.loadMarkets();let s=[];for(let a=0;a<e.length;a++){let o;let n=e[a],d=this.safeString(n,"symbol"),h=this.market(d);if(!h.spot)throw new r.NotSupported(this.id+" createOrders() is only supported for spot markets");if(void 0===i)i=d;else if(i!==d)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");let l=this.safeString(n,"type"),c=this.safeString(n,"side"),f=this.safeValue(n,"amount"),u=this.safeValue(n,"price"),m=this.safeValue(n,"params",{});[o,t]=this.handleMarginModeAndParams("createOrder",t);let p=this.createSpotOrderRequest(h,l,c,f,u,o,m);s.push(p)}let a={batchOrders:this.json(s)},o=await this.spotPrivatePostBatchOrders(a);return this.parseOrders(o)}async fetchOrder(e,t,i={}){let s;if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();let a=this.market(t),o={symbol:a.id};if(a.spot){let t=this.safeString(i,"clientOrderId");void 0!==t?(i=this.omit(i,"clientOrderId"),o.origClientOrderId=t):o.orderId=e;let[a,n]=this.handleMarginModeAndParams("fetchOrder",i);if(void 0!==a){if("isolated"!==a)throw new r.BadRequest(this.id+" fetchOrder() does not support marginMode "+a+" for spot-margin trading");s=await this.spotPrivateGetMarginOrder(this.extend(o,n))}else s=await this.spotPrivateGetOrder(this.extend(o,n))}else if(a.swap){o.order_id=e;let t=await this.contractPrivateGetOrderGetOrderId(this.extend(o,i));s=this.safeValue(t,"data")}return this.parseOrder(s,a)}async fetchOrders(e,t,i,s={}){let a;await this.loadMarkets();let o={};void 0!==e&&(a=this.market(e),o.symbol=a.id);let n=this.safeInteger(s,"until");s=this.omit(s,"until");let[d,h]=this.handleMarketTypeAndParams("fetchOrders",a,s);if("spot"===d){let d;if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument for spot market");let[h,l]=this.handleMarginModeAndParams("fetchOrders",s);if(void 0!==t&&(o.startTime=t),void 0!==n&&(o.endTime=n),void 0!==i&&(o.limit=i),void 0!==h){if("isolated"!==h)throw new r.BadRequest(this.id+" fetchOrders() does not support marginMode "+h+" for spot-margin trading");d=await this.spotPrivateGetMarginAllOrders(this.extend(o,l))}else d=await this.spotPrivateGetAllOrders(this.extend(o,l));return this.parseOrders(d,a,t,i)}{if(void 0!==t){o.start_time=t;let e=this.safeInteger(s,"end_time",n);if(void 0===e)o.end_time=this.sum(t,this.options.maxTimeTillEnd);else{if(e-t>this.options.maxTimeTillEnd)throw new r.BadRequest(this.id+" end is invalid, i.e. exceeds allowed 90 days.");o.end_time=n}}else void 0!==n&&(o.start_time=this.sum(n,-1*this.options.maxTimeTillEnd),o.end_time=n);void 0!==i&&(o.page_size=i);let e=this.safeString(this.options,"fetchOrders","contractPrivateGetOrderListHistoryOrders");e=this.safeString(h,"method",e);let d=[],l=[];if("contractPrivateGetOrderListHistoryOrders"===e){let e=await this.contractPrivateGetOrderListHistoryOrders(this.extend(o,h));d=this.safeValue(e,"data")}else{let e=await this.contractPrivateGetPlanorderListOrders(this.extend(o,h));l=this.safeValue(e,"data")}let c=this.arrayConcat(l,d);return this.parseOrders(c,a,t,i,s)}}async fetchOrdersByIds(e,t,i={}){let s;await this.loadMarkets();let a={};void 0!==t&&(s=this.market(t),a.symbol=s.id);let[o,n]=this.handleMarketTypeAndParams("fetchOrdersByIds",s,i);if("spot"===o)throw new r.BadRequest(this.id+" fetchOrdersByIds() is not supported for "+o);{a.order_ids=e.join(",");let t=await this.contractPrivateGetOrderBatchQuery(this.extend(a,n)),i=this.safeList(t,"data");return this.parseOrders(i,s)}}async fetchOpenOrders(e,t,i,s={}){let a,o;await this.loadMarkets();let n={};if(void 0!==e&&(a=this.market(e)),[o,s]=this.handleMarketTypeAndParams("fetchOpenOrders",a,s),"spot"!==o)return await this.fetchOrdersByState(2,e,t,i,s);{let o;if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument for spot market");n.symbol=a.id;let[d,h]=this.handleMarginModeAndParams("fetchOpenOrders",s);if(void 0!==d){if("isolated"!==d)throw new r.BadRequest(this.id+" fetchOpenOrders() does not support marginMode "+d+" for spot-margin trading");o=await this.spotPrivateGetMarginOpenOrders(this.extend(n,h))}else o=await this.spotPrivateGetOpenOrders(this.extend(n,h));return this.parseOrders(o,a,t,i)}}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrdersByState(3,e,t,i,s)}async fetchCanceledOrders(e,t,i,s={}){return await this.fetchOrdersByState(4,e,t,i,s)}async fetchOrdersByState(e,t,i,s,a={}){let o;await this.loadMarkets();let n={};void 0!==t&&(o=this.market(t));let[d]=this.handleMarketTypeAndParams("fetchOrdersByState",o,a);if("spot"!==d)return n.states=e,await this.fetchOrders(t,i,s,this.extend(n,a));throw new r.NotSupported(this.id+" fetchOrdersByState() is not supported for "+d)}async cancelOrder(e,t,i={}){let s,a,o;await this.loadMarkets(),void 0!==t&&(s=this.market(t)).id,[a,i]=this.handleMarketTypeAndParams("cancelOrder",s,i);let[n,d]=this.handleMarginModeAndParams("cancelOrder",i);if("spot"===a){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");let a={symbol:s.id},h=this.safeString(i,"clientOrderId");if(void 0!==h?(i=this.omit(d,"clientOrderId"),a.origClientOrderId=h):a.orderId=e,void 0!==n){if("isolated"!==n)throw new r.BadRequest(this.id+" cancelOrder() does not support marginMode "+n+" for spot-margin trading");o=await this.spotPrivateDeleteMarginOrder(this.extend(a,d))}else o=await this.spotPrivateDeleteOrder(this.extend(a,d))}else{let t,i=this.safeString(this.options,"cancelOrder","contractPrivatePostOrderCancel");if("contractPrivatePostOrderCancel"===(i=this.safeString(d,"method",i)))t=await this.contractPrivatePostOrderCancel([e]);else if("contractPrivatePostPlanorderCancel"===i)t=await this.contractPrivatePostPlanorderCancel([e]);else throw new r.NotSupported(this.id+" cancelOrder() not support this method");o=this.safeValue(t,"data");let s=this.safeValue(o,0),a=this.safeValue(s,"errorMsg","");if("success"!==a)throw new r.InvalidOrder(this.id+" cancelOrder() the order with id "+e+" cannot be cancelled: "+a)}return this.parseOrder(o,s)}async cancelOrders(e,t,i={}){await this.loadMarkets();let s=void 0!==t?this.market(t):void 0,[a]=this.handleMarketTypeAndParams("cancelOrders",s,i);if("spot"===a)throw new r.BadRequest(this.id+" cancelOrders() is not supported for "+a);{let t=await this.contractPrivatePostOrderCancel(e),i=this.safeList(t,"data");return this.parseOrders(i,s)}}async cancelAllOrders(e,t={}){let i;await this.loadMarkets();let s=void 0!==e?this.market(e):void 0,a={};[i,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);let[o,n]=this.handleMarginModeAndParams("cancelAllOrders",t);if("spot"===i){let t;if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument on spot");if(a.symbol=s.id,void 0!==o){if("isolated"!==o)throw new r.BadRequest(this.id+" cancelAllOrders() does not support marginMode "+o+" for spot-margin trading");t=await this.spotPrivateDeleteMarginOpenOrders(this.extend(a,n))}else t=await this.spotPrivateDeleteOpenOrders(this.extend(a,n));return this.parseOrders(t,s)}{let t;void 0!==e&&(a.symbol=s.id);let i=this.safeString(this.options,"cancelAllOrders","contractPrivatePostOrderCancelAll");"contractPrivatePostOrderCancelAll"===(i=this.safeString(n,"method",i))?t=await this.contractPrivatePostOrderCancelAll(this.extend(a,n)):"contractPrivatePostPlanorderCancelAll"===i&&(t=await this.contractPrivatePostPlanorderCancelAll(this.extend(a,n)));let r=this.safeList(t,"data",[]);return this.parseOrders(r,s)}}parseOrder(e,t){let i,s;if(void 0!==this.safeInteger(e,"code"))return this.safeOrder({info:e,status:"rejected",clientOrderId:this.safeString(e,"newClientOrderId")});i="string"==typeof e?e:this.safeString2(e,"orderId","id");let r=this.safeString(e,"symbol");t=this.safeMarket(r,t);let a=this.safeIntegerN(e,["time","createTime","transactTime"]),n=this.safeString(e,"feeCurrency");if(void 0!==n){let t=this.safeString(e,"takerFee"),i=this.safeString(e,"makerFee"),r=o.Y.stringAdd(t,i);s={currency:n,cost:this.parseNumber(r)}}return this.safeOrder({id:i,clientOrderId:this.safeString(e,"clientOrderId"),timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,status:this.parseOrderStatus(this.safeString2(e,"status","state")),symbol:t.symbol,type:this.parseOrderType(this.safeString(e,"type")),timeInForce:this.parseOrderTimeInForce(this.safeString(e,"timeInForce")),side:this.parseOrderSide(this.safeString(e,"side")),price:this.safeNumber(e,"price"),triggerPrice:this.safeNumber2(e,"stopPrice","triggerPrice"),average:this.safeNumber(e,"dealAvgPrice"),amount:this.safeNumber2(e,"origQty","vol"),cost:this.safeNumber(e,"cummulativeQuoteQty"),filled:this.safeNumber2(e,"executedQty","dealVol"),remaining:void 0,fee:s,trades:void 0,info:e},t)}parseOrderSide(e){return this.safeString({BUY:"buy",SELL:"sell",1:"buy",2:"sell"},e,e)}parseOrderType(e){return this.safeString({MARKET:"market",LIMIT:"limit",LIMIT_MAKER:"limit"},e,e)}parseOrderStatus(e){return this.safeString({NEW:"open",FILLED:"closed",CANCELED:"canceled",PARTIALLY_FILLED:"open",PARTIALLY_CANCELED:"canceled",2:"open",3:"closed",4:"canceled"},e,e)}parseOrderTimeInForce(e){return this.safeString({GTC:"GTC",FOK:"FOK",IOC:"IOC"},e,e)}async fetchAccountHelper(e,t){if("spot"===e)return await this.spotPrivateGetAccount(t);if("swap"===e){let e=await this.contractPrivateGetAccountAssets(t);return this.safeValue(e,"data")}}async fetchAccounts(e={}){let[t,i]=this.handleMarketTypeAndParams("fetchAccounts",void 0,e);await this.loadMarkets();let s=await this.fetchAccountHelper(t,i),r=this.safeValue(s,"balances",[]),a=[];for(let e=0;e<r.length;e++){let t=r[e],i=this.safeString2(t,"asset","currency"),s=this.safeCurrencyCode(i);a.push({id:this.safeString(t,"id"),type:this.safeString(t,"type"),code:s,info:t})}return a}async fetchTradingFee(e,t={}){await this.loadMarkets();let i=this.market(e);if(!i.spot)throw new r.BadRequest(this.id+" fetchTradingFee() supports spot markets only");let s={symbol:i.id},a=await this.spotPrivateGetTradeFee(this.extend(s,t)),o=this.safeDict(a,"data",{});return{info:o,symbol:e,maker:this.safeNumber(o,"makerCommission"),taker:this.safeNumber(o,"takerCommission"),percentage:void 0,tierBased:void 0}}customParseBalance(e,t){let i;i="margin"===t?this.safeValue(e,"assets",[]):"swap"===t?this.safeValue(e,"data",[]):this.safeValue(e,"balances",[]);let s={info:e};if("margin"===t){for(let e=0;e<i.length;e++){let t=i[e],r=this.safeString(t,"symbol"),a=this.safeSymbol(r,void 0),o=this.safeValue(t,"baseAsset",{}),n=this.safeValue(t,"quoteAsset",{}),d=this.safeCurrencyCode(this.safeString(o,"asset")),h=this.safeCurrencyCode(this.safeString(n,"asset")),l={};l[d]=this.parseBalanceHelper(o),l[h]=this.parseBalanceHelper(n),s[a]=this.safeBalance(l)}return s}if("swap"===t){for(let e=0;e<i.length;e++){let t=i[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"availableBalance"),o.used=this.safeString(t,"frozenBalance"),s[a]=o}return this.safeBalance(s)}for(let e=0;e<i.length;e++){let t=i[e],r=this.safeString(t,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"free"),o.used=this.safeString(t,"locked"),s[a]=o}return this.safeBalance(s)}parseBalanceHelper(e){let t=this.account();t.used=this.safeString(e,"locked"),t.free=this.safeString(e,"free"),t.total=this.safeString(e,"totalAsset");let i=this.safeString(e,"borrowed"),s=this.safeString(e,"interest");return t.debt=o.Y.stringAdd(i,s),t}async fetchBalance(e={}){let t,i;await this.loadMarkets();let s={};[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let a=this.safeString(e,"marginMode"),o=this.safeBool(e,"margin",!1);if(e=this.omit(e,["margin","marginMode"]),void 0!==a||o||"margin"===t){let r;let a=this.safeString(e,"symbol");if(void 0===a){let t=this.safeValue(e,"symbols");void 0!==t&&(r=this.marketIds(t).join(","))}else r=this.market(a).id;this.checkRequiredArgument("fetchBalance",r,"symbol or symbols"),t="margin",s.symbols=r,e=this.omit(e,["symbol","symbols"]),i=await this.spotPrivateGetMarginIsolatedAccount(this.extend(s,e))}else if("spot"===t)i=await this.spotPrivateGetAccount(this.extend(s,e));else if("swap"===t)i=await this.contractPrivateGetAccountAssets(this.extend(s,e));else throw new r.NotSupported(this.id+" fetchBalance() not support this method");return this.customParseBalance(i,t)}async fetchMyTrades(e,t,i,s={}){let a,o;if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();let n=this.market(e);[a,s]=this.handleMarketTypeAndParams("fetchMyTrades",n,s);let d={symbol:n.id};if("spot"===a){void 0!==t&&(d.startTime=t),void 0!==i&&(d.limit=i);let e=this.safeInteger(s,"until");void 0!==e&&(s=this.omit(s,"until"),d.endTime=e),o=await this.spotPrivateGetMyTrades(this.extend(d,s))}else{void 0!==t&&(d.start_time=t,void 0===this.safeInteger(s,"end_time")&&(d.end_time=this.sum(t,this.options.maxTimeTillEnd))),void 0!==i&&(d.page_size=i);let e=await this.contractPrivateGetOrderListOrderDeals(this.extend(d,s));o=this.safeValue(e,"data")}return this.parseTrades(o,n,t,i)}async fetchOrderTrades(e,t,i,s,a={}){let o,n;await this.loadMarkets();let d={};void 0!==t&&(o=this.market(t));let[h,l]=this.handleMarketTypeAndParams("fetchOrderTrades",o,a);if("spot"===h){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrderTrades() requires a symbol argument");d.symbol=o.id,d.orderId=e,n=await this.spotPrivateGetMyTrades(this.extend(d,l))}else{d.order_id=e;let t=await this.contractPrivateGetOrderDealDetailsOrderId(this.extend(d,l));n=this.safeValue(t,"data")}return this.parseTrades(n,o,i,s,l)}async modifyMarginHelper(e,t,i,s={}){let a=this.safeInteger(s,"positionId");if(void 0===a)throw new r.ArgumentsRequired(this.id+" modifyMarginHelper() requires a positionId parameter");return await this.loadMarkets(),await this.contractPrivatePostPositionChangeMargin(this.extend({positionId:a,amount:t,type:i},s))}async reduceMargin(e,t,i={}){return await this.modifyMarginHelper(e,t,"SUB",i)}async addMargin(e,t,i={}){return await this.modifyMarginHelper(e,t,"ADD",i)}async setLeverage(e,t,i={}){await this.loadMarkets();let s={leverage:e},a=this.safeInteger(i,"positionId");if(void 0===a){let e=this.safeNumber(i,"openType"),a=this.safeNumber(i,"positionType"),o=void 0!==t?this.market(t):void 0;if(void 0===e||void 0===a||void 0===o)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a positionId parameter or a symbol argument with openType and positionType parameters, use openType 1 or 2 for isolated or cross margin respectively, use positionType 1 or 2 for long or short positions");s.openType=e,s.symbol=o.id,s.positionType=a}else s.positionId=a;return await this.contractPrivatePostPositionChangeLeverage(this.extend(s,i))}async fetchFundingHistory(e,t,i,s={}){let r;await this.loadMarkets();let a={};void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==i&&(a.page_size=i);let o=await this.contractPrivateGetPositionFundingRecords(this.extend(a,s)),n=this.safeValue(o,"data",{}),d=this.safeValue(n,"resultList",[]),h=[];for(let t=0;t<d.length;t++){let i=d[t],s=this.safeInteger(i,"settleTime");h.push({info:i,symbol:e,code:void 0,timestamp:s,datetime:this.iso8601(s),id:this.safeNumber(i,"id"),amount:this.safeNumber(i,"funding")})}return h}parseFundingRate(e,t){let i;let s=this.safeNumber(e,"fundingRate"),r=this.safeInteger(e,"nextSettleTime"),a=this.safeString(e,"symbol"),o=this.safeSymbol(a,t,void 0,"contract"),n=this.safeInteger(e,"timestamp"),d=this.safeString(e,"collectCycle");return void 0!==d&&(i=d+"h"),{info:e,symbol:o,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:n,datetime:this.iso8601(n),fundingRate:s,fundingTimestamp:r,fundingDatetime:this.iso8601(r),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0,interval:i}}async fetchFundingInterval(e,t={}){return await this.fetchFundingRate(e,t)}async fetchFundingRate(e,t={}){await this.loadMarkets();let i=this.market(e),s={symbol:i.id},r=await this.contractPublicGetFundingRateSymbol(this.extend(s,t)),a=this.safeValue(r,"data",{});return this.parseFundingRate(a,i)}async fetchFundingRateHistory(e,t,i,s={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let a=this.market(e),o={symbol:a.id};void 0!==i&&(o.page_size=i);let n=await this.contractPublicGetFundingRateHistory(this.extend(o,s)),d=this.safeValue(n,"data"),h=this.safeValue(d,"resultList",[]),l=[];for(let e=0;e<h.length;e++){let t=h[e],i=this.safeString(t,"symbol"),s=this.safeSymbol(i),r=this.safeInteger(t,"settleTime");l.push({info:t,symbol:s,fundingRate:this.safeNumber(t,"fundingRate"),timestamp:r,datetime:this.iso8601(r)})}let c=this.sortBy(l,"timestamp");return this.filterBySymbolSinceLimit(c,a.symbol,t,i)}async fetchLeverageTiers(e,t={}){await this.loadMarkets(),e=this.marketSymbols(e,"swap",!0,!0);let i=await this.contractPublicGetDetail(t),s=this.safeList(i,"data");return this.parseLeverageTiers(s,e,"symbol")}parseMarketLeverageTiers(e,t){let i=this.safeString(e,"symbol"),s=this.safeString(e,"maintenanceMarginRate"),r=this.safeString(e,"initialMarginRate"),a=this.safeString(e,"maxVol"),n=this.safeString(e,"riskIncrVol"),d=this.safeString(e,"riskIncrMmr"),h=this.safeString(e,"riskIncrImr"),l="0",c=[],f=this.safeString(e,"quoteCoin");if("0"===n)return[{tier:0,symbol:this.safeSymbol(i,t,void 0,"contract"),currency:this.safeCurrencyCode(f),minNotional:void 0,maxNotional:void 0,maintenanceMarginRate:void 0,maxLeverage:this.safeNumber(e,"maxLeverage"),info:e}];for(;o.Y.stringLt(l,a);){let a=o.Y.stringAdd(l,n);c.push({tier:this.parseNumber(o.Y.stringDiv(a,n)),symbol:this.safeSymbol(i,t,void 0,"contract"),currency:this.safeCurrencyCode(f),minNotional:this.parseNumber(l),maxNotional:this.parseNumber(a),maintenanceMarginRate:this.parseNumber(s),maxLeverage:this.parseNumber(o.Y.stringDiv("1",r)),info:e}),r=o.Y.stringAdd(r,h),s=o.Y.stringAdd(s,d),l=a}return c}parseDepositAddress(e,t){let i=this.safeString(e,"address"),s=this.safeString(e,"coin"),r=this.safeString(e,"netWork");return this.checkAddress(i),{info:e,currency:this.safeCurrencyCode(s,t),network:this.networkIdToCode(r),address:i,tag:this.safeString(e,"memo")}}async fetchDepositAddressesByNetwork(e,t={}){let i;await this.loadMarkets();let s=this.currency(e),r={coin:s.id},a=this.safeString(t,"network");if(void 0!==a){let t=this.networkIdToCode(a,e),r=this.safeDict(s,"networks",{});if(t in r){let e=this.safeDict(r,t,{}),s=this.safeValue(e,"info",{});i=this.safeString(s,"network")}else i=this.networkCodeToId(a,e)}void 0!==i&&(r.network=i),t=this.omit(t,"network");let o=await this.spotPrivateGetCapitalDepositAddress(this.extend(r,t)),n=this.parseDepositAddresses(o,void 0,!1);return this.indexBy(n,"network")}async createDepositAddress(e,t={}){let i;await this.loadMarkets();let s=this.currency(e),a={coin:s.id},o=this.safeString(t,"network");if(void 0===o)throw new r.ArgumentsRequired(this.id+" createDepositAddress requires a `network` parameter");let n=this.networkIdToCode(o,e),d=this.safeDict(s,"networks",{});if(n in d){let e=this.safeDict(d,n,{}),t=this.safeValue(e,"info",{});i=this.safeString(t,"network")}else i=this.networkCodeToId(o,e);void 0!==i&&(a.network=i),t=this.omit(t,"network");let h=await this.spotPrivatePostCapitalDepositAddress(this.extend(a,t));return this.parseDepositAddress(h,s)}async fetchDepositAddress(e,t={}){let i;let s=this.safeString(t,"network"),a=await this.fetchDepositAddressesByNetwork(e,t);if(void 0!==s)i=this.safeDict(a,this.networkIdToCode(s,e));else{let t=this.safeDict(this.options,"defaultNetworks"),s=this.safeString(t,e);if(void 0!==s)i=this.safeDict(a,s);else{let e=Object.keys(a),t=this.safeString(e,0);i=this.safeDict(a,t)}}if(void 0===i)throw new r.InvalidAddress(this.id+" fetchDepositAddress() cannot find a deposit address for "+e+", and network"+s+"consider creating one using .createDepositAddress() method or in MEXC website");return i}async fetchDeposits(e,t,i,s={}){let a;await this.loadMarkets();let o={};if(void 0!==e){a=this.currency(e),o.coin=a.id;let t=this.safeString(s,"network");void 0!==t&&(s=this.omit(s,"network"),o.coin+="-"+t)}if(void 0!==t&&(o.startTime=t),void 0!==i){if(i>1e3)throw new r.ExchangeError("This exchange supports a maximum limit of 1000");o.limit=i}let n=await this.spotPrivateGetCapitalDepositHisrec(this.extend(o,s));return this.parseTransactions(n,a,t,i)}async fetchWithdrawals(e,t,i,s={}){let a;await this.loadMarkets();let o={};if(void 0!==e&&(a=this.currency(e),o.coin=a.id),void 0!==t&&(o.startTime=t),void 0!==i){if(i>1e3)throw new r.ExchangeError("This exchange supports a maximum limit of 1000");o.limit=i}let n=await this.spotPrivateGetCapitalWithdrawHistory(this.extend(o,s));return this.parseTransactions(n,a,t,i)}parseTransaction(e,t){let i,s,r;let a=this.safeString(e,"id"),n=void 0===a?"deposit":"withdrawal",d=this.safeInteger2(e,"insertTime","applyTime"),h=this.safeString(e,"coin");void 0!==h&&(i=h.split("-")[0]);let l=this.safeString(e,"network");void 0!==l&&(s=this.networkIdToCode(l));let c=this.safeCurrencyCode(i,t),f=this.parseTransactionStatusByType(this.safeString(e,"status"),n),u=this.safeString(e,"amount"),m=this.safeString(e,"address"),p=this.safeString(e,"txId"),g=this.safeString(e,"transactionFee");return void 0!==g&&(r={cost:this.parseNumber(g),currency:c}),"withdrawal"===n&&(u=o.Y.stringSub(u,g)),{info:e,id:a,txid:p,timestamp:d,datetime:this.iso8601(d),network:s,address:m,addressTo:m,addressFrom:void 0,tag:this.safeString(e,"memo"),tagTo:void 0,tagFrom:void 0,type:n,amount:this.parseNumber(u),currency:c,status:f,updated:void 0,comment:void 0,internal:void 0,fee:r}}parseTransactionStatusByType(e,t){let i=this.safeValue({deposit:{1:"failed",2:"pending",3:"pending",4:"pending",5:"ok",6:"pending",7:"failed"},withdrawal:{1:"pending",2:"pending",3:"pending",4:"pending",5:"pending",6:"pending",7:"ok",8:"failed",9:"canceled",10:"pending"}},t,{});return this.safeString(i,e,e)}async fetchPosition(e,t={}){await this.loadMarkets();let i={symbol:this.market(e).id},s=await this.fetchPositions(void 0,this.extend(i,t));return this.safeValue(s,0)}async fetchPositions(e,t={}){await this.loadMarkets();let i=await this.contractPrivateGetPositionOpenPositions(t),s=this.safeList(i,"data",[]);return this.parsePositions(s,e)}parsePosition(e,t){let i=(t=this.safeMarket(this.safeString(e,"symbol"),t)).symbol,s=this.safeString(e,"holdVol"),r=this.safeNumber(e,"openAvgPrice"),a=this.safeString(e,"im"),o=this.safeString(e,"positionType"),n=this.safeString(e,"margin_mode"),d=this.safeNumber(e,"leverage"),h=this.safeNumber(e,"liquidatePrice"),l=this.safeInteger(e,"updateTime");return this.safePosition({info:e,id:void 0,symbol:i,contracts:this.parseNumber(s),contractSize:void 0,entryPrice:r,collateral:void 0,side:"1"===o?"long":"short",unrealizedPnl:void 0,leverage:this.parseNumber(d),percentage:void 0,marginMode:"1"===n?"isolated":"cross",notional:void 0,markPrice:void 0,lastPrice:void 0,liquidationPrice:h,initialMargin:this.parseNumber(a),initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,marginRatio:void 0,timestamp:l,datetime:this.iso8601(l),hedged:void 0,stopLossPrice:void 0,takeProfitPrice:void 0,lastUpdateTimestamp:void 0})}async fetchTransfer(e,t,i={}){let[s,a]=this.handleMarketTypeAndParams("fetchTransfer",void 0,i);if(await this.loadMarkets(),"spot"===s){let t=await this.spot2PrivateGetAssetInternalTransferInfo(this.extend({transact_id:e},a)),i=this.safeDict(t,"data",{});return this.parseTransfer(i)}if("swap"===s)throw new r.BadRequest(this.id+" fetchTransfer() is not supported for "+s)}async fetchTransfers(e,t,i,s={}){let a,o;let[n,d]=this.handleMarketTypeAndParams("fetchTransfers",void 0,s);await this.loadMarkets();let h={};if(void 0!==e&&(a=this.currency(e),h.currency=a.id),"spot"===n){if(void 0!==t&&(h.start_time=t),void 0!==i){if(i>50)throw new r.ExchangeError("This exchange supports a maximum limit of 50");h["page-size"]=i}let e=await this.spot2PrivateGetAssetInternalTransferRecord(this.extend(h,d)),s=this.safeValue(e,"data",{});o=this.safeValue(s,"result_list",[])}else if("swap"===n){void 0!==i&&(h.page_size=i);let e=await this.contractPrivateGetAccountTransferRecord(this.extend(h,d)),t=this.safeValue(e,"data");o=this.safeValue(t,"resultList")}return this.parseTransfers(o,a,t,i)}async transfer(e,t,i,s,a={}){await this.loadMarkets();let o=this.currency(e),n={spot:"SPOT",swap:"FUTURES",margin:"ISOLATED_MARGIN"},d=this.safeString(n,i),h=this.safeString(n,s);if(void 0===d){let e=Object.keys(n);throw new r.ExchangeError(this.id+" fromAccount must be one of "+e.join(", "))}if(void 0===h){let e=Object.keys(n);throw new r.ExchangeError(this.id+" toAccount must be one of "+e.join(", "))}let l={asset:o.id,amount:t,fromAccountType:d,toAccountType:h};if("ISOLATED_MARGIN"===d||"ISOLATED_MARGIN"===h){let e=this.safeString(a,"symbol");if(a=this.omit(a,"symbol"),void 0===e)throw new r.ArgumentsRequired(this.id+" transfer() requires a symbol argument for isolated margin");let t=this.market(e);l.symbol=t.id}let c=await this.spotPrivatePostCapitalTransfer(this.extend(l,a)),f=this.parseTransfer(c,o);return this.extend(f,{amount:t,fromAccount:i,toAccount:s})}parseTransfer(e,t){let i,s;let r=this.safeString(e,"currency"),a=this.safeStringN(e,["transact_id","txid","tranId"]),o=this.safeInteger(e,"createTime"),n=void 0!==o?this.iso8601(o):void 0,d=this.safeString(e,"type");return void 0!==d?(i="IN"===d?"MAIN":"CONTRACT",s="IN"===d?"CONTRACT":"MAIN"):(i=this.safeString(e,"from"),s=this.safeString(e,"to")),{info:e,id:a,timestamp:o,datetime:n,currency:this.safeCurrencyCode(r,t),amount:this.safeNumber(e,"amount"),fromAccount:this.parseAccountId(i),toAccount:this.parseAccountId(s),status:this.parseTransferStatus(this.safeString2(e,"transact_state","state"))}}parseAccountId(e){return this.safeString({MAIN:"spot",CONTRACT:"swap"},e,e)}parseTransferStatus(e){return this.safeString({SUCCESS:"ok",FAILED:"failed",WAIT:"pending"},e,e)}async withdraw(e,t,i,s,r={}){await this.loadMarkets();let a=this.currency(e);[s,r]=this.handleWithdrawTagAndParams(s,r);let o=this.safeDict(this.options,"networks",{}),n=this.safeString2(r,"network","netWork");n=this.safeString(o,n,n),n=this.networkCodeToId(n,a.code),this.checkAddress(i);let d={coin:a.id,address:i,amount:t};void 0!==s&&(d.memo=s),void 0!==n&&(d.netWork=n,r=this.omit(r,["network","netWork"]));let h=await this.spotPrivatePostCapitalWithdraw(this.extend(d,r));return this.parseTransaction(h,a)}async setPositionMode(e,t,i={}){return await this.contractPrivatePostPositionChangePositionMode(this.extend({positionMode:e?1:2},i))}async fetchPositionMode(e,t={}){let i=await this.contractPrivateGetPositionPositionMode(t),s=this.safeInteger(i,"data");return{info:i,hedged:1===s}}async fetchTransactionFees(e,t={}){await this.loadMarkets();let i=await this.spotPrivateGetCapitalConfigGetall(t);return this.parseTransactionFees(i,e)}parseTransactionFees(e,t){let i={};for(let s=0;s<e.length;s++){let r=e[s],a=this.safeString(r,"coin"),o=this.safeCurrency(a),n=this.safeString(o,"code");(void 0===t||this.inArray(n,t))&&(i[n]=this.parseTransactionFee(r,o))}return{withdraw:i,deposit:{},info:e}}parseTransactionFee(e,t){let i=this.safeValue(e,"networkList",[]),s={};for(let e=0;e<i.length;e++){let t=i[e],r=this.safeString(t,"network"),a=this.safeString(this.options.networks,r,r),o=this.safeNumber(t,"withdrawFee");s[a]=o}return s}async fetchDepositWithdrawFees(e,t={}){await this.loadMarkets();let i=await this.spotPrivateGetCapitalConfigGetall(t);return this.parseDepositWithdrawFees(i,e,"coin")}parseDepositWithdrawFee(e,t){let i=this.safeValue(e,"networkList",[]),s=this.depositWithdrawFee(e);for(let e=0;e<i.length;e++){let r=i[e],a=this.safeString(r,"network"),o=this.networkIdToCode(a,this.safeString(t,"code"));s.networks[o]={withdraw:{fee:this.safeNumber(r,"withdrawFee"),percentage:void 0},deposit:{fee:void 0,percentage:void 0}}}return this.assignDefaultDepositWithdrawFees(s)}async fetchLeverage(e,t={}){await this.loadMarkets();let i=this.market(e),s={symbol:i.id},r=await this.contractPrivateGetPositionLeverage(this.extend(s,t)),a=this.safeList(r,"data",[]);return this.parseLeverage(a,i)}parseLeverage(e,t){let i,s,r;for(let t=0;t<e.length;t++){let a=e[t],o=this.safeInteger(a,"openType"),n=this.safeInteger(a,"positionType");1===n?s=this.safeInteger(a,"leverage"):2===n&&(r=this.safeInteger(a,"leverage")),i=1===o?"isolated":"cross"}return{info:e,symbol:t.symbol,marginMode:i,longLeverage:s,shortLeverage:r}}handleMarginModeAndParams(e,t={},i){let s;let r=this.safeString(this.options,"defaultType"),a=this.safeBool(t,"margin",!1);return[s,t]=super.handleMarginModeAndParams(e,t,i),("margin"===r||!0===a)&&(s="isolated"),[s,t]}async fetchPositionsHistory(e,t,i,s={}){await this.loadMarkets();let r={};if(void 0!==e&&1===e.length){let t=this.market(e[0]);r.symbol=t.id}void 0!==i&&(r.page_size=i);let a=await this.contractPrivateGetPositionListHistoryPositions(this.extend(r,s)),o=this.safeList(a,"data"),n=this.parsePositions(o,e,s);return this.filterBySinceLimit(n,t,i)}async setMarginMode(e,t,i={}){await this.loadMarkets();let s=this.market(t);if(s.spot)throw new r.BadSymbol(this.id+" setMarginMode() supports contract markets only");if("isolated"!==(e=e.toLowerCase())&&"cross"!==e)throw new r.BadRequest(this.id+" setMarginMode() marginMode argument should be isolated or cross");let a=this.safeInteger(i,"leverage");if(void 0===a)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a leverage parameter");let o=this.safeStringLower2(i,"direction","positionId"),n={leverage:a,openType:"isolated"===e?1:2};void 0!==t&&(n.symbol=s.id),void 0!==o&&(n.positionType="short"===o?2:1),i=this.omit(i,"direction");let d=await this.contractPrivatePostPositionChangeLeverage(this.extend(n,i));return this.parseLeverage(d,s)}nonce(){return this.milliseconds()-this.safeInteger(this.options,"timeDifference",0)}sign(e,t="public",i="GET",s={},r,a){let o;let d=this.safeString(t,0),h=this.safeString(t,1);if([e,s]=this.resolvePath(e,s),"spot"===d||"broker"===d){o="broker"===d?this.urls.api[d][h]+"/"+e:this.urls.api[d][h]+"/api/"+this.version+"/"+e;let t="";"private"===h&&(s.timestamp=this.nonce(),s.recvWindow=this.safeInteger(this.options,"recvWindow",5e3)),Object.keys(s).length&&(o+="?"+(t=this.urlencode(s))),"private"===h&&(this.checkRequiredCredentials(),o+="&signature="+this.hmac(this.encode(t),this.encode(this.secret),n.s),r={"X-MEXC-APIKEY":this.apiKey,source:this.safeString(this.options,"broker","CCXT")}),("POST"===i||"PUT"===i||"DELETE"===i)&&(r["Content-Type"]="application/json")}else if("contract"===d||"spot2"===d){if(o=this.urls.api[d][h]+"/"+this.implodeParams(e,s),s=this.omit(s,this.extractParams(e)),"public"===h)Object.keys(s).length&&(o+="?"+this.urlencode(s));else{this.checkRequiredCredentials();let e=this.nonce().toString(),t="";r={ApiKey:this.apiKey,"Request-Time":e,"Content-Type":"application/json",source:this.safeString(this.options,"broker","CCXT")},"POST"===i?a=t=this.json(s):Object.keys(s=this.keysort(s)).length&&(t+=this.urlencode(s),o+="?"+t),t=this.apiKey+e+t;let d=this.hmac(this.encode(t),this.encode(this.secret),n.s);r.Signature=d}}return{url:o,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,h){if(void 0===n||!0===this.safeBool(n,"success",!1))return;let l=this.safeString(n,"code",void 0);if(void 0!==l&&"200"!==l&&"0"!==l){let e=this.id+" "+o;throw this.throwBroadlyMatchedException(this.exceptions.broad,o,e),this.throwExactlyMatchedException(this.exceptions.exact,l,e),new r.ExchangeError(e)}}}}}]);