"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[616],{2846:(e,t,i)=>{i.d(t,{A:()=>d});var r=i(9007),s=i(8119),a=i(6077),o=i(3675),n=i(5432);class d extends r.A{describe(){return this.deepExtend(super.describe(),{id:"coincatch",name:"CoinCatch",countries:["VG"],rateLimit:50,version:"v1",certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!1,addMargin:!0,cancelAllOrders:!0,cancelAllOrdersAfter:!1,cancelOrder:!0,cancelOrders:!0,cancelWithdraw:!1,closePosition:!1,createConvertTrade:!1,createDepositAddress:!1,createLimitBuyOrder:!0,createLimitSellOrder:!0,createMarketBuyOrder:!0,createMarketBuyOrderWithCost:!0,createMarketOrder:!0,createMarketOrderWithCost:!1,createMarketSellOrder:!0,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createOrderWithTakeProfitAndStopLoss:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopLossOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,createTakeProfitOrder:!0,createTrailingAmountOrder:!1,createTrailingPercentOrder:!1,createTriggerOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchCanceledAndClosedOrders:!0,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:!1,fetchConvertCurrencies:!1,fetchConvertQuote:!1,fetchConvertTrade:!1,fetchConvertTradeHistory:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionHistory:!1,fetchPositionMode:!0,fetchPositions:!0,fetchPositionsForSymbol:!0,fetchPositionsHistory:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!0,reduceMargin:!0,sandbox:!1,setLeverage:!0,setMargin:!1,setMarginMode:!0,setPositionMode:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m",15:"15m",30:"30m","1h":"1H","2h":"2H","4h":"4H","6h":"6H","12h":"12H","1d":"1D","3d":"3D","1w":"1W","1M":"1M"},urls:{logo:"https://github.com/user-attachments/assets/3d49065f-f05d-4573-88a2-1b5201ec6ff3",api:{public:"https://api.coincatch.com",private:"https://api.coincatch.com"},www:"https://www.coincatch.com/",doc:"https://coincatch.github.io/github.io/en/",fees:"https://www.coincatch.com/en/rate/",referral:{url:"https://partner.coincatch.cc/bg/92hy70391729607848548",discount:.1}},api:{public:{get:{"api/spot/v1/public/time":1,"api/spot/v1/public/currencies":20/3,"api/spot/v1/market/ticker":1,"api/spot/v1/market/tickers":1,"api/spot/v1/market/fills":2,"api/spot/v1/market/fills-history":2,"api/spot/v1/market/candles":1,"api/spot/v1/market/history-candles":1,"api/spot/v1/market/depth":1,"api/spot/v1/market/merge-depth":1,"api/mix/v1/market/contracts":1,"api/mix/v1/market/merge-depth":1,"api/mix/v1/market/depth":1,"api/mix/v1/market/ticker":1,"api/mix/v1/market/tickers":1,"api/mix/v1/market/fills":1,"api/mix/v1/market/fills-history":1,"api/mix/v1/market/candles":1,"pi/mix/v1/market/index":1,"api/mix/v1/market/funding-time":1,"api/mix/v1/market/history-fundRate":1,"api/mix/v1/market/current-fundRate":1,"api/mix/v1/market/open-interest":1,"api/mix/v1/market/mark-price":1,"api/mix/v1/market/symbol-leverage":1,"api/mix/v1/market/queryPositionLever":1}},private:{get:{"api/spot/v1/wallet/deposit-address":4,"pi/spot/v1/wallet/withdrawal-list":1,"api/spot/v1/wallet/withdrawal-list-v2":1,"api/spot/v1/wallet/deposit-list":1,"api/spot/v1/account/getInfo":1,"api/spot/v1/account/assets":2,"api/spot/v1/account/transferRecords":1,"api/mix/v1/account/account":2,"api/mix/v1/account/accounts":2,"api/mix/v1/position/singlePosition-v2":2,"api/mix/v1/position/allPosition-v2":4,"api/mix/v1/account/accountBill":2,"api/mix/v1/account/accountBusinessBill":4,"api/mix/v1/order/current":1,"api/mix/v1/order/marginCoinCurrent":1,"api/mix/v1/order/history":2,"api/mix/v1/order/historyProductType":4,"api/mix/v1/order/detail":2,"api/mix/v1/order/fills":2,"api/mix/v1/order/allFills":2,"api/mix/v1/plan/currentPlan":1,"api/mix/v1/plan/historyPlan":2},post:{"api/spot/v1/wallet/transfer-v2":4,"api/spot/v1/wallet/withdrawal-v2":4,"api/spot/v1/wallet/withdrawal-inner-v2":1,"api/spot/v1/account/bills":2,"api/spot/v1/trade/orders":2,"api/spot/v1/trade/batch-orders":{cost:4,step:10},"api/spot/v1/trade/cancel-order":1,"api/spot/v1/trade/cancel-order-v2":2,"api/spot/v1/trade/cancel-symbol-order":2,"api/spot/v1/trade/cancel-batch-orders":1,"api/spot/v1/trade/cancel-batch-orders-v2":1,"api/spot/v1/trade/orderInfo":1,"api/spot/v1/trade/open-orders":1,"api/spot/v1/trade/history":1,"api/spot/v1/trade/fills":1,"api/spot/v1/plan/placePlan":1,"api/spot/v1/plan/modifyPlan":1,"api/spot/v1/plan/cancelPlan":1,"api/spot/v1/plan/currentPlan":1,"api/spot/v1/plan/historyPlan":1,"api/spot/v1/plan/batchCancelPlan":2,"api/mix/v1/account/open-count":1,"api/mix/v1/account/setLeverage":4,"api/mix/v1/account/setMargin":4,"api/mix/v1/account/setMarginMode":4,"api/mix/v1/account/setPositionMode":4,"api/mix/v1/order/placeOrder":2,"api/mix/v1/order/batch-orders":{cost:4,step:10},"api/mix/v1/order/cancel-order":2,"api/mix/v1/order/cancel-batch-orders":2,"api/mix/v1/order/cancel-symbol-orders":2,"api/mix/v1/order/cancel-all-orders":2,"api/mix/v1/plan/placePlan":2,"api/mix/v1/plan/modifyPlan":2,"api/mix/v1/plan/modifyPlanPreset":2,"api/mix/v1/plan/placeTPSL":2,"api/mix/v1/plan/placeTrailStop":2,"api/mix/v1/plan/placePositionsTPSL":2,"api/mix/v1/plan/modifyTPSLPlan":2,"api/mix/v1/plan/cancelPlan":2,"api/mix/v1/plan/cancelSymbolPlan":2,"api/mix/v1/plan/cancelAllPlan":2}}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},fees:{trading:{spot:{tierBased:!1,percentage:!0,feeSide:"get",maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")}}},options:{brokerId:"47cfy",createMarketBuyOrderRequiresPrice:!0,timeframes:{spot:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1day","3d":"3day","1w":"1week","1M":"1M"},swap:{"1m":"1m","3m":"3m","5m":"5m",15:"15m",30:"30m","1h":"1H","2h":"2H","4h":"4H","6h":"6H","12h":"12H","1d":"1D","3d":"3D","1w":"1W","1M":"1M"}},currencyIdsListForParseMarket:void 0,broker:"",networks:{BTC:"BITCOIN",ERC20:"ERC20",TRC20:"TRC20",BEP20:"BEP20",ARB:"ArbitrumOne",OPTIMISM:"Optimism",LTC:"LTC",BCH:"BCH",ETC:"ETC",SOL:"SOL",NEO3:"NEO3",STX:"stacks",EGLD:"Elrond",NEAR:"NEARProtocol",ACA:"AcalaToken",KLAY:"Klaytn",FTM:"Fantom",TERRA:"Terra",WAVES:"WAVES",TAO:"TAO",SUI:"SUI",SEI:"SEI",RUNE:"THORChain",ZIL:"ZIL",SXP:"Solar",FET:"FET",AVAX:"C-Chain",XRP:"XRP",EOS:"EOS",DOGE:"DOGECOIN",CAP20:"CAP20",MATIC:"Polygon",CSPR:"CSPR",GLMR:"Moonbeam",MINA:"MINA",CFX:"CFX",STRAT:"StratisEVM",TIA:"Celestia",ChilizChain:"ChilizChain",APT:"Aptos",ONT:"Ontology",ICP:"ICP",ADA:"Cardano",FIL:"FIL",CELO:"CELO",DOT:"DOT",XLM:"StellarLumens",ATOM:"ATOM",CRO:"CronosChain"},networksById:{BITCOIN:"BTC",ERC20:"ERC20",TRC20:"TRC20","TRX(TRC20)":"TRC20",BEP20:"BEP20",ArbitrumOne:"ARB",Optimism:"OPTIMISM",LTC:"LTC",BCH:"BCH",ETC:"ETC",SOL:"SOL",NEO3:"NEO3",stacks:"STX",Elrond:"EGLD",NEARProtocol:"NEAR",AcalaToken:"ACA",Klaytn:"KLAY",Fantom:"FTM",Terra:"TERRA",WAVES:"WAVES",TAO:"TAO",SUI:"SUI",SEI:"SEI",THORChain:"RUNE",ZIL:"ZIL",Solar:"SXP",FET:"FET","C-Chain":"AVAX",XRP:"XRP",EOS:"EOS",DOGECOIN:"DOGE",CAP20:"CAP20",Polygon:"MATIC",CSPR:"CSPR",Moonbeam:"GLMR",MINA:"MINA",CFXeSpace:"CFX",CFX:"CFX",StratisEVM:"STRAT",Celestia:"TIA",ChilizChain:"ChilizChain",Aptos:"APT",Ontology:"ONT",ICP:"ICP",Cardano:"ADA",FIL:"FIL",CELO:"CELO",DOT:"DOT",StellarLumens:"XLM",ATOM:"ATOM",CronosChain:"CRO"}},features:{default:{sandbox:!1,createOrder:{marginMode:!1,triggerPrice:!0,triggerPriceType:{last:!0,mark:!0,index:!1},triggerDirection:!1,stopLossPrice:!1,takeProfitPrice:!1,attachedStopLossTakeProfit:void 0,timeInForce:{IOC:!0,FOK:!0,PO:!0,GTD:!1},hedged:!1,trailing:!1,leverage:!1,marketBuyByCost:!0,marketBuyRequiresPrice:!1,selfTradePrevention:!1,iceberg:!1},createOrders:{max:50},fetchMyTrades:{marginMode:!1,limit:500,daysBack:1e5,untilDays:1e5},fetchOrder:{marginMode:!1,trigger:!1,trailing:!1},fetchOpenOrders:{marginMode:!1,limit:100,trigger:!0,trailing:!1,marketType:!0},fetchOrders:void 0,fetchClosedOrders:void 0,fetchOHLCV:{limit:1e3}},spot:{extends:"default"},forDerivatives:{extends:"default",createOrder:{attachedStopLossTakeProfit:{triggerPriceType:void 0,price:!1}},fetchMyTrades:{limit:100}},swap:{linear:{extends:"forDerivatives"},inverse:{extends:"forDerivatives"}},future:{linear:void 0,inverse:void 0}},commonCurrencies:{},exceptions:{exact:{22001:s.OrderNotFound,429:s.DDoSProtection,40001:s.AuthenticationError,40002:s.AuthenticationError,40003:s.AuthenticationError,40005:s.InvalidNonce,40006:s.AuthenticationError,40007:s.BadRequest,40008:s.InvalidNonce,40009:s.AuthenticationError,40011:s.AuthenticationError,40012:s.AuthenticationError,40013:s.ExchangeError,40014:s.PermissionDenied,40015:s.ExchangeError,40016:s.PermissionDenied,40017:s.ExchangeError,40018:s.PermissionDenied,40019:s.BadRequest,40020:s.BadRequest,40034:s.BadRequest,400172:s.BadRequest,40912:s.BadRequest,40913:s.BadRequest,40102:s.BadRequest,40200:s.OnMaintenance,40305:s.BadRequest,40409:s.ExchangeError,40704:s.ExchangeError,40724:s.BadRequest,40725:s.ExchangeError,40762:s.InsufficientFunds,40774:s.BadRequest,40808:s.BadRequest,43001:s.OrderNotFound,43002:s.InvalidOrder,43004:s.OrderNotFound,43005:s.RateLimitExceeded,43006:s.BadRequest,43007:s.BadRequest,43008:s.BadRequest,43009:s.BadRequest,43010:s.BadRequest,43011:s.BadRequest,43012:s.InsufficientFunds,43117:s.InsufficientFunds,43118:s.BadRequest,43122:s.BadRequest,45006:s.InsufficientFunds,45110:s.BadRequest},broad:{}},precisionMode:o.kb})}calculateRateLimiterCost(e,t,i,r,s={}){let a=this.safeInteger(s,"step"),o=this.safeInteger(s,"cost",1),n=this.safeList2(r,"orderList","orderDataList",[]).length;return void 0!==a&&n>a?o*Math.ceil(n/a):o}async fetchTime(e={}){let t=await this.publicGetApiSpotV1PublicTime(e);return this.safeInteger(t,"data")}async fetchCurrencies(e={}){let t=await this.publicGetApiSpotV1PublicCurrencies(e),i=this.safeList(t,"data",[]),r={},s=[];for(let e=0;e<i.length;e++){let t,o;let n=i[e],d=this.safeString(n,"coinName");s.push(d);let h=this.safeCurrencyCode(d),l=!1,p=!1,c=this.safeList(n,"chains"),m=this.safeDict(this.options,"networksById"),f={};for(let e=0;e<c.length;e++){let i=c[e],r=this.safeString(i,"chain"),s=this.safeString(m,r,r),n="true"===this.safeString(i,"rechargeable"),d="true"===this.safeString(i,"withdrawable"),h=this.safeString(i,"minDepositAmount"),u=this.safeString(i,"minWithdrawAmount");f[r]={id:r,network:s,limits:{deposit:{min:this.parseNumber(h),max:void 0},withdraw:{min:this.parseNumber(u),max:void 0}},active:n&&d,deposit:n,withdraw:d,fee:this.safeNumber(i,"withdrawFee"),precision:void 0,info:i},l=l||n,p=p||d,t=t?a.Y.stringMin(h,t):h,o=o?a.Y.stringMin(u,o):u}r[h]={id:d,numericId:this.safeInteger(n,"coinId"),code:h,precision:void 0,type:void 0,name:void 0,active:p&&l,deposit:l,withdraw:p,fee:void 0,limits:{deposit:{min:this.parseNumber(t),max:void 0},withdraw:{min:this.parseNumber(o),max:void 0}},networks:f,info:n}}return void 0===this.safeList(this.options,"currencyIdsListForParseMarket")&&(this.options.currencyIdsListForParseMarket=s),r}async fetchMarkets(e={}){let t,i=await this.publicGetApiSpotV1MarketTickers(e);void 0===this.safeList(this.options,"currencyIdsListForParseMarket")&&await this.fetchCurrencies();let r=this.safeList(i,"data",[]),s={};[t,e]=this.handleOptionAndParams(e,"fetchMarkets","productType",t);let a=[];s.productType="umcbl",i=await this.publicGetApiMixV1MarketContracts(this.extend(s,e));let o=this.safeList(i,"data",[]);s.productType="dmcbl",i=await this.publicGetApiMixV1MarketContracts(this.extend(s,e));let n=this.safeList(i,"data",[]),d=[];for(let e=0;e<n.length;e++){let t=n[e],i=this.safeList(t,"supportMarginCoins",[]);for(let e=0;e<i.length;e++){let r={supportMarginCoins:[i[e]]};d.push(this.extend(t,r))}}a=this.arrayConcat(o,d);let h=this.arrayConcat(r,a);return this.parseMarkets(h)}parseMarket(e){let t,i,r,s,o,n=this.safeString(e,"symbol"),d=this.safeDict(this.fees,"trading"),h=this.safeDict(d,"spot"),l=this.safeString(e,"baseCoin"),p=this.safeString(e,"quoteCoin"),c="",m="spot",f=void 0===l;if(f){let e=this.parseSpotMarketId(n);l=this.safeString(e,"baseId"),p=this.safeString(e,"quoteId"),n+="_SPBL"}else{m="swap",h.taker=this.safeNumber(e,"takerFeeRate"),h.maker=this.safeNumber(e,"makerFeeRate");let a=this.safeList(e,"supportMarginCoins",[]);t=this.safeString(a,0),c=":"+(i=this.safeCurrencyCode(t)),r=p===t,s=l===t,r?o="linear":s&&(o="inverse")}let u=this.safeCurrencyCode(l),g=this.safeCurrencyCode(p),v=u+"/"+g+c,y=this.safeString(e,"symbolStatus"),S=this.safeString(e,"volumePlace"),w=this.parsePrecision(S),P=this.safeString(e,"pricePlace"),O=this.safeString(e,"priceEndStep"),k=a.Y.stringMul(this.parsePrecision(P),O);return this.safeMarketStructure({id:n,symbol:v,base:u,quote:g,baseId:l,quoteId:p,active:y?"normal"===y:void 0,type:m,subType:o,spot:f,margin:!f&&void 0,swap:!f,future:!1,option:!1,contract:!f,settle:i,settleId:t,contractSize:this.safeNumber(e,"sizeMultiplier"),linear:r,inverse:s,taker:this.safeNumber(h,"taker"),maker:this.safeNumber(h,"maker"),percentage:this.safeBool(h,"percentage"),tierBased:this.safeBool(h,"tierBased"),feeSide:this.safeString(h,"feeSide"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(w),price:this.parseNumber(k)},limits:{amount:{min:this.safeNumber(e,"minTradeNum"),max:void 0},price:{min:void 0,max:void 0},leverage:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:e})}parseSpotMarketId(e){let t,i;let r=this.safeList(this.options,"currencyIdsListForParseMarket",[]);for(let s=0;s<r.length;s++){let a=r[s],o=e.indexOf(a);if(o>-1){let r=e.replace(a,"");0===o?(t=a,i=r):(t=r,i=a);break}}return{baseId:t,quoteId:i}}async fetchTicker(e,t={}){let i;await this.loadMarkets();let r=this.market(e),a={symbol:r.id};if(r.spot)i=await this.publicGetApiSpotV1MarketTicker(this.extend(a,t));else if(r.swap)i=await this.publicGetApiMixV1MarketTicker(this.extend(a,t));else throw new s.NotSupported(this.id+" fetchTicker() is not supported for "+r.type+" type of markets");let o=this.safeDict(i,"data",{});return this.parseTicker(o,r)}async fetchTickers(e,t={}){let i;let r="fetchTickers";await this.loadMarkets(),e=this.marketSymbols(e,void 0,!0,!0);let a=this.getMarketFromSymbols(e),o="spot";if([o,t]=this.handleMarketTypeAndParams(r,a,t,o),"spot"===o)i=await this.publicGetApiSpotV1MarketTickers(t);else if("swap"===o){let e="umcbl";[e,t]=this.handleOptionAndParams(t,r,"productType",e);let s={productType:e};i=await this.publicGetApiMixV1MarketTickers(this.extend(s,t))}else throw new s.NotSupported(this.id+" "+r+"() is not supported for "+o+" type of markets");let n=this.safeList(i,"data",[]);return this.parseTickers(n,e)}parseTicker(e,t){let i=this.safeInteger2(e,"ts","timestamp"),r=this.safeString(e,"symbol","");0>r.indexOf("_")&&(r+="_SPBL"),t=this.safeMarketCustom(r,t);let s=this.safeString2(e,"close","last");return this.safeTicker({symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high24h"),low:this.safeString(e,"low24h"),bid:this.safeString2(e,"buyOne","bestBid"),bidVolume:this.safeString(e,"bidSz"),ask:this.safeString2(e,"sellOne","bestAsk"),askVolume:this.safeString(e,"askSz"),vwap:void 0,open:this.safeString2(e,"openUtc0","openUtc"),close:s,last:s,previousClose:void 0,change:void 0,percentage:a.Y.stringMul(this.safeString2(e,"changeUtc","chgUtc"),"100"),average:void 0,baseVolume:this.safeString2(e,"baseVol","baseVolume"),quoteVolume:this.safeString2(e,"quoteVol","quoteVolume"),indexPrice:this.safeString(e,"indexPrice"),markPrice:void 0,info:e},t)}async fetchOrderBook(e,t,i={}){let r,a;await this.loadMarkets();let o="fetchOrderBook",n=this.market(e),d={symbol:n.id};if(void 0!==t&&(d.limit=t),[r,i]=this.handleOptionAndParams(i,o,"precision"),void 0!==r&&(d.precision=r),n.spot)a=await this.publicGetApiSpotV1MarketMergeDepth(this.extend(d,i));else if(n.swap)a=await this.publicGetApiMixV1MarketMergeDepth(this.extend(d,i));else throw new s.NotSupported(this.id+" "+o+"() is not supported for "+n.type+" type of markets");let h=this.safeDict(a,"data",{}),l=this.safeInteger(h,"ts");return this.parseOrderBook(h,e,l,"bids","asks")}async fetchOHLCV(e,t="1m",i,r,a={}){let o,n;let d="fetchOHLCV";await this.loadMarkets();let h=this.market(e),l={symbol:h.id};[o,a]=this.handleOptionAndParams(a,d,"until");let p=h.type,c=this.options.timeframes[p],m=this.safeString(c,t,t),f=r;if((void 0!==i||void 0!==o)&&(f=1e3),void 0!==f&&(l.limit=f),h.spot){l.period=m,void 0!==i&&(l.after=i),void 0!==o&&(l.before=o),n=await this.publicGetApiSpotV1MarketCandles(this.extend(l,a));let e=this.safeList(n,"data",[]);return this.parseOHLCVs(e,h,t,i,r)}if(h.swap){let e;return l.granularity=m,void 0===o&&(o=this.milliseconds()),void 0===i&&(i=o-1e6*this.parseTimeframe(t)),l.startTime=i,l.endTime=o,[e,a]=this.handleOptionAndParams(a,d,"price"),"mark"===e&&(l.kLineType="market mark index"),n=await this.publicGetApiMixV1MarketCandles(this.extend(l,a)),this.parseOHLCVs(n,h,t,i,r)}throw new s.NotSupported(this.id+" "+d+"() is not supported for "+h.type+" type of markets")}parseOHLCV(e,t){return[this.safeInteger2(e,"ts",0),this.safeNumber2(e,"open",1),this.safeNumber2(e,"high",2),this.safeNumber2(e,"low",3),this.safeNumber2(e,"close",4),this.safeNumber2(e,"baseVol",5)]}async fetchTrades(e,t,i,r={}){let a,o;let n="fetchTrades";await this.loadMarkets();let d=this.market(e),h={symbol:d.id};[a,r]=this.handleOptionAndParams(r,n,"until");let l=i;if((void 0!==t||void 0!==a)&&(l=1e3,void 0!==t&&(h.startTime=t),void 0!==a&&(h.endTime=a)),void 0!==l&&(h.limit=l),d.spot)o=await this.publicGetApiSpotV1MarketFillsHistory(this.extend(h,r));else if(d.swap)o=await this.publicGetApiMixV1MarketFillsHistory(this.extend(h,r));else throw new s.NotSupported(this.id+" "+n+"() is not supported for "+d.type+" type of markets");let p=this.safeList(o,"data",[]);return this.parseTrades(p,d,t,i)}parseTrade(e,t){let i;let r=this.safeString(e,"symbol");t=this.safeMarketCustom(r,t);let s=this.safeIntegerN(e,["fillTime","timestamp","cTime"]),o=this.safeString2(e,"fees","fee");void 0!==o&&(i=a.Y.stringAbs(o));let n=this.safeString(e,"feeCcy");void 0===n&&void 0!==t.settle&&(n=t.settle);let d=this.safeStringLower2(e,"tradeSide","side");return this.safeTrade({id:this.safeString2(e,"tradeId","fillId"),order:this.safeString(e,"orderId"),timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:this.safeString(e,"orderType"),side:this.parseOrderSide(d),takerOrMaker:this.safeString(e,"takerMakerFlag"),price:this.safeString2(e,"fillPrice","price"),amount:this.safeStringN(e,["fillQuantity","size","sizeQty"]),cost:this.safeString2(e,"fillTotalAmount","fillAmount"),fee:{cost:i,currency:n},info:e},t)}async fetchFundingRate(e,t={}){await this.loadMarkets();let i=this.market(e),r=i.id,s=r.split("_"),a={symbol:r,productType:this.safeString(s,1)},o=await this.publicGetApiMixV1MarketCurrentFundRate(this.extend(a,t)),n=this.safeDict(o,"data",{});return this.parseFundingRate(n,i)}parseFundingRate(e,t){let i=this.safeString(e,"symbol");t=this.safeMarketCustom(i,t);let r=this.safeNumber(e,"fundingRate");return{info:e,symbol:t.symbol,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:r,fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}handleOptionParamsAndRequest(e,t,i,r,s,a){let[o,n]=this.handleOptionAndParams(e,t,i,a);return void 0!==o&&(r[s]=o),[r,n]}async fetchFundingRateHistory(e,t,i,r={}){if(void 0===e)throw new s.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let a=this.market(e),o={symbol:a.id},n=i;void 0!==t&&(n=100),void 0!==n&&(o.pageSize=n);let d=await this.publicGetApiMixV1MarketHistoryFundRate(this.extend(o,r)),h=this.safeList(d,"data",[]),l=[];for(let e=0;e<h.length;e++){let t=h[e],i=this.safeInteger(t,"settleTime");l.push({info:t,symbol:this.safeSymbol(this.safeString(t,"symbol"),a,void 0,"swap"),fundingRate:this.safeNumber(t,"fundingRate"),timestamp:i,datetime:this.iso8601(i)})}let p=this.sortBy(l,"timestamp");return this.filterBySinceLimit(p,t,i)}async fetchBalance(e={}){let t,i;await this.loadMarkets();let r="fetchBalance";if([t,e]=this.handleMarketTypeAndParams(r,void 0,e),"spot"===t)i=await this.privateGetApiSpotV1AccountAssets(e);else if("swap"===t){let t="umcbl";[t,e]=this.handleOptionAndParams(e,r,"productType",t);let s={productType:t};i=await this.privateGetApiMixV1AccountAccounts(this.extend(s,e))}else throw new s.NotSupported(this.id+" "+r+"() is not supported for "+t+" type of markets");let a=this.safeList(i,"data",[]);return this.parseBalance(a)}parseBalance(e){let t={info:e};for(let i=0;i<e.length;i++){let r=this.safeDict(e,i,{}),s=this.safeString2(r,"coinName","marginCoin"),o=this.safeCurrencyCode(s),n=this.account();n.free=this.safeString(r,"available");let d=this.safeString2(r,"lock","locked"),h=this.safeString(r,"frozen","0");n.used=a.Y.stringAdd(d,h),n.total=this.safeString(r,"equity"),t[o]=n}return this.safeBalance(t)}async transfer(e,t,i,r,s={}){let a;await this.loadMarkets();let o=this.currency(e);"swap"===i&&(i="USDT"===e?"mix_usdt":"mix_usd"),"swap"===r&&(r="USDT"===e?"mix_usdt":"mix_usd");let n={coin:o.id,amount:this.currencyToPrecision(e,t),fromType:i,toType:r};[a,s]=this.handleOptionAndParams(s,"transfer","clientOrderId"),void 0!==a&&(n.clientOid=a);let d=await this.privatePostApiSpotV1WalletTransferV2(this.extend(n,s));return this.parseTransfer(d,o)}parseTransfer(e,t){let i;"success"===this.safeString(e,"msg")&&(i="ok");let r=this.safeDict(e,"data",{});return{id:this.safeString(r,"transferId"),timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:i,info:e}}async fetchDepositAddress(e,t={}){let i;await this.loadMarkets();let r=this.currency(e),a={coin:r.id};if([i,t]=this.handleNetworkCodeAndParams(t),void 0===i&&(i=this.defaultNetworkCode(e)),void 0===i)throw new s.ArgumentsRequired(this.id+" fetchDepositAddress() requires a network parameter or a default network code");a.chain=this.networkCodeToId(i,e);let o=await this.privateGetApiSpotV1WalletDepositAddress(this.extend(a,t)),n=this.safeDict(o,"data",{});return this.parseDepositAddress(n,r)}parseDepositAddress(e,t){let i=this.safeString(e,"address");this.checkAddress(i);let r=this.safeString(e,"chain"),s=this.safeString(this.options.networksById,r,r),a=this.safeString(e,"tag");return{currency:t.code,address:i,tag:a,network:s,info:e}}async fetchDeposits(e,t,i,r={}){let s,a;await this.loadMarkets();let o={};void 0!==e&&(s=this.currency(e),o.coin=s.id),void 0!==t&&(o.startTime=t),[a,r]=this.handleOptionAndParams(r,"fetchDeposits","until"),void 0!==a&&(o.endTime=a);let n=await this.privateGetApiSpotV1WalletDepositList(this.extend(o,r)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,s,t,i)}async fetchWithdrawals(e,t,i,r={}){let s,a;await this.loadMarkets();let o={};void 0!==e&&(s=this.currency(e),o.coin=s.id),void 0!==t&&(o.startTime=t),void 0!==i&&(o.limit=i),[a,r]=this.handleOptionAndParams(r,"fetchWithdrawals","until"),void 0!==a&&(o.endTime=a);let n=await this.privateGetApiSpotV1WalletWithdrawalListV2(this.extend(o,r)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,s,t,i)}async withdraw(e,t,i,r,s={}){let a;[r,s]=this.handleWithdrawTagAndParams(r,s),await this.loadMarkets();let o=this.currency(e),n={coin:o.id,address:i,amount:t};void 0!==r&&(n.tag=r),[a,s]=this.handleNetworkCodeAndParams(s),void 0!==a&&(n.chain=this.networkCodeToId(a));let d=await this.privatePostApiSpotV1WalletWithdrawalV2(this.extend(n,s)),h=this.safeDict(d,"data",{});return this.parseTransaction(h,o)}parseTransaction(e,t){let i,r=this.safeString(e,"status");"success"===r&&(r="ok");let s=this.safeString(e,"txId"),a=this.safeString(e,"coin"),o=this.safeCurrencyCode(a,t),n=this.safeInteger(e,"cTime"),d=this.safeNumber(e,"amount"),h=this.safeString(e,"chain"),l=this.safeString(this.options.networksById,h,h),p=this.safeString(e,"toAddress"),c=this.safeString(e,"fromAddress"),m=this.safeString(e,"tag"),f=this.safeString(e,"type"),u=this.safeNumber(e,"fee");return void 0!==u&&(i={cost:u,currency:o}),{info:e,id:this.safeString2(e,"id","orderId"),txid:s,timestamp:n,datetime:this.iso8601(n),network:l,address:void 0,addressTo:p,addressFrom:c,tag:m,tagTo:void 0,tagFrom:void 0,type:f,amount:d,currency:o,status:r,updated:void 0,internal:void 0,comment:void 0,fee:i}}async createMarketBuyOrderWithCost(e,t,i={}){await this.loadMarkets();let r="createMarketBuyOrderWithCost";if(!this.market(e).spot)throw new s.NotSupported(this.id+" "+r+"() supports spot orders only");return i.methodName=r,i.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,i)}async createOrder(e,t,i,r,a,o={}){await this.loadMarkets(),o.methodName=this.safeString(o,"methodName","createOrder");let n=this.market(e);if(n.spot)return await this.createSpotOrder(e,t,i,r,a,o);if(n.swap)return await this.createSwapOrder(e,t,i,r,a,o);throw new s.NotSupported(this.id+" createOrder() is not supported for "+n.type+" type of markets")}async createSpotOrder(e,t,i,r,s,a={}){let o;await this.loadMarkets(),a.methodName=this.safeString(a,"methodName","createSpotOrder");let n=this.createSpotOrderRequest(e,t,i,r,s,a);o=void 0!==this.safeString(n,"triggerPrice")?await this.privatePostApiSpotV1PlanPlacePlan(n):await this.privatePostApiSpotV1TradeOrders(n);let d=this.safeDict(o,"data",{}),h=this.market(e);return this.parseOrder(d,h)}createSpotOrderRequest(e,t,i,r,a,o={}){let n,d,h="createSpotOrderRequest";[h,o]=this.handleParamString(o,"methodName",h);let l={symbol:this.market(e).id,side:i,orderType:t},p="market"===t,c=this.handleTimeInForceAndPostOnly(h,o,p);o=c.params;let m=c.timeInForce;[n,o]=this.handleParamString(o,"cost"),[d,o]=this.handleParamString(o,"triggerPrice");let f=p&&"buy"===i;if(!f&&void 0!==n)throw new s.NotSupported(this.id+" "+h+" supports cost parameter for market buy orders only");if(f){let e=this.handleRequiresPriceAndCost(h,o,a,r,n);n=e.cost,o=e.params}if(void 0===d)"limit"===t&&(l.price=a),l.quantity=f?n:this.numberToString(r),l.force=m||"normal";else{let e,i;l.triggerPrice=d,void 0!==m&&(l.timeInForceValue=m),[e,o]=this.handleParamString(o,"clientOrderId"),void 0!==e&&(l.clientOid=e),"limit"===t&&(l.executePrice=a),i=p?"market_price":"fill_price",l.triggerType=i,l.size=p?n:this.numberToString(r)}return this.extend(l,o)}handleRequiresPriceAndCost(e,t={},i,r,o,n="buy"){let d,h;let l="createMarket"+this.capitalize(n)+"OrderRequiresPrice",p=!0;if([p,t]=this.handleOptionAndParams(t,e,l,!0),void 0!==r&&(d=this.numberToString(r)),void 0!==i&&(h=this.numberToString(i)),p){if(void 0===i&&void 0===o)throw new s.InvalidOrder(this.id+" "+e+"() requires the price argument for market "+n+" orders to calculate the total cost to spend (amount * price), alternatively set the "+l+" option or param to false and pass the cost to spend in the amount argument");void 0===o&&(o=a.Y.stringMul(d,h))}else o=o||d;return{cost:o,params:t}}handleTimeInForceAndPostOnly(e,t={},i=!1){let r;[r,t]=this.handleOptionAndParams(t,e,"timeInForce");let s=!1;return[s,t]=this.handlePostOnly(i,"post_only"===r,t),s&&(r="PO"),{timeInForce:r=this.encodeTimeInForce(r),params:t}}async createSwapOrder(e,t,i,r,s,a={}){let o;a.methodName=this.safeString(a,"methodName","createSwapOrder"),await this.loadMarkets();let n=this.market(e),d=this.createSwapOrderRequest(e,t,i,r,s,a),h=this.safeString(d,"endpointType");d=this.omit(d,"endpointType"),o="trigger"===h?await this.privatePostApiMixV1PlanPlacePlan(d):"tpsl"===h?await this.privatePostApiMixV1PlanPlaceTPSL(d):await this.privatePostApiMixV1OrderPlaceOrder(d);let l=this.safeDict(o,"data",{});return this.parseOrder(l,n)}createSwapOrderRequest(e,t,i,r,s,a={}){let o="createSwapOrderRequest";[o,a]=this.handleParamString(a,"methodName",o);let n=this.market(e),d={symbol:n.id,marginCoin:n.settleId,size:this.amountToPrecision(e,r)};[d,a]=this.handleOptionParamsAndRequest(a,o,"clientOrderId",d,"clientOid");let h="market"===t;a=this.handleTriggerStopLossAndTakeProfit(e,i,t,s,o,a);let l=this.safeString(a,"endpointType");if(void 0===l||"standard"===l){let t=this.handleTimeInForceAndPostOnly(o,a,h);a=t.params;let i=t.timeInForce;void 0!==i&&(d.timeInForceValue=i),void 0!==s&&(d.price=this.priceToPrecision(e,s))}if("tpsl"!==l){d.orderType=t;let e=!1;[e,a]=this.handleOptionAndParams(a,o,"hedged",e);let r=!1;[r,a]=this.handleParamBool(a,"reduceOnly",r),e?r?"buy"===i?i="close_short":"sell"===i&&(i="close_long"):"buy"===i?i="open_long":"sell"===i&&(i="open_short"):i=i.toLowerCase()+"_single",d.side=i}return this.extend(d,a)}handleTriggerStopLossAndTakeProfit(e,t,i,r,a="createOrder",o={}){let n;let d={},h="standard",l=this.safeString(o,"stopLossPrice"),p=this.safeString(o,"takeProfitPrice"),c=this.safeDict(o,"takeProfit"),m=this.safeDict(o,"stopLoss"),f=this.safeString2(o,"triggerPrice","stopPrice"),u=void 0!==f,g=this.safeString(o,"trailingPercent"),v=this.safeString(o,"trailingTriggerPrice"),y=void 0!==p,S=void 0!==l;void 0===c||y||(y=void 0!==(p=this.safeString(c,"triggerPrice"))),void 0===m||S||(S=void 0!==(l=this.safeString(m,"triggerPrice")));let w=void 0!==g,P="market"===i;if(y&&S||u||"createOrderWithTakeProfitAndStopLoss"===a)u&&(P?d.triggerType="market_price":(d.triggerType="fill_price",d.executePrice=this.priceToPrecision(e,r)),d.triggerPrice=this.priceToPrecision(e,f),h="trigger"),"createOrders"===a&&(h=void 0),y&&(d.presetTakeProfitPrice=p),S&&(d.presetStopLossPrice=l);else if(y||S||w){if(!P)throw new s.NotSupported(this.id+" "+a+"() supports does not support "+i+" type of stop loss and take profit orders (only market type is supported for stop loss and take profit orders). To create a market order with stop loss or take profit attached use createOrderWithTakeProfitAndStopLoss()");h="tpsl";let r="long";if("buy"===t&&(r="short"),d.holdSide=r,w){if(void 0===v)throw new s.ArgumentsRequired(this.id+" "+a+"() requires the trailingTriggerPrice parameter for trailing stop orders");n=v,d.rangeRate=g,d.planType="moving_plan"}else y?(n=p,d.planType="profit_plan"):(n=l,d.planType="loss_plan");d.triggerPrice=this.priceToPrecision(e,n)}return void 0!==h&&(d.endpointType=h),o=this.omit(o,["stopLoss","takeProfit","stopLossPrice","takeProfitPrice","triggerPrice","stopPrice","trailingPercent","trailingTriggerPrice"]),this.extend(d,o)}async createOrderWithTakeProfitAndStopLoss(e,t,i,r,a,o,n,d={}){let h="createOrderWithTakeProfitAndStopLoss";if(await this.loadMarkets(),!this.market(e).swap)throw new s.NotSupported(this.id+" "+h+"() is supported for swap markets only");return d.methodName=h,super.createOrderWithTakeProfitAndStopLoss(e,t,i,r,a,o,n,d)}encodeTimeInForce(e){return this.safeString({GTC:"normal",IOC:"iok",FOK:"fok",PO:"post_only"},e,e)}async createOrders(e,t={}){let i,r,a;await this.loadMarkets();let o="createOrders";t.methodName=o;let n=[],d=[];for(let t=0;t<e.length;t++){let i=e[t],r=this.safeString(i,"symbol");d.push(r);let a=this.safeString(i,"type"),h=this.safeString(i,"side"),l=this.safeNumber(i,"amount"),p=this.safeNumber(i,"price"),c=this.safeDict(i,"params",{}),m=this.createOrderRequest(r,a,h,l,p,c);if(void 0!==this.safeString(c,"triggerPrice"))throw new s.NotSupported(this.id+" "+o+"() does not support trigger orders");void 0===this.safeString(m,"clientOrderId")&&(m.clientOrderId=this.uuid()),n.push(m)}if(1!==(d=this.unique(d)).length)throw new s.BadRequest(this.id+" createOrders() requires all orders to be of the same symbol");let h=this.safeString(d,0),l=this.market(h),p={symbol:l.id},c=l.type;if("spot"===c)p.orderList=n,i=await this.privatePostApiSpotV1TradeBatchOrders(this.extend(p,t)),a="resultList";else if(l.swap)p.marginCoin=l.settleId,p.orderDataList=n,i=await this.privatePostApiMixV1OrderBatchOrders(this.extend(p,t)),a="orderInfo";else throw new s.NotSupported(this.id+" "+o+"() is not supported for "+c+" type of markets");let m=this.safeDict(i,"data",{});return r=this.safeList(m,a,[]),this.parseOrders(r)}createOrderRequest(e,t,i,r,a,o={}){let n=this.safeString(o,"methodName","createOrderRequest");o.methodName=n;let d=this.market(e);if(d.spot)return this.createSpotOrderRequest(e,t,i,r,a,o);if(d.swap)return this.createSwapOrderRequest(e,t,i,r,a,o);throw new s.NotSupported(this.id+" "+n+"() is not supported for "+d.type+" type of markets")}async editOrder(e,t,i,r,a,o,n={}){let d="editOrder";n.methodName=d,await this.loadMarkets();let h=this.market(t);if(h.spot)return await this.editSpotOrder(e,t,i,r,a,o,n);throw new s.NotSupported(this.id+" "+d+"() is not supported for "+h.type+" type of markets")}async editSpotOrder(e,t,i,r,a,o,n={}){let d;await this.loadMarkets();let h="editSpotOrder";[h,n]=this.handleParamString(n,"methodName",h);let l=this.market(t);if(!l.spot)throw new s.NotSupported(this.id+" editSpotOrder() does not support "+l.type+" orders");let p={orderType:i},c=this.safeString(n,"clientOrderId");if(void 0!==c)p.clientOid=c;else if(void 0===e)throw new s.BadRequest(this.id+" "+h+"() requires id or clientOrderId");else p.orderId=e;[d,n]=this.handleParamString(n,"cost");let m="market"===i&&"buy"===r;if(!m&&void 0!==d)throw new s.NotSupported(this.id+" "+h+"() supports cost parameter for market buy orders only");if(void 0!==a){if(m){let e=this.handleRequiresPriceAndCost(h,n,o,a,d);d=e.cost,n=e.params}else p.size=this.numberToString(a)}void 0!==d&&(p.size=d),"limit"===i&&void 0!==o&&(p.price=o);let f=await this.privatePostApiSpotV1PlanModifyPlan(this.extend(p,n)),u=this.safeDict(f,"data",{});return this.parseOrder(u,l)}async fetchOrder(e,t,i={}){let r,a,o;let n="fetchOrder";await this.loadMarkets();let d={},h=this.safeString(i,"clientOrderId");void 0===h&&(d.orderId=e),void 0!==t&&(r=this.market(t));let l="spot";if([l,i]=this.handleMarketTypeAndParams(n,r,i,l),"spot"===l){a=await this.privatePostApiSpotV1TradeOrderInfo(this.extend(d,i));let e=this.safeList(a,"data");void 0===e&&(a=JSON.parse(a),e=this.safeList(a,"data",[])),o=this.safeDict(e,0,{})}else if("swap"===l){if(void 0===r)throw new s.ArgumentsRequired(this.id+" "+n+"() requires a symbol argument for "+l+" type of markets");d.symbol=r.id,void 0!==h&&(i=this.omit(i,"clientOrderId"),d.clientOid=h),a=await this.privateGetApiMixV1OrderDetail(this.extend(d,i)),o=this.safeDict(a,"data",{})}else throw new s.NotSupported(this.id+" "+n+"() is not supported for "+l+" type of markets");return this.parseOrder(o,r)}async fetchOpenOrders(e,t,i,r={}){let a;let o="fetchOpenOrders";await this.loadMarkets(),void 0!==e&&(a=this.market(e));let n="spot";if([n,r]=this.handleMarketTypeAndParams(o,a,r,n),r.methodName=o,"spot"===n)return await this.fetchOpenSpotOrders(e,t,i,r);if("swap"===n)return await this.fetchOpenSwapOrders(e,t,i,r);throw new s.NotSupported(this.id+" "+o+"() is not supported for "+n+" type of markets")}async fetchOpenSpotOrders(e,t,i,r={}){let a,o;await this.loadMarkets();let n="fetchOpenSpotOrders";[n,r]=this.handleParamString(r,"methodName",n);let d={};void 0!==e&&(a=this.market(e),d.symbol=a.id);let h=!1;if([h,r]=this.handleOptionAndParams2(r,n,"trigger","stop",h),h){if(void 0===e)throw new s.ArgumentsRequired(this.id+" "+n+"() requires a symbol argument for trigger orders");void 0!==i&&(d.pageSize=i);let t=await this.privatePostApiSpotV1PlanCurrentPlan(this.extend(d,r)),a=this.safeDict(t,"data",{});o=this.safeList(a,"orderList",[])}else{let e=await this.privatePostApiSpotV1TradeOpenOrders(this.extend(d,r));o=this.safeList(e,"data",[])}return this.parseOrders(o,a,t,i)}async fetchOpenSwapOrders(e,t,i,r={}){let a,o,n;await this.loadMarkets();let d="fetchOpenSwapOrders";[d,r]=this.handleParamString(r,"methodName",d);let h=!1;[h,r]=this.handleOptionAndParams2(r,d,"trigger","stop",h),[a,r]=this.handleOptionAndParams(r,d,"isPlan",a);let l=this.handleOption(d,"productType");if(void 0!==e){let t={symbol:(o=this.market(e)).id};h||void 0!==a?(void 0!==l&&(t.productType=l),void 0!==a&&(t.isPlan=a),n=await this.privateGetApiMixV1PlanCurrentPlan(this.extend(t,r))):n=await this.privateGetApiMixV1OrderCurrent(this.extend(t,r))}else if(h)throw new s.ArgumentsRequired(this.id+" "+d+"() requires a symbol argument for swap trigger orders");else{let e;void 0===l&&(l="umcbl");let t={productType:l};void 0!==(e=this.handleOption(d,"marginCoin",e))&&(t.marginCoin=e),n=await this.privateGetApiMixV1OrderMarginCoinCurrent(this.extend(t,r))}let p=this.safeList(n,"data",[]);return this.parseOrders(p,o,t,i)}async fetchCanceledAndClosedOrders(e,t,i,r={}){let a;let o="fetchCanceledAndClosedOrders";await this.loadMarkets(),void 0!==e&&(a=this.market(e));let n="spot";if([n,r]=this.handleMarketTypeAndParams(o,a,r,n),r.methodName=o,"spot"===n)return await this.fetchCanceledAndClosedSpotOrders(e,t,i,r);if("swap"===n)return await this.fetchCanceledAndClosedSwapOrders(e,t,i,r);throw new s.NotSupported(this.id+" "+o+"() is not supported for "+n+" type of markets")}async fetchCanceledAndClosedSpotOrders(e,t,i,r={}){let a,o="fetchCanceledAndClosedSpotOrders";if([o,r]=this.handleParamString(r,"methodName",o),void 0===e)throw new s.ArgumentsRequired(this.id+" "+o+" () requires a symbol argument for spot markets");await this.loadMarkets();let n=this.market(e),d={symbol:n.id},h=i,l=!1;if([l,r]=this.handleOptionAndParams2(r,o,"trigger","stop",l),l){let e;[e,r]=this.handleOptionAndParams(r,o,"until",e);let i=t,s=this.milliseconds();void 0===e&&void 0===i?(i=s-7776e6,e=s):void 0!==e?i=e-7776e6:e=t+7776e6,d.startTime=i,d.endTime=e,void 0===h&&(h=500),d.pageSize=h;let n=await this.privatePostApiSpotV1PlanHistoryPlan(this.extend(d,r)),l=this.safeDict(n,"data",{});a=this.safeList(l,"orderList",[])}else{void 0!==t&&(d.after=t,h=500),void 0!==h&&(d.limit=h);let e=JSON.parse(await this.privatePostApiSpotV1TradeHistory(this.extend(d,r)));a=this.safeList(e,"data",[])}return this.parseOrders(a,n,t,i)}async fetchCanceledAndClosedSwapOrders(e,t,i,r={}){let s,a,o,n,d,h="fetchCanceledAndClosedSwapOrders";[h,r]=this.handleParamString(r,"methodName",h);let l=t;[s,r]=this.handleOptionAndParams(r,h,"until",s);let p=this.milliseconds();void 0===s&&void 0===l?(l=p-7776e6,s=p):void 0!==s?l=s-7776e6:s=t+7776e6;let c={startTime:l,endTime:s};void 0!==i&&(c.pageSize=i),void 0!==e&&(a=this.market(e),c.symbol=a.id);let m=this.handleOption(h,"productType"),f=!1;if([f,r]=this.handleOptionAndParams2(r,h,"trigger","stop",f),[o,r]=this.handleOptionAndParams(r,h,"isPlan",o),f||void 0!==o)void 0!==o&&(c.isPlan=o),void 0!==m&&(c.productType=m),n=await this.privateGetApiMixV1PlanHistoryPlan(this.extend(c,r)),d=this.safeList(n,"data",[]);else{void 0!==e?(a=this.market(e),c.symbol=a.id,n=await this.privateGetApiMixV1OrderHistory(this.extend(c,r))):(void 0===m&&(m="umcbl"),c.productType=m,n=await this.privateGetApiMixV1OrderHistoryProductType(this.extend(c,r)));let t=this.safeDict(n,"data",{});d=this.safeList(t,"orderList",[])}return this.parseOrders(d,a)}async cancelOrder(e,t,i={}){let r,a;let o="cancelOrder";if(void 0===t)throw new s.ArgumentsRequired(this.id+" "+o+" () requires a symbol argument");await this.loadMarkets();let n=this.market(t),d={};if([r,i]=this.handleParamString(i,"clientOrderId"),void 0===e&&void 0===r)throw new s.ArgumentsRequired(this.id+" "+o+" () requires an id argument or clientOrderId parameter");void 0!==r?d.clientOid=r:d.orderId=e;let h=n.type,l=!1;if([l,i]=this.handleOptionAndParams2(i,o,"trigger","stop",l),l&&"spot"===h||(d.symbol=n.id),"spot"===h)a=l?await this.privatePostApiSpotV1PlanCancelPlan(this.extend(d,i)):await this.privatePostApiSpotV1TradeCancelOrderV2(this.extend(d,i));else if("swap"===h){let e;if([e,i]=this.handleOptionAndParams(i,o,"planType",e),d.marginCoin=n.settleId,l||void 0!==e){if(void 0===e)throw new s.ArgumentsRequired(this.id+" "+o+' () requires a planType parameter for swap trigger orders ("profit_plan" - profit order, "loss_plan" - loss order, "normal_plan" - plan order, "pos_profit" - position profit, "pos_loss" - position loss, "moving_plan" - Trailing TP/SL, "track_plan" - Trailing Stop)');d.planType=e,a=await this.privatePostApiMixV1PlanCancelPlan(this.extend(d,i))}else a=await this.privatePostApiMixV1OrderCancelOrder(this.extend(d,i))}else throw new s.NotSupported(this.id+" "+o+"() is not supported for "+h+" type of markets");let p=this.safeDict(a,"data",{});return this.parseOrder(p,n)}async cancelAllOrders(e,t={}){let i,r;let a="cancelAllOrders";await this.loadMarkets(),void 0!==e&&(i=this.market(e));let o={},n="spot";[n,t]=this.handleMarketTypeAndParams(a,i,t,n);let d=!1;if([d,t]=this.handleOptionAndParams2(t,a,"trigger","stop",d),"spot"===n){if(d){void 0!==e&&(o.symbols=[i.id]),r=await this.privatePostApiSpotV1PlanBatchCancelPlan(this.extend(o,t));let s=this.safeList(r,"data",[]);return this.parseOrders(s,i)}if(void 0===e)throw new s.ArgumentsRequired(this.id+" "+a+" () requires a symbol argument for spot non-trigger orders");o.symbol=i.id,r=await this.privatePostApiSpotV1TradeCancelSymbolOrder(this.extend(o,t))}else if("swap"===n){let n,h="umcbl";if(void 0!==e?o.symbol=i.id:(h=this.handleOption(a,"productType",h),o.productType=h),[n,t]=this.handleOptionAndParams(t,a,"planType",n),d||void 0!==n){if(void 0===n)throw new s.ArgumentsRequired(this.id+" "+a+' () requires a planType parameter for swap trigger orders ("profit_plan" - profit order, "loss_plan" - loss order, "normal_plan" - plan order, "pos_profit" - position profit, "pos_loss" - position loss, "moving_plan" - Trailing TP/SL, "track_plan" - Trailing Stop)');o.planType=n,r=void 0!==e?await this.privatePostApiMixV1PlanCancelSymbolPlan(this.extend(o,t)):await this.privatePostApiMixV1PlanCancelAllPlan(this.extend(o,t))}else if(void 0!==e)o.marginCoin=i.settleId,r=await this.privatePostApiMixV1OrderCancelSymbolOrders(this.extend(o,t));else{let e;if("umcbl"===h)e="USDT";else if([e,t]=this.handleOptionAndParams(t,a,"marginCoin",e),void 0===e)throw new s.ArgumentsRequired(this.id+" "+a+" () requires a marginCoin parameter for dmcbl product type");o.marginCoin=e,r=await this.privatePostApiMixV1OrderCancelAllOrders(this.extend(o,t))}let l=this.getResultFromBatchCancelingSwapOrders(r);return this.parseOrders(l,i)}else throw new s.NotSupported(this.id+" "+a+"() is not supported for "+n+" type of markets");let h=this.safeOrder(r);return h.info=r,[h]}async cancelOrders(e,t,i={}){let r,a;let o="cancelOrders";if(void 0===t)throw new s.ArgumentsRequired(this.id+" "+o+"() requires a symbol argument");await this.loadMarkets();let n=this.market(t),d={symbol:n.id},h=n.type,l=this.safeList(i,"clientOrderIds");if(void 0!==l)d.clientOids=l,i=this.omit(i,"clientOrderIds");else if(void 0===e)throw new s.ArgumentsRequired(this.id+" "+o+"() requires either ids argument or clientOrderIds parameter");else d.orderIds=e;if("spot"===h){r=await this.privatePostApiSpotV1TradeCancelBatchOrdersV2(this.extend(d));let e=this.safeDict(r,"data",{});a=this.safeList(e,"resultList",[])}else if("swap"===h)d.marginCoin=n.settleId,r=await this.privatePostApiMixV1OrderCancelBatchOrders(this.extend(d,i)),a=this.getResultFromBatchCancelingSwapOrders(r);else throw new s.NotSupported(this.id+" "+o+"() is not supported for "+h+" type of markets");return this.parseOrders(a,n)}getResultFromBatchCancelingSwapOrders(e){let t=this.safeDict(e,"data",{}),i=[],r=this.safeValue(t,"order_ids",[]);for(let e=0;e<r.length;e++){let t={orderId:r[e]};i.push(t)}return i}parseOrder(e,t){let i,r,s,o;let n=this.safeString(e,"symbol"),d=this.safeString(e,"marginCoin");t=this.safeMarketCustom(n,t,d);let h=this.safeInteger(e,"cTime"),l=this.omitZero(this.safeString2(e,"price","executePrice")),p=this.omitZero(this.safeString(e,"priceAvg"));void 0===l&&(l=p);let c=this.safeString(e,"orderType"),m=this.parseOrderSide(this.safeStringLower(e,"side")),f=this.safeString2(e,"quantity","size"),u=void 0!==this.safeString(e,"triggerType"),g="market"===c&&"buy"===m;t.spot&&g&&!u&&(f=void 0);let v=this.safeString2(e,"status","state"),y=this.safeString(e,"feeDetail");void 0!==y?i=this.parseFeeDetailString(y):(r=d?this.safeCurrencyCode(d):void 0,s=a.Y.stringAbs(this.safeString(e,"fee")));let S=this.parseOrderTimeInForce(this.safeStringLower(e,"timeInForce"));void 0!==S&&(o="PO"===S);let w=this.omitZero(this.safeString(e,"triggerPrice")),P=this.omitZero(this.safeString(e,"presetTakeProfitPrice")),O=this.omitZero(this.safeString2(e,"presetTakeProfitPrice","presetTakeLossPrice")),k=this.safeString(e,"planType");return"loss_plan"===k?O=w:"profit_plan"===k&&(P=w),this.safeOrder({id:this.safeString(e,"orderId"),clientOrderId:this.safeString2(e,"clientOrderId","clientOid"),datetime:this.iso8601(h),timestamp:h,lastTradeTimestamp:void 0,lastUpdateTimestamp:this.safeInteger(e,"uTime"),status:this.parseOrderStatus(v),symbol:t.symbol,type:c,timeInForce:S,side:m,price:l,average:p||this.safeString(e,"fillPrice"),amount:f,filled:this.safeString2(e,"fillQuantity","filledQty"),remaining:void 0,triggerPrice:w,takeProfitPrice:P,stopLossPrice:O,cost:this.safeString2(e,"fillTotalAmount","filledAmount"),trades:void 0,fee:{currency:r,cost:s},fees:i,reduceOnly:this.safeBool(e,"reduceOnly"),postOnly:o,info:e},t)}parseOrderStatus(e){return this.safeString({not_trigger:"open",init:"open",new:"open",partially_filled:"open",full_fill:"closed",filled:"closed",cancel:"canceled",canceled:"canceled",cancelled:"canceled"},e,e)}parseOrderSide(e){return this.safeString({buy:"buy",sell:"sell",open_long:"buy",open_short:"sell",close_long:"sell",close_short:"buy",reduce_close_long:"sell",reduce_close_short:"buy",offset_close_long:"sell",offset_close_short:"buy",burst_close_long:"sell",burst_close_short:"buy",delivery_close_long:"sell",delivery_close_short:"buy",buy_single:"buy",sell_single:"sell"},e,e)}parseOrderTimeInForce(e){return this.safeString({normal:"GTC",post_only:"PO",iok:"IOC",fok:"FOK"},e,e)}parseFeeDetailString(e){let t=[],i=this.parseJson(e);if(i){let e=Object.keys(i);for(let r=0;r<e.length;r++){let s=this.safeString(e,r);if(s in this.currencies_by_id){let e=this.safeCurrencyCode(s),r=this.safeDict(i,s,{}),o=a.Y.stringAbs(this.safeString(r,"totalFee"));t.push({currency:e,amount:o})}}}return t}async fetchMyTrades(e,t,i,r={}){let a,o,n="fetchMyTrades";[n,r]=this.handleParamString(r,"methodName",n),await this.loadMarkets();let d="spot",h={};if(void 0!==e)d=(a=this.market(e)).type,h.symbol=a.id;else if([d,r]=this.handleMarketTypeAndParams(n,a,r,d),"spot"===d)throw new s.ArgumentsRequired(this.id+" "+n+"() requires a symbol argument for spot markets");let l=i;if("spot"===d)void 0!==t&&(l=500),void 0!==l&&(h.limit=l),o=await this.privatePostApiSpotV1TradeFills(this.extend(h,r));else if("swap"===d){let i;if(void 0!==t?r.startTime=t:r.startTime=0,[i,r]=this.handleOptionAndParams(r,n,"until"),void 0!==i?h.endTime=i:h.endTime=this.milliseconds(),void 0!==e)o=await this.privateGetApiMixV1OrderFills(this.extend(h,r));else{let e="umcbl";e=this.handleOption(n,"productType",e),h.productType=e,o=await this.privateGetApiMixV1OrderAllFills(this.extend(h,r))}}else throw new s.NotSupported(this.id+" "+n+"() is not supported for "+d+" type of markets");let p=this.safeList(o,"data",[]);return this.parseTrades(p,a,t,i)}async fetchOrderTrades(e,t,i,r,a={}){let o="fetchOrderTrades";if(void 0===t)throw new s.ArgumentsRequired(this.id+" "+o+" () requires a symbol argument");return await this.fetchMyTrades(t,i,r,this.extend({orderId:e,methodName:o},a))}async fetchMarginMode(e,t={}){await this.loadMarkets();let i=this.market(e),r={symbol:i.id,marginCoin:i.settleId},s=await this.privateGetApiMixV1AccountAccount(this.extend(r,t)),a=this.safeDict(s,"data",{});return this.parseMarginMode(a,i)}parseMarginMode(e,t){let i=this.safeStringLower(e,"marginMode");return{info:e,symbol:this.safeSymbol(void 0,t),marginMode:this.parseMarginModeType(i)}}parseMarginModeType(e){return this.safeString({crossed:"cross",fixed:"isolated"},e,e)}async setMarginMode(e,t,i={}){if(void 0===t)throw new s.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");e=e.toLowerCase(),await this.loadMarkets();let r=this.market(t);if("swap"!==r.type)throw new s.NotSupported(this.id+" setMarginMode() is not supported for "+r.type+" type of markets");let a={symbol:r.id,marginCoin:r.settleId,marginMode:this.encodeMarginModeType(e)};return await this.privatePostApiMixV1AccountSetMarginMode(this.extend(a,i))}encodeMarginModeType(e){return this.safeString({cross:"crossed",isolated:"fixed"},e,e)}async fetchPositionMode(e,t={}){if(void 0===e)throw new s.ArgumentsRequired(this.id+" fetchPositionMode() requires a symbol argument");await this.loadMarkets();let i=this.market(e);if("swap"!==i.type)throw new s.NotSupported(this.id+" fetchPositionMode() is not supported for "+i.type+" type of markets");let r={symbol:i.id,marginCoin:i.settleId},a=await this.privateGetApiMixV1AccountAccount(this.extend(r,t)),o=this.safeDict(a,"data",{});return{info:a,hedged:"double_hold"===this.safeString(o,"holdMode")}}async setPositionMode(e,t,i={}){await this.loadMarkets();let r=this.safeString(i,"productType");if(void 0===r){if(void 0!==t){let e=this.market(t);if("swap"!==e.type)throw new s.NotSupported(this.id+" setPositionMode() is not supported for "+e.type+" type of markets");let i=e.id.split("_");r=this.safeStringLower(i,1,r)}else r=this.handleOption("setPositionMode","productType","umcbl")}let a={productType:r,holdMode:e?"double_hold":"single_hold"};return await this.privatePostApiMixV1AccountSetPositionMode(this.extend(a,i))}async fetchLeverage(e,t={}){await this.loadMarkets();let i=this.market(e);if("swap"!==i.type)throw new s.NotSupported(this.id+" fetchLeverage() is not supported for "+i.type+" type of markets");let r={symbol:i.id,marginCoin:i.settleId},a=await this.privateGetApiMixV1AccountAccount(this.extend(r,t)),o=this.safeDict(a,"data",{});return this.parseLeverage(o,i)}async setLeverage(e,t,i={}){let r;let a="setLeverage";if(void 0===t)throw new s.ArgumentsRequired(this.id+" "+a+"() requires a symbol argument");await this.loadMarkets();let o=this.market(t);if("swap"!==o.type)throw new s.NotSupported(this.id+" "+a+"() is not supported for "+o.type+" type of markets");let n={symbol:o.id,marginCoin:o.settleId,leverage:e};[r,i]=this.handleOptionAndParams(i,a,"side"),void 0!==r&&(n.holdSide=r);let d=await this.privatePostApiMixV1AccountSetLeverage(this.extend(n,i)),h=this.safeDict(d,"data",{});return this.parseLeverage(h,o)}parseLeverage(e,t){let i=this.safeString(e,"symbol");t=this.safeMarketCustom(i,t);let r=this.parseMarginModeType(this.safeStringLower(e,"marginMode")),s=this.safeInteger2(e,"fixedLongLeverage","longLeverage"),a=this.safeInteger2(e,"fixedShortLeverage","shortLeverage"),o=this.safeInteger(e,"crossMarginLeverage");return"cross"===r&&(s=o,a=o),{info:e,symbol:t.symbol,marginMode:r,longLeverage:s,shortLeverage:a}}async modifyMarginHelper(e,t,i,r={}){let o,n="modifyMarginHelper";[n,r]=this.handleParamString(r,"methodName",n),await this.loadMarkets();let d=this.market(e);if("swap"!==d.type)throw new s.NotSupported(this.id+" "+n+"() is not supported for "+d.type+" type of markets");t=this.amountToPrecision(e,t);let h={symbol:d.id,marginCoin:d.settleId,amount:t};[o,r]=this.handleOptionAndParams(r,n,"side"),void 0!==o&&(h.holdSide=o);let l=await this.privatePostApiMixV1AccountSetMargin(this.extend(h,r));return"reduce"===i&&(t=a.Y.stringAbs(t)),this.extend(this.parseMarginModification(l,d),{amount:this.parseNumber(t),type:i})}parseMarginModification(e,t){let i=this.safeString(e,"msg");return{info:e,symbol:t.symbol,type:void 0,marginMode:void 0,amount:void 0,total:void 0,code:t.quote,status:"success"===i?"ok":"failed",timestamp:void 0,datetime:void 0}}async reduceMargin(e,t,i={}){return i.methodName="reduceMargin",await this.modifyMarginHelper(e,-t,"reduce",i)}async addMargin(e,t,i={}){return i.methodName="addMargin",await this.modifyMarginHelper(e,t,"add",i)}async fetchPosition(e,t={}){let i="long";[i,t]=this.handleOptionAndParams(t,"fetchPosition","side");let r=await this.fetchPositionsForSymbol(e,t);if(r.length>1)for(let e=0;e<r.length;e++){let t=r[e];if(t.side===i)return t}return r[0]}async fetchPositionsForSymbol(e,t={}){await this.loadMarkets();let i=this.market(e),r={symbol:i.id,marginCoin:i.settleId},s=await this.privateGetApiMixV1PositionSinglePositionV2(this.extend(r,t)),a=this.safeList(s,"data",[]);return this.parsePositions(a,[e])}async fetchPositions(e,t={}){let i="fetchPositions";await this.loadMarkets();let r="umcbl";if(void 0!==e){let t=this.marketIds(e),a=[];for(let e=0;e<t.length;e++){let i=t[e].split("_"),r=this.safeString(i,1);a.push(r)}if((a=this.unique(a)).length>1)throw new s.BadSymbol(this.id+" "+i+"() requires all symbols to belong to the same product type (umcbl or dmcbl)");r=a[0]}else[r,t]=this.handleOptionAndParams(t,i,"productType",r);let a={productType:r};if("dmcbl"===r){let e;if([e,t]=this.handleOptionAndParams(t,i,"marginCoin"),void 0!==e){let t=this.currency(e);a.marginCoin=t.id}}let o=await this.privateGetApiMixV1PositionAllPositionV2(this.extend(a,t)),n=this.safeList(o,"data",[]);return this.parsePositions(n,e)}parsePosition(e,t){let i;let r=this.safeString(e,"symbol"),s=this.safeString(e,"marginCoin");t=this.safeMarketCustom(r,t,s);let o=this.safeInteger(e,"cTime"),n=this.safeString(e,"marginMode"),d=this.safeString(e,"holdMode");"double_hold"===d?i=!0:"single_hold"===d&&(i=!1);let h=this.safeNumber(e,"margin"),l=this.safeString(e,"keepMarginRate");return this.safePosition({symbol:t.symbol,id:void 0,timestamp:o,datetime:this.iso8601(o),contracts:this.safeNumber(e,"total"),contractSize:void 0,side:this.safeStringLower(e,"holdSide"),notional:h,leverage:this.safeInteger(e,"leverage"),unrealizedPnl:this.safeNumber(e,"unrealizedPL"),realizedPnl:this.safeNumber(e,"achievedProfits"),collateral:void 0,entryPrice:this.safeNumber(e,"averageOpenPrice"),markPrice:this.safeNumber(e,"marketPrice"),liquidationPrice:this.safeNumber(e,"liquidationPrice"),marginMode:this.parseMarginModeType(n),hedged:i,maintenanceMargin:void 0,maintenanceMarginPercentage:this.parseNumber(a.Y.stringMul(l,"100")),initialMargin:h,initialMarginPercentage:void 0,marginRatio:this.safeNumber(e,"marginRatio"),lastUpdateTimestamp:this.safeInteger(e,"uTime"),lastPrice:void 0,stopLossPrice:void 0,takeProfitPrice:void 0,percentage:void 0,info:e})}safeMarketCustom(e,t,i){try{t=this.safeMarket(e,t)}catch(s){let r=this.safeList(this.markets_by_id,e,[]);if(void 0===i)t=r[0];else for(let e=0;e<r.length;e++){let s=r[e];if(s.settleId===i){t=s;break}}}return t}async fetchLedger(e,t,i,r={}){let a,o;let n="fetchLedger";await this.loadMarkets();let d={},h="spot";if([h,r]=this.handleMarketTypeAndParams(n,void 0,r,h),void 0!==e&&(o=this.currency(e)),"spot"===h){if(void 0!==o){let e=this.safeString(o,"numericId");d.coinId=e}void 0!==i&&(d.limit=i);let e=await this.privatePostApiSpotV1AccountBills(this.extend(d,r));a=this.safeList(e,"data",[])}else if("swap"===h){let s;void 0!==t?d.startTime=t:d.startTime=0,[s,r]=this.handleOptionAndParams(r,n,"until"),void 0!==s?d.endTime=s:d.endTime=this.milliseconds(),void 0!==i&&(d.pageSize=i);let o="umcbl";o=void 0===e?this.handleOption(n,"productType",o):"USDT"===e?"umcbl":"dmcbl",[o,r]=this.handleParamString(r,"productType",o),d.productType=o;let h=await this.privateGetApiMixV1AccountAccountBusinessBill(this.extend(d,r)),l=this.safeDict(h,"data",{});a=this.safeList(l,"result",[])}else throw new s.NotSupported(this.id+" "+n+"() does not support market type "+h);return this.parseLedger(a,o,t,i)}parseLedgerEntry(e,t){let i;let r=this.safeInteger(e,"cTime"),s=this.safeString2(e,"coinName","marginCoin"),o=this.safeString(e,"symbol");i=this.safeMarketCustom(o,i,s);let n=this.safeString2(e,"quantity","amount"),d="in";a.Y.stringLt(n,"0")&&(d="out",n=a.Y.stringMul(n,"-1"));let h={cost:a.Y.stringAbs(this.safeString2(e,"fee","fees")),currency:this.safeString(e,"feeCoin")};return this.safeLedgerEntry({id:this.safeString2(e,"billId","id"),info:e,timestamp:r,datetime:this.iso8601(r),account:void 0,direction:d,referenceId:void 0,referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeStringLower2(e,"bizType","business")),currency:this.safeCurrencyCode(s,t),symbol:i.symbol,amount:n,before:void 0,after:this.safeString(e,"balance"),status:"ok",fee:h},t)}parseLedgerEntryType(e){return this.safeString({deposit:"deposit",withdraw:"withdrawal",buy:"trade",sell:"trade","deduction of handling fee":"fee","transfer-in":"transfer","transfer in":"transfer","transfer out":"transfer","rebate rewards":"rebate","airdrop rewards":"rebate","usdt contract rewards":"rebate","mix contract rewards":"rebate","system lock":"system lock","user lock":"user lock",open_long:"trade",open_short:"trade",close_long:"trade",close_short:"trade",trans_from_exchange:"transfer",trans_to_exchange:"transfer",contract_settle_fee:"fee",burst_long_loss_query:"trade",burst_short_loss_query:"trade"},e,e)}handleErrors(e,t,i,r,a,o,n,d,h){if(!n)return;let l=this.safeString(n,"msg"),p=this.id+" "+o,c=this.safeString(n,"code"),m="success"===l||void 0===l;if(i.indexOf("batch")>=0){let e=this.safeDict(n,"data",{}),t=this.safeList2(e,"failure","fail_infos",[]);if(!this.isEmpty(t)){m=!1;let e=this.safeDict(t,0,{});c=this.safeString(e,"errorCode"),l=this.safeString(e,"errorMsg")}}if(!m)throw this.throwExactlyMatchedException(this.exceptions.exact,c,p),this.throwBroadlyMatchedException(this.exceptions.broad,l,p),new s.ExchangeError(p)}sign(e,t="public",i="GET",r={},s,a){let o="/"+e;if("GET"===i){let e=this.urlencode(r);0!==e.length&&(o+="?"+e)}if("private"===t){this.checkRequiredCredentials();let e=this.numberToString(this.milliseconds()),t="";"GET"!==i&&(t=a=this.json(r));let d=e+i+o+t,h=this.hmac(this.encode(d),this.encode(this.secret),n.s,"base64");s={"ACCESS-KEY":this.apiKey,"ACCESS-SIGN":h,"ACCESS-TIMESTAMP":e,"ACCESS-PASSPHRASE":this.password,"Content-Type":"application/json","X-CHANNEL-API-CODE":this.safeString(this.options,"brokerId","47cfy")}}return{url:this.urls.api[t]+o,method:i,body:a,headers:s}}}}}]);