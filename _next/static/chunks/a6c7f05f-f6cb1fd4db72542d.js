"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[295],{5985:(e,t,i)=>{i.d(t,{A:()=>d});var s=i(9719),r=i(8119),a=i(6077),o=i(3675),n=i(5432);class d extends s.A{describe(){return this.deepExtend(super.describe(),{id:"bitmart",name:"BitMart",countries:["US","CN","HK","KR"],rateLimit:33.34,version:"v2",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,borrowCrossMargin:!1,borrowIsolatedMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createPostOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,createTrailingPercentOrder:!0,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositWithdrawFee:!0,fetchDepositWithdrawFees:!1,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIsolatedBorrowRate:!0,fetchIsolatedBorrowRates:!0,fetchLedger:!0,fetchLiquidations:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMyLiquidations:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactionFee:!0,fetchTransactionFees:!1,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawAddressesByNetwork:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!0,setLeverage:!0,setMarginMode:!1,transfer:!0,withdraw:!0},hostname:"bitmart.com",urls:{logo:"https://github.com/user-attachments/assets/0623e9c4-f50e-48c9-82bd-65c3908c3a14",api:{spot:"https://api-cloud.{hostname}",swap:"https://api-cloud-v2.{hostname}"},www:"https://www.bitmart.com/",doc:"https://developer-pro.bitmart.com/",referral:{url:"http://www.bitmart.com/?r=rQCFLh",discount:.3},fees:"https://www.bitmart.com/fee/en"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:{"system/time":3,"system/service":3,"spot/v1/currencies":7.5,"spot/v1/symbols":7.5,"spot/v1/symbols/details":5,"spot/quotation/v3/tickers":6,"spot/quotation/v3/ticker":4,"spot/quotation/v3/lite-klines":5,"spot/quotation/v3/klines":7,"spot/quotation/v3/books":4,"spot/quotation/v3/trades":4,"spot/v1/ticker":5,"spot/v2/ticker":30,"spot/v1/ticker_detail":5,"spot/v1/steps":30,"spot/v1/symbols/kline":6,"spot/v1/symbols/book":5,"spot/v1/symbols/trades":5,"contract/v1/tickers":15,"contract/public/details":5,"contract/public/depth":5,"contract/public/open-interest":30,"contract/public/funding-rate":30,"contract/public/funding-rate-history":30,"contract/public/kline":6,"account/v1/currencies":30}},private:{get:{"account/sub-account/v1/transfer-list":7.5,"account/sub-account/v1/transfer-history":7.5,"account/sub-account/main/v1/wallet":5,"account/sub-account/main/v1/subaccount-list":7.5,"account/contract/sub-account/main/v1/wallet":5,"account/contract/sub-account/main/v1/transfer-list":7.5,"account/contract/sub-account/v1/transfer-history":7.5,"account/v1/wallet":5,"account/v1/currencies":30,"spot/v1/wallet":5,"account/v1/deposit/address":30,"account/v1/withdraw/charge":32,"account/v2/deposit-withdraw/history":7.5,"account/v1/deposit-withdraw/detail":7.5,"spot/v1/order_detail":1,"spot/v2/orders":5,"spot/v1/trades":5,"spot/v2/trades":4,"spot/v3/orders":5,"spot/v2/order_detail":1,"spot/v1/margin/isolated/borrow_record":1,"spot/v1/margin/isolated/repay_record":1,"spot/v1/margin/isolated/pairs":30,"spot/v1/margin/isolated/account":5,"spot/v1/trade_fee":30,"spot/v1/user_fee":30,"spot/v1/broker/rebate":1,"contract/private/assets-detail":5,"contract/private/order":1.2,"contract/private/order-history":10,"contract/private/position":10,"contract/private/get-open-orders":1.2,"contract/private/current-plan-order":1.2,"contract/private/trades":10,"contract/private/position-risk":10,"contract/private/affilate/rebate-list":10,"contract/private/affilate/trade-list":10,"contract/private/transaction-history":10},post:{"account/sub-account/main/v1/sub-to-main":30,"account/sub-account/sub/v1/sub-to-main":30,"account/sub-account/main/v1/main-to-sub":30,"account/sub-account/sub/v1/sub-to-sub":30,"account/sub-account/main/v1/sub-to-sub":30,"account/contract/sub-account/main/v1/sub-to-main":7.5,"account/contract/sub-account/main/v1/main-to-sub":7.5,"account/contract/sub-account/sub/v1/sub-to-main":7.5,"account/v1/withdraw/apply":7.5,"spot/v1/submit_order":1,"spot/v1/batch_orders":1,"spot/v2/cancel_order":1,"spot/v1/cancel_orders":15,"spot/v4/query/order":1,"spot/v4/query/client-order":1,"spot/v4/query/open-orders":5,"spot/v4/query/history-orders":5,"spot/v4/query/trades":5,"spot/v4/query/order-trades":5,"spot/v4/cancel_orders":3,"spot/v4/cancel_all":90,"spot/v4/batch_orders":3,"spot/v3/cancel_order":1,"spot/v2/batch_orders":1,"spot/v2/submit_order":1,"spot/v1/margin/submit_order":1,"spot/v1/margin/isolated/borrow":30,"spot/v1/margin/isolated/repay":30,"spot/v1/margin/isolated/transfer":30,"account/v1/transfer-contract-list":60,"account/v1/transfer-contract":60,"contract/private/submit-order":2.5,"contract/private/cancel-order":1.5,"contract/private/cancel-orders":30,"contract/private/submit-plan-order":2.5,"contract/private/cancel-plan-order":1.5,"contract/private/submit-leverage":2.5,"contract/private/submit-tp-sl-order":2.5,"contract/private/modify-plan-order":2.5,"contract/private/modify-preset-plan-order":2.5,"contract/private/modify-tp-sl-order":2.5}}},timeframes:{"1m":1,"3m":3,"5m":5,"15m":15,"30m":30,"45m":45,"1h":60,"2h":120,"3h":180,"4h":240,"1d":1440,"1w":10080,"1M":43200},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0040"),maker:this.parseNumber("0.0035"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0020")],[this.parseNumber("10"),this.parseNumber("0.18")],[this.parseNumber("50"),this.parseNumber("0.0016")],[this.parseNumber("250"),this.parseNumber("0.0014")],[this.parseNumber("1000"),this.parseNumber("0.0012")],[this.parseNumber("5000"),this.parseNumber("0.0010")],[this.parseNumber("25000"),this.parseNumber("0.0008")],[this.parseNumber("50000"),this.parseNumber("0.0006")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("10"),this.parseNumber("0.0009")],[this.parseNumber("50"),this.parseNumber("0.0008")],[this.parseNumber("250"),this.parseNumber("0.0007")],[this.parseNumber("1000"),this.parseNumber("0.0006")],[this.parseNumber("5000"),this.parseNumber("0.0005")],[this.parseNumber("25000"),this.parseNumber("0.0004")],[this.parseNumber("50000"),this.parseNumber("0.0003")]]}}},precisionMode:o.kb,exceptions:{exact:{3e4:r.ExchangeError,30001:r.AuthenticationError,30002:r.AuthenticationError,30003:r.AccountSuspended,30004:r.AuthenticationError,30005:r.AuthenticationError,30006:r.AuthenticationError,30007:r.AuthenticationError,30008:r.AuthenticationError,30010:r.PermissionDenied,30011:r.AuthenticationError,30012:r.AuthenticationError,30013:r.RateLimitExceeded,30014:r.ExchangeNotAvailable,30016:r.OnMaintenance,30017:r.RateLimitExceeded,30018:r.BadRequest,30019:r.PermissionDenied,6e4:r.BadRequest,60001:r.BadRequest,60002:r.BadRequest,60003:r.ExchangeError,60004:r.ExchangeError,60005:r.ExchangeError,60006:r.ExchangeError,60007:r.InvalidAddress,60008:r.InsufficientFunds,60009:r.ExchangeError,60010:r.ExchangeError,60011:r.InvalidAddress,60012:r.ExchangeError,60020:r.PermissionDenied,60021:r.PermissionDenied,60022:r.PermissionDenied,60026:r.PermissionDenied,60027:r.PermissionDenied,60028:r.AccountSuspended,60029:r.AccountSuspended,60030:r.BadRequest,60031:r.BadRequest,60050:r.ExchangeError,60051:r.ExchangeError,61001:r.InsufficientFunds,61003:r.BadRequest,61004:r.BadRequest,61005:r.BadRequest,61006:r.NotSupported,61007:r.ExchangeError,61008:r.ExchangeError,7e4:r.ExchangeError,70001:r.BadRequest,70002:r.BadSymbol,70003:r.NetworkError,71001:r.BadRequest,71002:r.BadRequest,71003:r.BadRequest,71004:r.BadRequest,71005:r.BadRequest,5e4:r.BadRequest,50001:r.BadSymbol,50002:r.BadRequest,50003:r.BadRequest,50004:r.BadRequest,50005:r.OrderNotFound,50006:r.InvalidOrder,50007:r.InvalidOrder,50008:r.InvalidOrder,50009:r.InvalidOrder,50010:r.InvalidOrder,50011:r.InvalidOrder,50012:r.InvalidOrder,50013:r.InvalidOrder,50014:r.BadRequest,50015:r.BadRequest,50016:r.BadRequest,50017:r.BadRequest,50018:r.BadRequest,50019:r.ExchangeError,50020:r.InsufficientFunds,50021:r.BadRequest,50022:r.ExchangeNotAvailable,50023:r.BadSymbol,50024:r.BadRequest,50025:r.BadRequest,50026:r.BadRequest,50027:r.BadRequest,50028:r.BadRequest,50029:r.InvalidOrder,50030:r.OrderNotFound,50031:r.OrderNotFound,50032:r.OrderNotFound,50033:r.InvalidOrder,50034:r.InvalidOrder,50035:r.InvalidOrder,50036:r.ExchangeError,50037:r.BadRequest,50038:r.BadRequest,50039:r.BadRequest,50040:r.BadSymbol,50041:r.ExchangeError,50042:r.BadRequest,51e3:r.BadSymbol,51001:r.ExchangeError,51002:r.ExchangeError,51003:r.ExchangeError,51004:r.InsufficientFunds,51005:r.InvalidOrder,51006:r.InvalidOrder,51007:r.BadRequest,51008:r.ExchangeError,51009:r.InvalidOrder,51010:r.InvalidOrder,51011:r.InvalidOrder,51012:r.InvalidOrder,51013:r.InvalidOrder,51014:r.InvalidOrder,51015:r.InvalidOrder,52e3:r.BadRequest,52001:r.BadRequest,52002:r.BadRequest,52003:r.BadRequest,52004:r.BadRequest,53e3:r.AccountSuspended,53001:r.AccountSuspended,53002:r.PermissionDenied,53003:r.PermissionDenied,53005:r.PermissionDenied,53006:r.PermissionDenied,53007:r.PermissionDenied,53008:r.PermissionDenied,53009:r.PermissionDenied,53010:r.PermissionDenied,57001:r.BadRequest,58001:r.BadRequest,59001:r.ExchangeError,59002:r.ExchangeError,59003:r.ExchangeError,59004:r.ExchangeError,59005:r.PermissionDenied,59006:r.ExchangeError,59007:r.ExchangeError,59008:r.ExchangeError,59009:r.ExchangeError,59010:r.InsufficientFunds,59011:r.ExchangeError,40001:r.ExchangeError,40002:r.ExchangeError,40003:r.ExchangeError,40004:r.ExchangeError,40005:r.ExchangeError,40006:r.PermissionDenied,40007:r.BadRequest,40008:r.InvalidNonce,40009:r.BadRequest,40010:r.BadRequest,40011:r.BadRequest,40012:r.ExchangeError,40013:r.ExchangeError,40014:r.BadSymbol,40015:r.BadSymbol,40016:r.InvalidOrder,40017:r.InvalidOrder,40018:r.InvalidOrder,40019:r.ExchangeError,40020:r.InvalidOrder,40021:r.ExchangeError,40022:r.ExchangeError,40023:r.ExchangeError,40024:r.ExchangeError,40025:r.ExchangeError,40026:r.ExchangeError,40027:r.InsufficientFunds,40028:r.PermissionDenied,40029:r.InvalidOrder,40030:r.InvalidOrder,40031:r.InvalidOrder,40032:r.InvalidOrder,40033:r.InvalidOrder,40034:r.BadSymbol,40035:r.OrderNotFound,40036:r.InvalidOrder,40037:r.OrderNotFound,40038:r.BadRequest,40039:r.BadRequest,40040:r.InvalidOrder,40041:r.InvalidOrder,40042:r.InvalidOrder,40043:r.InvalidOrder,40044:r.InvalidOrder,40045:r.InvalidOrder,40046:r.PermissionDenied,40047:r.PermissionDenied,40048:r.InvalidOrder,40049:r.InvalidOrder,40050:r.InvalidOrder},broad:{}},commonCurrencies:{$GM:"GOLDMINER",$HERO:"Step Hero",$PAC:"PAC",BP:"BEYOND",GDT:"Gorilla Diamond",GLD:"Goldario",MVP:"MVP Coin",TRU:"Truebit"},options:{defaultNetwork:"ERC20",defaultNetworks:{USDT:"ERC20"},timeDifference:0,adjustForTimeDifference:!1,networks:{ERC20:"ERC20",SOL:"SOL",BTC:"BTC",TRC20:"TRC20",OMNI:"OMNI",XLM:"XLM",EOS:"EOS",NEO:"NEO",BTM:"BTM",BCH:"BCH",LTC:"LTC",BSV:"BSV",XRP:"XRP",PLEX:"PLEX",XCH:"XCH",NEAR:"NEAR",FIO:"FIO",SCRT:"SCRT",IOTX:"IOTX",ALGO:"ALGO",ATOM:"ATOM",DOT:"DOT",ADA:"ADA",DOGE:"DOGE",XYM:"XYM",GLMR:"GLMR",MOVR:"MOVR",ZIL:"ZIL",INJ:"INJ",KSM:"KSM",ZEC:"ZEC",NAS:"NAS",HRC20:"HECO",XDC:"XDC",ONE:"ONE",LAT:"LAT",CSPR:"Casper",ICP:"Computer",XTZ:"XTZ",MINA:"MINA",THETA:"THETA",AKT:"AKT",AR:"AR",CELO:"CELO",FIL:"FIL",NULS:"NULS",ETC:"ETC",DASH:"DASH",DGB:"DGB",BEP2:"BEP2",GRIN:"GRIN",WAVES:"WAVES",ABBC:"ABBC",ACA:"ACA",QTUM:"QTUM",PAC:"PAC",TLOS:"TLOS",KARDIA:"KardiaChain",FUSE:"FUSE",TRC10:"TRC10",FIRO:"FIRO",FTM:"Fantom",EVER:"EVER",KAVA:"KAVA",HYDRA:"HYDRA",PLCU:"PLCU",BRISE:"BRISE",OPTIMISM:"OPTIMISM",REEF:"REEF",SYS:"SYS",VITE:"VITE",STX:"STX",SXP:"SXP",BITCI:"BITCI",XRD:"XRD",ASTR:"ASTAR",ZEN:"HORIZEN",LTO:"LTO",ETHW:"ETHW",ETHF:"ETHF",IOST:"IOST",APT:"APT",ONT:"ONT",EVMOS:"EVMOS",XMR:"XMR",OASYS:"OAS",OSMO:"OSMO",OMAX:"OMAX Chain",DESO:"DESO",BFIC:"BFIC",OHO:"OHO",CS:"CS",CHEQ:"CHEQ",NODL:"NODL",NEM:"XEM",FRA:"FRA",ERGO:"ERG"},defaultType:"spot",fetchBalance:{type:"spot"},accountsByType:{spot:"spot",swap:"swap"},createMarketBuyOrderRequiresPrice:!0,brokerId:"CCXTxBitmart000"},features:{default:{sandbox:!1,createOrder:{marginMode:!0,triggerPrice:!1,triggerPriceType:void 0,triggerDirection:!1,stopLossPrice:!1,takeProfitPrice:!1,attachedStopLossTakeProfit:void 0,timeInForce:{IOC:!0,FOK:!1,PO:!0,GTD:!1},hedged:!1,trailing:!1,marketBuyRequiresPrice:!1,marketBuyByCost:!0,leverage:!0,selfTradePrevention:!1,iceberg:!1},createOrders:{max:10},fetchMyTrades:{marginMode:!0,limit:200,daysBack:void 0,untilDays:99999},fetchOrder:{marginMode:!1,trigger:!1,trailing:!1},fetchOpenOrders:{marginMode:!0,limit:200,trigger:!1,trailing:!1},fetchOrders:void 0,fetchClosedOrders:{marginMode:!0,limit:200,daysBack:void 0,daysBackCanceled:void 0,untilDays:void 0,trigger:!1,trailing:!1},fetchOHLCV:{limit:1e3}},forDerivatives:{extends:"default",createOrder:{marginMode:!0,triggerPrice:!0,triggerPriceType:{last:!0,mark:!0,index:!1},triggerDirection:!0,stopLossPrice:!0,takeProfitPrice:!0,attachedStopLossTakeProfit:{triggerPriceType:{last:!0,mark:!0,index:!1},price:!1},timeInForce:{IOC:!0,FOK:!0,PO:!0,GTD:!1},hedged:!1,trailing:!0,marketBuyRequiresPrice:!0,marketBuyByCost:!0},fetchMyTrades:{marginMode:!0,limit:void 0,daysBack:void 0,untilDays:99999},fetchOrder:{marginMode:!1,trigger:!1,trailing:!0},fetchOpenOrders:{marginMode:!1,limit:100,trigger:!0,trailing:!1},fetchClosedOrders:{marginMode:!0,limit:200,daysBack:void 0,daysBackCanceled:void 0,untilDays:void 0,trigger:!1,trailing:!1},fetchOHLCV:{limit:500}},spot:{extends:"default"},swap:{linear:{extends:"forDerivatives"},inverse:{extends:"forDerivatives"}},future:{linear:void 0,inverse:void 0}}})}async fetchTime(e={}){let t=await this.publicGetSystemTime(e),i=this.safeDict(t,"data",{});return this.safeInteger(i,"server_time")}async fetchStatus(e={}){let t,i;let s=this.safeDict(this.options,"fetchStatus",{}),r=this.safeString(this.options,"defaultType"),a=this.safeString(s,"type",r);a=this.safeString(e,"type",a),e=this.omit(e,"type");let o=await this.publicGetSystemService(e),n=this.safeDict(o,"data",{}),d=this.safeList(n,"service",[]),c=this.indexBy(d,"service_type");"swap"===a&&(a="contract");let h=this.safeString(c,a);return void 0!==h&&(2===this.safeInteger(h,"status")?t="ok":(t="maintenance",i=this.safeInteger(h,"end_time"))),{status:t,updated:void 0,eta:i,url:void 0,info:o}}async fetchSpotMarkets(e={}){let t=await this.publicGetSpotV1SymbolsDetails(e),i=this.safeDict(t,"data",{}),s=this.safeList(i,"symbols",[]),r=[];for(let e=0;e<s.length;e++){let t=s[e],i=this.safeString(t,"symbol"),o=this.safeInteger(t,"symbol_id"),n=this.safeString(t,"base_currency"),d=this.safeString(t,"quote_currency"),c=this.safeCurrencyCode(n),h=this.safeCurrencyCode(d),l=c+"/"+h,p=this.safeString(t,"min_buy_amount"),u=this.safeString(t,"min_sell_amount"),f=a.Y.stringMax(p,u),m=this.safeNumber(t,"base_min_size");r.push({id:i,numericId:o,symbol:l,base:c,quote:h,settle:void 0,baseId:n,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:m,price:this.parseNumber(this.parsePrecision(this.safeString(t,"price_max_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:m,max:this.safeNumber(t,"base_max_size")},price:{min:void 0,max:void 0},cost:{min:this.parseNumber(f),max:void 0}},created:void 0,info:t})}return r}async fetchContractMarkets(e={}){let t=await this.publicGetContractPublicDetails(e),i=this.safeDict(t,"data",{}),s=this.safeList(i,"symbols",[]),r=[];for(let e=0;e<s.length;e++){let t=s[e],i=this.safeString(t,"symbol"),a=this.safeString(t,"base_currency"),o=this.safeString(t,"quote_currency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),c="USDT",h=this.safeCurrencyCode(c),l=n+"/"+d+":"+h,p=this.safeInteger(t,"product_type"),u=1===p,f=2===p,m=this.safeInteger(t,"expire_timestamp");f||0!==m||(m=void 0),r.push({id:i,numericId:void 0,symbol:l,base:n,quote:d,settle:h,baseId:a,quoteId:o,settleId:c,type:u?"swap":"future",spot:!1,margin:!1,swap:u,future:f,option:!1,active:!0,contract:!0,linear:!0,inverse:!1,contractSize:this.safeNumber(t,"contract_size"),expiry:m,expiryDatetime:this.iso8601(m),strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(t,"vol_precision"),price:this.safeNumber(t,"price_precision")},limits:{leverage:{min:this.safeNumber(t,"min_leverage"),max:this.safeNumber(t,"max_leverage")},amount:{min:this.safeNumber(t,"min_volume"),max:this.safeNumber(t,"max_volume")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:this.safeInteger(t,"open_timestamp"),info:t})}return r}async fetchMarkets(e={}){this.options.adjustForTimeDifference&&await this.loadTimeDifference();let t=await this.fetchSpotMarkets(e),i=await this.fetchContractMarkets(e);return this.arrayConcat(t,i)}async fetchCurrencies(e={}){let t=await this.publicGetSpotV1Currencies(e),i=this.safeDict(t,"data",{}),s=this.safeList(i,"currencies",[]),r={};for(let e=0;e<s.length;e++){let t=s[e],i=this.safeString(t,"id"),a=this.safeCurrencyCode(i),o=this.safeString(t,"name"),n=this.safeBool(t,"withdraw_enabled"),d=this.safeBool(t,"deposit_enabled"),c=n&&d;r[a]={id:i,code:a,name:o,info:t,active:c,deposit:d,withdraw:n,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return r}async fetchTransactionFee(e,t={}){await this.loadMarkets();let i={currency:this.currency(e).id},s=await this.privateGetAccountV1WithdrawCharge(this.extend(i,t)),r=s.data,a={};return a[e]=this.safeNumber(r,"withdraw_fee"),{info:s,withdraw:a,deposit:{}}}parseDepositWithdrawFee(e,t){return{info:e,withdraw:{fee:this.safeNumber(e,"withdraw_fee"),percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}}}async fetchDepositWithdrawFee(e,t={}){await this.loadMarkets();let i={currency:this.currency(e).id},s=(await this.privateGetAccountV1WithdrawCharge(this.extend(i,t))).data;return this.parseDepositWithdrawFee(s)}parseTicker(e,t){let i=this.safeList(e,"result",[]),s=this.safeString2(e,"avg_price","index_price"),r=this.safeString2(e,"symbol","contract_symbol"),o=this.safeInteger2(e,"timestamp","ts"),n=this.safeString2(e,"last_price","last"),d=this.safeString2(e,"price_change_percent_24h","change_24h"),c=this.safeString(e,"fluctuation"),h=this.safeString2(e,"high_24h","high_price"),l=this.safeString2(e,"low_24h","low_price"),p=this.safeString2(e,"best_bid","bid_px"),u=this.safeString2(e,"best_bid_size","bid_sz"),f=this.safeString2(e,"best_ask","ask_px"),m=this.safeString2(e,"best_ask_size","ask_sz"),g=this.safeString(e,"open_24h"),v=this.safeStringN(e,["base_volume_24h","v_24h","volume_24h"]),y=this.safeStringLowerN(e,["quote_volume_24h","qv_24h","turnover_24h"]),b=this.safeString(i,0);void 0!==b&&(r=b,o=this.safeInteger(i,12),h=this.safeString(i,5),l=this.safeString(i,6),p=this.safeString(i,8),u=this.safeString(i,9),f=this.safeString(i,10),m=this.safeString(i,11),g=this.safeString(i,4),n=this.safeString(i,1),c=this.safeString(i,7),v=this.safeString(i,2),y=this.safeStringLower(i,3));let w=(t=this.safeMarket(r,t)).symbol;return void 0===o&&(o=this.safeIntegerProduct(e,"s_t",1e3)),void 0===d&&(d=a.Y.stringMul(c,"100")),void 0===y&&(void 0===v?y=this.safeString(e,"volume_24h",y):(y=v,v=void 0)),this.safeTicker({symbol:w,timestamp:o,datetime:this.iso8601(o),high:h,low:l,bid:p,bidVolume:u,ask:f,askVolume:m,vwap:void 0,open:g,close:n,last:n,previousClose:void 0,change:void 0,percentage:d,average:s,baseVolume:v,quoteVolume:y,indexPrice:this.safeString(e,"index_price"),info:e},t)}async fetchTicker(e,t={}){let i;await this.loadMarkets();let s=this.market(e),a={};if(s.swap)a.symbol=s.id,i=await this.publicGetContractPublicDetails(this.extend(a,t));else if(s.spot)a.symbol=s.id,i=await this.publicGetSpotQuotationV3Ticker(this.extend(a,t));else throw new r.NotSupported(this.id+" fetchTicker() does not support "+s.type+" markets, only spot and swap markets are accepted");let o=[],n={};if(s.spot)n=this.safeDict(i,"data",{});else{let e=this.safeDict(i,"data",{});o=this.safeList(e,"symbols",[]),n=this.safeDict(o,0,{})}return this.parseTicker(n,s)}async fetchTickers(e,t={}){let i,s,a;if(await this.loadMarkets(),void 0!==(e=this.marketSymbols(e))){let t=this.safeString(e,0);s=this.market(t)}if([i,t]=this.handleMarketTypeAndParams("fetchTickers",s,t),"spot"===i)a=await this.publicGetSpotQuotationV3Tickers(t);else if("swap"===i)a=await this.publicGetContractPublicDetails(t);else throw new r.NotSupported(this.id+" fetchTickers() does not support "+i+" markets, only spot and swap markets are accepted");let o=[];if("spot"===i)o=this.safeList(a,"data",[]);else{let e=this.safeDict(a,"data",{});o=this.safeList(e,"symbols",[])}let n={};for(let e=0;e<o.length;e++){let t={};n[(t="spot"===i?this.parseTicker({result:o[e]}):this.parseTicker(o[e])).symbol]=t}return this.filterByArrayTickers(n,"symbol",e)}async fetchOrderBook(e,t,i={}){let s;await this.loadMarkets();let a=this.market(e),o={symbol:a.id};if(a.spot)void 0!==t&&(o.limit=t),s=await this.publicGetSpotQuotationV3Books(this.extend(o,i));else if(a.swap)s=await this.publicGetContractPublicDepth(this.extend(o,i));else throw new r.NotSupported(this.id+" fetchOrderBook() does not support "+a.type+" markets, only spot and swap markets are accepted");let n=this.safeDict(s,"data",{}),d=this.safeInteger2(n,"ts","timestamp");return this.parseOrderBook(n,a.symbol,d)}parseTrade(e,t){let i,s,r,a,o;let n=this.safeIntegerN(e,["createTime","create_time",1]);void 0!==this.safeString(e,0)?(i=this.safeString2(e,"count",3),s=this.safeString(e,"amount"),a=this.safeString2(e,"type",4)):(i=this.safeStringN(e,["size","vol","fillQty"]),s=this.safeString(e,"notional"),r=this.safeString(e,"type"),a=this.parseOrderSide(this.safeString(e,"side")));let d=this.safeString2(e,"symbol",0);t=this.safeMarket(d,t);let c=this.safeString2(e,"fee","paid_fees");if(void 0!==c){let i=this.safeString(e,"feeCoinName"),s=this.safeCurrencyCode(i);void 0===s&&(s="buy"===a?t.base:t.quote),o={cost:c,currency:s}}return this.safeTrade({info:e,id:this.safeStringN(e,["tradeId","trade_id","lastTradeID"]),order:this.safeString2(e,"orderId","order_id"),timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,type:r,side:a,price:this.safeStringN(e,["price","fillPrice",2]),amount:i,cost:s,takerOrMaker:this.safeStringLower2(e,"tradeRole","exec_type"),fee:o},t)}async fetchTrades(e,t,i,s={}){await this.loadMarkets();let a=this.market(e);if(!a.spot)throw new r.NotSupported(this.id+" fetchTrades() does not support "+a.type+" orders, only spot orders are accepted");let o={symbol:a.id};void 0!==i&&(o.limit=i);let n=await this.publicGetSpotQuotationV3Trades(this.extend(o,s)),d=this.safeList(n,"data",[]);return this.parseTrades(d,a,t,i)}parseOHLCV(e,t){return Array.isArray(e)?[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:[this.safeTimestamp2(e,"timestamp","ts"),this.safeNumber2(e,"open_price","o"),this.safeNumber2(e,"high_price","h"),this.safeNumber2(e,"low_price","l"),this.safeNumber2(e,"close_price","c"),this.safeNumber2(e,"volume","v")]}async fetchOHLCV(e,t="1m",i,s,r={}){let a;await this.loadMarkets();let o=!1;if([o,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate",!1),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,i,s,t,r,200);let n=this.market(e),d=this.parseTimeframe(t),c=this.safeInteger(this.timeframes,t),h={symbol:n.id};if(void 0!==c?h.step=c:h.step=t,n.spot)[h,r]=this.handleUntilOption("before",h,r,.001),void 0!==s&&(h.limit=s),void 0!==i&&(h.after=this.parseToInt(i/1e3)-1);else{void 0===s&&(s=500),s=Math.min(500,s);let e=this.parseToInt(this.milliseconds()/1e3);if(void 0===i){let t=e-s*d;h.start_time=t,h.end_time=e}else{let t=this.parseToInt(i/1e3)-1,r=this.sum(t,s*d);h.start_time=t,h.end_time=Math.min(r,e)}[h,r]=this.handleUntilOption("end_time",h,r,.001)}a=n.swap?await this.publicGetContractPublicKline(this.extend(h,r)):await this.publicGetSpotQuotationV3Klines(this.extend(h,r));let l=this.safeList(a,"data",[]);return this.parseOHLCVs(l,n,t,i,s)}async fetchMyTrades(e,t,i,s={}){let a,o,n;await this.loadMarkets();let d={};void 0!==e&&(a=this.market(e),d.symbol=a.id),[o,s]=this.handleMarketTypeAndParams("fetchMyTrades",a,s);let c=this.safeIntegerN(s,["until","endTime","end_time"]);if(s=this.omit(s,["until"]),"spot"===o){let e;[e,s]=this.handleMarginModeAndParams("fetchMyTrades",s),"isolated"===e&&(d.orderMode="iso_margin");let r=this.safeDict(this.options,"fetchMyTrades",{}),a=this.safeInteger(r,"limit",200);void 0===i&&(i=a),d.limit=Math.min(i,200),void 0!==t&&(d.startTime=t),void 0!==c&&(d.endTime=c),n=await this.privatePostSpotV4QueryTrades(this.extend(d,s))}else if("swap"===o){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");void 0!==t&&(d.start_time=t),void 0!==c&&(d.end_time=c),n=await this.privateGetContractPrivateTrades(this.extend(d,s))}else throw new r.NotSupported(this.id+" fetchMyTrades() does not support "+o+" orders, only spot and swap orders are accepted");let h=this.safeList(n,"data",[]);return this.parseTrades(h,a,t,i)}async fetchOrderTrades(e,t,i,s,r={}){await this.loadMarkets();let a=await this.privatePostSpotV4QueryOrderTrades(this.extend({orderId:e},r)),o=this.safeList(a,"data",[]);return this.parseTrades(o,void 0,i,s)}customParseBalance(e,t){let i;let s=this.safeDict(e,"data",{});i="swap"===t?this.safeList(e,"data",[]):"margin"===t?this.safeList(s,"symbols",[]):this.safeList(s,"wallet",[]);let r={info:e};if("margin"===t){for(let e=0;e<i.length;e++){let t=i[e],s=this.safeString(t,"symbol"),a=this.safeSymbol(s,void 0,"_"),o=this.safeDict(t,"base",{}),n=this.safeDict(t,"quote",{}),d=this.safeCurrencyCode(this.safeString(o,"currency")),c=this.safeCurrencyCode(this.safeString(n,"currency")),h={};h[d]=this.parseBalanceHelper(o),h[c]=this.parseBalanceHelper(n),r[a]=this.safeBalance(h)}return r}for(let e=0;e<i.length;e++){let t=i[e],s=this.safeString2(t,"id","currency");s=this.safeString(t,"coin_code",s);let a=this.safeCurrencyCode(s),o=this.account();o.free=this.safeString2(t,"available","available_balance"),o.used=this.safeString2(t,"frozen","frozen_balance"),r[a]=o}return this.safeBalance(r)}parseBalanceHelper(e){let t=this.account();t.used=this.safeString(e,"frozen"),t.free=this.safeString(e,"available"),t.total=this.safeString(e,"total_asset");let i=this.safeString(e,"borrow_unpaid"),s=this.safeString(e,"interest_unpaid");return t.debt=a.Y.stringAdd(i,s),t}async fetchBalance(e={}){let t,i;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let s=this.safeString(e,"marginMode"),a=this.safeBool(e,"margin",!1);if(e=this.omit(e,["margin","marginMode"]),(void 0!==s||a)&&(t="margin"),"spot"===t)i=await this.privateGetSpotV1Wallet(e);else if("swap"===t)i=await this.privateGetContractPrivateAssetsDetail(e);else if("account"===t)i=await this.privateGetAccountV1Wallet(e);else if("margin"===t)i=await this.privateGetSpotV1MarginIsolatedAccount(e);else throw new r.NotSupported(this.id+" fetchBalance() does not support "+t+" markets, only spot, swap and account and margin markets are accepted");return this.customParseBalance(i,t)}parseTradingFee(e,t){let i=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(i),maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate"),percentage:void 0,tierBased:void 0}}async fetchTradingFee(e,t={}){await this.loadMarkets();let i=this.market(e);if(!i.spot)throw new r.NotSupported(this.id+" fetchTradingFee() does not support "+i.type+" orders, only spot orders are accepted");let s={symbol:i.id},a=await this.privateGetSpotV1TradeFee(this.extend(s,t)),o=this.safeDict(a,"data",{});return this.parseTradingFee(o)}parseOrder(e,t){let i,s,r;"string"==typeof e&&(i=e,e={}),i=this.safeString2(e,"order_id","orderId",i);let a=this.safeInteger2(e,"create_time","createTime"),o=this.safeString(e,"symbol"),n=this.safeSymbol(o,t);t=this.safeMarket(n,t);let d=this.safeString(t,"type","spot"),c=this.safeString(e,"type");"limit_maker"===c&&(c="limit",r=!0,s="PO"),"ioc"===c&&(c="limit",s="IOC");let h=this.safeString(e,"price");"market price"===h&&(h=void 0);let l=this.safeNumber(e,"activation_price");return this.safeOrder({id:i,clientOrderId:this.safeString2(e,"client_order_id","clientOrderId"),info:e,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:this.safeInteger(e,"update_time"),symbol:n,type:c,timeInForce:s,postOnly:r,side:this.parseOrderSide(this.safeString(e,"side")),price:this.omitZero(h),triggerPrice:l,amount:this.omitZero(this.safeString(e,"size")),cost:this.safeString2(e,"filled_notional","filledNotional"),average:this.safeStringN(e,["price_avg","priceAvg","deal_avg_price"]),filled:this.safeStringN(e,["filled_size","filledSize","deal_size"]),remaining:void 0,status:this.parseOrderStatusByType(d,this.safeString2(e,"status","state")),fee:void 0,trades:void 0},t)}parseOrderSide(e){return this.safeString({1:"buy",2:"buy",3:"sell",4:"sell"},e,e)}parseOrderStatusByType(e,t){let i=this.safeDict({spot:{1:"rejected",2:"open",3:"rejected",4:"open",5:"open",6:"closed",7:"canceled",8:"canceled",new:"open",partially_filled:"open",filled:"closed",partially_canceled:"canceled"},swap:{1:"open",2:"open",4:"closed"}},e,{});return this.safeString(i,t,t)}async createMarketBuyOrderWithCost(e,t,i={}){if(await this.loadMarkets(),!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return i.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,i)}async createOrder(e,t,i,s,r,a={}){let o;await this.loadMarkets();let n=this.market(e),d=this.handleMarginModeAndParams("createOrder",a),c=this.safeString(d,0),h=this.safeStringN(a,["triggerPrice","stopPrice","trigger_price"]),l=this.safeString(a,"stopLossPrice"),p=this.safeString(a,"takeProfitPrice");if(n.spot){let n=this.createSpotOrderRequest(e,t,i,s,r,a);o="isolated"===c?await this.privatePostSpotV1MarginSubmitOrder(n):await this.privatePostSpotV2SubmitOrder(n)}else{let n=this.createSwapOrderRequest(e,t,i,s,r,a);o=void 0!==h?await this.privatePostContractPrivateSubmitPlanOrder(n):void 0!==l||void 0!==p?await this.privatePostContractPrivateSubmitTpSlOrder(n):await this.privatePostContractPrivateSubmitOrder(n)}let u=this.safeDict(o,"data",{}),f=this.parseOrder(u,n);return f.type=t,f.side=i,f.amount=s,f.price=r,f}async createOrders(e,t={}){let i,s;await this.loadMarkets();let a=[];for(let t=0;t<e.length;t++){let o=e[t],n=this.safeString(o,"symbol");if(!(s=this.market(n)).spot)throw new r.NotSupported(this.id+" createOrders() supports spot orders only");if(void 0===i)i=n;else if(i!==n)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");let d=this.safeString(o,"type"),c=this.safeString(o,"side"),h=this.safeValue(o,"amount"),l=this.safeValue(o,"price"),p=this.safeDict(o,"params",{}),u=this.createSpotOrderRequest(n,d,c,h,l,p);u=this.omit(u,["symbol"]),a.push(u)}let o={symbol:s.id,orderParams:a},n=await this.privatePostSpotV4BatchOrders(o),d=this.safeDict(n,"data",{}),c=this.safeDict(d,"data",{}),h=this.safeList(c,"orderIds",[]),l=[];for(let e=0;e<h.length;e++){let t=h[e],i=this.safeOrder({id:t},s);l.push(i)}return l}createSwapOrderRequest(e,t,i,s,r,a={}){let o,n;let d=this.market(e),c=this.safeString(a,"stopLossPrice"),h=this.safeString(a,"takeProfitPrice"),l=void 0!==c,p=void 0!==h;l?t="stop_loss":p&&(t="take_profit");let u={symbol:d.id,type:t,size:parseInt(this.amountToPrecision(e,s))},f=this.safeString(a,"timeInForce"),m=this.safeInteger(a,"mode"),g="market"===t,v=this.safeBool(a,"reduceOnly");[o,a]=this.handlePostOnly(g,4===m,a);let y="limit"===t||o||"IOC"===f||3===m;"GTC"===f?u.mode=1:"FOK"===f?u.mode=2:"IOC"===f&&(u.mode=3),o&&(u.mode=4);let b=this.safeStringN(a,["triggerPrice","stopPrice","trigger_price"]),w=void 0!==b,S=this.safeString2(a,"trailingTriggerPrice","activation_price",this.numberToString(r)),O=this.safeString2(a,"trailingPercent","callback_rate"),_=void 0!==O;y?u.price=this.priceToPrecision(e,r):("trailing"===t||_)&&(u.callback_rate=O,u.activation_price=this.priceToPrecision(e,S),u.activation_price_type=this.safeInteger(a,"activation_price_type",1)),w&&((y||void 0!==r)&&(u.executive_price=this.priceToPrecision(e,r)),u.trigger_price=this.priceToPrecision(e,b),u.price_type=this.safeInteger(a,"price_type",1),"buy"===i?v?u.price_way=2:u.price_way=1:"sell"===i&&(v?u.price_way=1:u.price_way=2)),[n,a]=this.handleMarginModeAndParams("createOrder",a,"cross"),l||p?(v=!0,u.price_type=this.safeInteger(a,"price_type",1),u.executive_price=this.priceToPrecision(e,r),l?u.trigger_price=this.priceToPrecision(e,c):u.trigger_price=this.priceToPrecision(e,h)):u.open_type=n,"buy"===i?v?u.side=2:u.side=1:"sell"===i&&(v?u.side=3:u.side=4);let T=this.safeString(a,"clientOrderId");void 0!==T&&(a=this.omit(a,"clientOrderId"),u.client_order_id=T);let k=this.safeInteger(a,"leverage");return a=this.omit(a,["timeInForce","postOnly","reduceOnly","leverage","trailingTriggerPrice","trailingPercent","triggerPrice","stopPrice","stopLossPrice","takeProfitPrice"]),void 0!==k?u.leverage=this.numberToString(k):w&&(u.leverage="1"),this.extend(u,a)}createSpotOrderRequest(e,t,i,s,n,d={}){let c;let h=this.market(e),l={symbol:h.id,side:i,type:t},p=this.safeString(d,"timeInForce");if("FOK"===p)throw new r.InvalidOrder(this.id+" createOrder() only accepts timeInForce parameter values of IOC or PO");let u=this.safeInteger(d,"mode"),f="market"===t;[c,d]=this.handlePostOnly(f,"limit_maker"===t||4===u,d),d=this.omit(d,["timeInForce","postOnly"]);let m="IOC"===p||"ioc"===t;if("limit"===t||c||m)l.size=this.amountToPrecision(e,s),l.price=this.priceToPrecision(e,n);else if(f){if("buy"===i){let e=this.safeString2(d,"cost","notional");d=this.omit(d,"cost");let t=!0;if([t,d]=this.handleOptionAndParams(d,"createOrder","createMarketBuyOrderRequiresPrice",!0),t){if(void 0===n&&void 0===e)throw new r.InvalidOrder(this.id+' createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument or in the "notional" extra parameter (the exchange-specific behaviour)');{let t=this.numberToString(s),i=this.numberToString(n);e=a.Y.stringMul(t,i)}}else e=void 0===e?this.numberToString(s):e;l.notional=this.decimalToPrecision(e,o.R3,h.precision.price,this.precisionMode)}else"sell"===i&&(l.size=this.amountToPrecision(e,s))}c&&(l.type="limit_maker"),m&&(l.type="ioc");let g=this.safeString(d,"clientOrderId");return void 0!==g&&(d=this.omit(d,"clientOrderId"),l.client_order_id=g),this.extend(l,d)}async cancelOrder(e,t,i={}){let s;if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();let a=this.market(t),o={symbol:a.id},n=this.safeString2(i,"clientOrderId","client_order_id");if(void 0!==n?o.client_order_id=n:o.order_id=e.toString(),i=this.omit(i,["clientOrderId"]),a.spot)s=await this.privatePostSpotV3CancelOrder(this.extend(o,i));else{let e=this.safeBool2(i,"stop","trigger");i=this.omit(i,["stop","trigger"]),s=e?await this.privatePostContractPrivateCancelPlanOrder(this.extend(o,i)):await this.privatePostContractPrivateCancelOrder(this.extend(o,i))}if(a.swap)return s;let d=this.safeValue(s,"data");if(!0===d)return this.safeOrder({id:e},a);let c=this.safeValue(d,"succeed");if(void 0!==c){if(void 0===(e=this.safeString(c,0)))throw new r.InvalidOrder(this.id+" cancelOrder() failed to cancel "+t+" order id "+e)}else if(!this.safeValue(d,"result"))throw new r.InvalidOrder(this.id+" cancelOrder() "+t+" order id "+e+" is filled or canceled");return this.safeOrder({id:e,symbol:a.symbol,info:{}},a)}async cancelOrders(e,t,i={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();let s=this.market(t);if(!s.spot)throw new r.NotSupported(this.id+" cancelOrders() does not support "+s.type+" orders, only spot orders are accepted");let a=this.safeList(i,"clientOrderIds");i=this.omit(i,["clientOrderIds"]);let o={symbol:s.id};void 0!==a?o.clientOrderIds=a:o.orderIds=e;let n=await this.privatePostSpotV4CancelOrders(this.extend(o,i)),d=this.safeDict(n,"data",{}),c=[],h=this.safeList(d,"successIds",[]);for(let e=0;e<h.length;e++){let t=h[e];c.push(this.safeOrder({id:t,status:"canceled"},s))}let l=this.safeList(d,"failIds",[]);for(let e=0;e<l.length;e++){let t=l[e];c.push(this.safeOrder({id:t,status:"failed"},s))}return c}async cancelAllOrders(e,t={}){let i,s,a;await this.loadMarkets();let o={};if(void 0!==e&&(i=this.market(e),o.symbol=i.id),[a,t]=this.handleMarketTypeAndParams("cancelAllOrders",i,t),"spot"===a)s=await this.privatePostSpotV4CancelAll(this.extend(o,t));else if("swap"===a){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");s=await this.privatePostContractPrivateCancelOrders(this.extend(o,t))}return s}async fetchOrdersByStatus(e,t,i,s,a={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrdersByStatus() requires a symbol argument");await this.loadMarkets();let o=this.market(t);if(!o.spot)throw new r.NotSupported(this.id+" fetchOrdersByStatus() does not support "+o.type+" orders, only spot orders are accepted");let n={symbol:o.id,offset:1,N:100};"open"===e?n.status=9:"closed"===e?n.status=6:"canceled"===e?n.status=8:n.status=e;let d=await this.privateGetSpotV3Orders(this.extend(n,a)),c=this.safeDict(d,"data",{}),h=this.safeList(c,"orders",[]);return this.parseOrders(h,o,i,s)}async fetchOpenOrders(e,t,i,s={}){let a,o,n;await this.loadMarkets();let d={};if(void 0!==e&&(a=this.market(e),d.symbol=a.id),[o,s]=this.handleMarketTypeAndParams("fetchOpenOrders",a,s),"spot"===o){let e;void 0!==i&&(d.limit=Math.min(i,200)),[e,s]=this.handleMarginModeAndParams("fetchOpenOrders",s),"isolated"===e&&(d.orderMode="iso_margin"),void 0!==t&&(d.startTime=t);let r=this.safeInteger2(s,"until","endTime");void 0!==r&&(s=this.omit(s,["endTime"]),d.endTime=r),n=await this.privatePostSpotV4QueryOpenOrders(this.extend(d,s))}else if("swap"===o){void 0!==i&&(d.limit=Math.min(i,100));let e=this.safeBool2(s,"stop","trigger");if(s=this.omit(s,["stop","trigger"]),e)n=await this.privateGetContractPrivateCurrentPlanOrder(this.extend(d,s));else{let e=this.safeBool(s,"trailing",!1),t=this.safeString(s,"orderType");s=this.omit(s,["orderType","trailing"]),e&&(t="trailing"),void 0!==t&&(d.type=t),n=await this.privateGetContractPrivateGetOpenOrders(this.extend(d,s))}}else throw new r.NotSupported(this.id+" fetchOpenOrders() does not support "+o+" orders, only spot and swap orders are accepted");let c=this.safeList(n,"data",[]);return this.parseOrders(c,a,t,i)}async fetchClosedOrders(e,t,i,s={}){let a,o,n;await this.loadMarkets();let d={};if(void 0!==e&&(a=this.market(e),d.symbol=a.id),[o,s]=this.handleMarketTypeAndParams("fetchClosedOrders",a,s),"spot"!==o&&void 0===e)throw new r.ArgumentsRequired(this.id+" fetchClosedOrders() requires a symbol argument");void 0!==t&&(d["spot"===o?"startTime":"start_time"]=t);let c="spot"===o?"endTime":"end_time",h=this.safeInteger2(s,"until",c);if(void 0!==h&&(s=this.omit(s,["until"]),d[c]=h),"spot"===o){let e;[e,s]=this.handleMarginModeAndParams("fetchClosedOrders",s),"isolated"===e&&(d.orderMode="iso_margin"),n=await this.privatePostSpotV4QueryHistoryOrders(this.extend(d,s))}else n=await this.privateGetContractPrivateOrderHistory(this.extend(d,s));let l=this.safeList(n,"data",[]);return this.parseOrders(l,a,t,i)}async fetchCanceledOrders(e,t,i,s={}){return await this.fetchOrdersByStatus("canceled",e,t,i,s)}async fetchOrder(e,t,i={}){let s,a,o;await this.loadMarkets();let n={};if(void 0!==t&&(a=this.market(t)),[s,i]=this.handleMarketTypeAndParams("fetchOrder",a,i),"spot"===s){let t=this.safeString(i,"clientOrderId");t||(n.orderId=e),o=void 0!==t?await this.privatePostSpotV4QueryClientOrder(this.extend(n,i)):await this.privatePostSpotV4QueryOrder(this.extend(n,i))}else if("swap"===s){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");let s=this.safeBool(i,"trailing",!1),d=this.safeString(i,"orderType");i=this.omit(i,["orderType","trailing"]),s&&(d="trailing"),void 0!==d&&(n.type=d),n.symbol=a.id,n.order_id=e,o=await this.privateGetContractPrivateOrder(this.extend(n,i))}let d=this.safeDict(o,"data",{});return this.parseOrder(d,a)}async fetchDepositAddress(e,t={}){await this.loadMarkets();let i=this.currency(e),s={currency:i.id};if("USDT"===e){let i=this.safeValue(this.options,"defaultNetworks"),r=this.safeStringUpper(i,e),a=this.safeDict(this.options,"networks",{}),o=this.safeStringUpper(t,"network",r);void 0!==(o=this.safeString(a,o,o))&&(s.currency=s.currency+"-"+o,t=this.omit(t,"network"))}let r=await this.privateGetAccountV1DepositAddress(this.extend(s,t)),a=this.safeDict(r,"data",{});return this.parseDepositAddress(a,i)}parseDepositAddress(e,t){let i;let s=this.safeString(e,"currency"),r=this.safeString(e,"address"),a=this.safeString(e,"chain");if(t=this.safeCurrency(s,t),void 0!==a){let e=a.split("-"),s=e.length,r=this.safeString(e,s-1);i=r===this.safeString(t,"name")?this.safeString(t,"code"):this.networkIdToCode(r)}return this.checkAddress(r),{info:e,currency:this.safeString(t,"code"),network:i,address:r,tag:this.safeString(e,"address_memo")}}async withdraw(e,t,i,s,r={}){[s,r]=this.handleWithdrawTagAndParams(s,r),this.checkAddress(i),await this.loadMarkets();let a=this.currency(e),o={currency:a.id,amount:t,destination:"To Digital Address",address:i};if(void 0!==s&&(o.address_memo=s),"USDT"===e){let t=this.safeValue(this.options,"defaultNetworks"),i=this.safeStringUpper(t,e),s=this.safeDict(this.options,"networks",{}),a=this.safeStringUpper(r,"network",i);void 0!==(a=this.safeString(s,a,a))&&(o.currency=o.currency+"-"+a,r=this.omit(r,"network"))}let n=await this.privatePostAccountV1WithdrawApply(this.extend(o,r)),d=this.safeDict(n,"data",{}),c=this.parseTransaction(d,a);return this.extend(c,{code:e,address:i,tag:s})}async fetchTransactionsByType(e,t,i,s,r={}){let a;await this.loadMarkets(),void 0===s&&(s=50);let o={operation_type:e,offset:1,N:s};if(void 0!==t&&(a=this.currency(t),o.currency=a.id),"USDT"===t){let e=this.safeValue(this.options,"defaultNetworks"),i=this.safeStringUpper(e,t),s=this.safeDict(this.options,"networks",{}),n=this.safeStringUpper(r,"network",i);void 0!==(n=this.safeString(s,n,n))&&(o.currency+="-"+n,a.code=o.currency,r=this.omit(r,"network"))}let n=await this.privateGetAccountV2DepositWithdrawHistory(this.extend(o,r)),d=this.safeDict(n,"data",{}),c=this.safeList(d,"records",[]);return this.parseTransactions(c,a,i,s)}async fetchDeposit(e,t,i={}){await this.loadMarkets();let s=await this.privateGetAccountV1DepositWithdrawDetail(this.extend({id:e},i)),r=this.safeDict(s,"data",{}),a=this.safeDict(r,"record",{});return this.parseTransaction(a)}async fetchDeposits(e,t,i,s={}){return await this.fetchTransactionsByType("deposit",e,t,i,s)}async fetchWithdrawal(e,t,i={}){await this.loadMarkets();let s=await this.privateGetAccountV1DepositWithdrawDetail(this.extend({id:e},i)),r=this.safeDict(s,"data",{}),a=this.safeDict(r,"record",{});return this.parseTransaction(a)}async fetchWithdrawals(e,t,i,s={}){return await this.fetchTransactionsByType("withdraw",e,t,i,s)}parseTransactionStatus(e){return this.safeString({0:"pending",1:"pending",2:"pending",3:"ok",4:"canceled",5:"failed"},e,e)}parseTransaction(e,t){let i,s,r;let a=this.safeString(e,"withdraw_id"),o=this.safeString(e,"deposit_id");void 0!==a&&""!==a?(s="withdraw",i=a):void 0!==o&&""!==o&&(s="deposit",i=o);let n=this.safeNumber(e,"arrival_amount"),d=this.safeInteger(e,"apply_time"),c=this.safeString(e,"currency"),h=this.safeCurrencyCode(c,t),l=this.parseTransactionStatus(this.safeString(e,"status")),p=this.safeNumber(e,"fee");void 0!==p&&(r={cost:p,currency:h});let u=this.safeString(e,"tx_id"),f=this.safeString(e,"address"),m=this.safeString(e,"address_memo");return{info:e,id:i,currency:h,amount:n,network:void 0,address:f,addressFrom:void 0,addressTo:void 0,tag:m,tagFrom:void 0,tagTo:void 0,status:l,type:s,updated:void 0,txid:u,internal:void 0,comment:void 0,timestamp:0!==d?d:void 0,datetime:0!==d?this.iso8601(d):void 0,fee:r}}async repayIsolatedMargin(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a=this.currency(t),o={symbol:r.id,currency:a.id,amount:this.currencyToPrecision(t,i)},n=await this.privatePostSpotV1MarginIsolatedRepay(this.extend(o,s)),d=this.safeDict(n,"data",{}),c=this.parseMarginLoan(d,a);return this.extend(c,{amount:i,symbol:e})}async borrowIsolatedMargin(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a=this.currency(t),o={symbol:r.id,currency:a.id,amount:this.currencyToPrecision(t,i)},n=await this.privatePostSpotV1MarginIsolatedBorrow(this.extend(o,s)),d=this.safeDict(n,"data",{}),c=this.parseMarginLoan(d,a);return this.extend(c,{amount:i,symbol:e})}parseMarginLoan(e,t){return{id:this.safeString2(e,"borrow_id","repay_id"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchIsolatedBorrowRate(e,t={}){await this.loadMarkets();let i=this.market(e),s={symbol:i.id},r=await this.privateGetSpotV1MarginIsolatedPairs(this.extend(s,t)),a=this.safeDict(r,"data",{}),o=this.safeList(a,"symbols",[]),n=this.safeDict(o,0,[]);return this.parseIsolatedBorrowRate(n,i)}parseIsolatedBorrowRate(e,t){let i=this.safeString(e,"symbol"),s=this.safeSymbol(i,t),r=this.safeDict(e,"base",{}),a=this.safeDict(e,"quote",{}),o=this.safeString(r,"currency"),n=this.safeString(a,"currency");return{symbol:s,base:this.safeCurrencyCode(o),baseRate:this.safeNumber(r,"hourly_interest"),quote:this.safeCurrencyCode(n),quoteRate:this.safeNumber(a,"hourly_interest"),period:36e5,timestamp:void 0,datetime:void 0,info:e}}async fetchIsolatedBorrowRates(e={}){await this.loadMarkets();let t=await this.privateGetSpotV1MarginIsolatedPairs(e),i=this.safeDict(t,"data",{}),s=this.safeList(i,"symbols",[]);return this.parseIsolatedBorrowRates(s)}async transfer(e,t,i,s,a={}){let o;await this.loadMarkets();let n=this.currency(e),d={amount:this.currencyToPrecision(e,t),currency:n.id},c=this.convertTypeToAccount(i),h=this.convertTypeToAccount(s);if("spot"===i)"margin"===s?(d.side="in",d.symbol=h):"swap"===s&&(d.type="spot_to_contract");else if("spot"===s)"margin"===i?(d.side="out",d.symbol=c):"swap"===i&&(d.type="contract_to_spot");else throw new r.ArgumentsRequired(this.id+" transfer() requires either fromAccount or toAccount to be spot");"margin"===i||"margin"===s?o=await this.privatePostSpotV1MarginIsolatedTransfer(this.extend(d,a)):("swap"===i||"swap"===s)&&(o=await this.privatePostAccountV1TransferContract(this.extend(d,a)));let l=this.safeDict(o,"data",{});return this.extend(this.parseTransfer(l,n),{status:this.parseTransferStatus(this.safeString2(o,"code","message"))})}parseTransferStatus(e){return this.safeString({1e3:"ok",OK:"ok",FINISHED:"ok"},e,e)}parseTransferToAccount(e){return this.safeString({contract_to_spot:"spot",spot_to_contract:"swap"},e,e)}parseTransferFromAccount(e){return this.safeString({contract_to_spot:"swap",spot_to_contract:"spot"},e,e)}parseTransfer(e,t){let i=this.safeString(e,"currency"),s=this.safeInteger(e,"timestamp");return{id:this.safeString(e,"transfer_id"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"amount"),fromAccount:this.parseTransferFromAccount(this.safeString(e,"type")),toAccount:this.parseTransferToAccount(this.safeString(e,"type")),status:this.parseTransferStatus(this.safeString(e,"state"))}}async fetchTransfers(e,t,i,s={}){let r;await this.loadMarkets(),void 0===i&&(i=10);let a={page:this.safeInteger(s,"page",1),limit:i};void 0!==e&&(r=this.currency(e),a.currency=r.id),void 0!==t&&(a.time_start=t),void 0!==i&&(a.limit=i);let o=this.safeInteger(s,"until"),n=this.safeInteger(s,"time_end",o);s=this.omit(s,["until"]),void 0!==n&&(a.time_end=n);let d=await this.privatePostAccountV1TransferContractList(this.extend(a,s)),c=this.safeDict(d,"data",{}),h=this.safeList(c,"records",[]);return this.parseTransfers(h,r,t,i)}async fetchBorrowInterest(e,t,i,s,a={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchBorrowInterest() requires a symbol argument");await this.loadMarkets();let o=this.market(t),n={symbol:o.id};void 0!==s&&(n.N=s),void 0!==i&&(n.start_time=i);let d=await this.privateGetSpotV1MarginIsolatedBorrowRecord(this.extend(n,a)),c=this.safeDict(d,"data",{}),h=this.safeList(c,"records",[]),l=this.parseBorrowInterests(h,o);return this.filterByCurrencySinceLimit(l,e,i,s)}parseBorrowInterest(e,t){let i=this.safeString(e,"symbol");t=this.safeMarket(i,t);let s=this.safeInteger(e,"create_time");return{info:e,symbol:this.safeString(t,"symbol"),currency:this.safeCurrencyCode(this.safeString(e,"currency")),interest:this.safeNumber(e,"interest_amount"),interestRate:this.safeNumber(e,"hourly_interest"),amountBorrowed:this.safeNumber(e,"borrow_amount"),marginMode:"isolated",timestamp:s,datetime:this.iso8601(s)}}async fetchOpenInterest(e,t={}){await this.loadMarkets();let i=this.market(e);if(!i.contract)throw new r.BadRequest(this.id+" fetchOpenInterest() supports contract markets only");let s={symbol:i.id},a=await this.publicGetContractPublicOpenInterest(this.extend(s,t)),o=this.safeDict(a,"data",{});return this.parseOpenInterest(o,i)}parseOpenInterest(e,t){let i=this.safeInteger(e,"timestamp"),s=this.safeString(e,"symbol");return this.safeOpenInterest({symbol:this.safeSymbol(s,t),openInterestAmount:this.safeNumber(e,"open_interest"),openInterestValue:this.safeNumber(e,"open_interest_value"),timestamp:i,datetime:this.iso8601(i),info:e},t)}async setLeverage(e,t,i={}){let s;if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");[s,i]=this.handleMarginModeAndParams("setLeverage",i),this.checkRequiredArgument("setLeverage",s,"marginMode",["isolated","cross"]),await this.loadMarkets();let a=this.market(t);if(!a.swap)throw new r.BadSymbol(this.id+" setLeverage() supports swap contracts only");let o={symbol:a.id,leverage:e.toString(),open_type:s};return await this.privatePostContractPrivateSubmitLeverage(this.extend(o,i))}async fetchFundingRate(e,t={}){await this.loadMarkets();let i=this.market(e);if(!i.swap)throw new r.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");let s={symbol:i.id},a=await this.publicGetContractPublicFundingRate(this.extend(s,t)),o=this.safeDict(a,"data",{});return this.parseFundingRate(o,i)}async fetchFundingRateHistory(e,t,i,s={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let a=this.market(e),o={symbol:a.id};void 0!==i&&(o.limit=i);let n=await this.publicGetContractPublicFundingRateHistory(this.extend(o,s)),d=this.safeDict(n,"data",{}),c=this.safeList(d,"list",[]),h=[];for(let e=0;e<c.length;e++){let t=c[e],i=this.safeString(t,"symbol"),s=this.safeSymbol(i,a,"-","swap"),r=this.safeInteger(t,"funding_time");h.push({info:t,symbol:s,fundingRate:this.safeNumber(t,"funding_rate"),timestamp:r,datetime:this.iso8601(r)})}let l=this.sortBy(h,"timestamp");return this.filterBySymbolSinceLimit(l,a.symbol,t,i)}parseFundingRate(e,t){let i=this.safeString(e,"symbol"),s=this.safeInteger(e,"timestamp");return{info:e,symbol:this.safeSymbol(i,t),markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:s,datetime:this.iso8601(s),fundingRate:this.safeNumber(e,"expected_rate"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(e,"rate_value"),previousFundingTimestamp:void 0,previousFundingDatetime:void 0,interval:void 0}}async fetchPosition(e,t={}){await this.loadMarkets();let i=this.market(e),s={symbol:i.id},r=await this.privateGetContractPrivatePosition(this.extend(s,t)),a=this.safeList(r,"data",[]),o=this.safeDict(a,0,{});return this.parsePosition(o,i)}async fetchPositions(e,t={}){let i,s;if(await this.loadMarkets(),void 0!==e){s=e.length;let t=this.safeString(e,0);i=this.market(t)}let r={};1===s&&(r.symbol=i.id);let a=await this.privateGetContractPrivatePosition(this.extend(r,t)),o=this.safeList(a,"data",[]),n=[];for(let e=0;e<o.length;e++)n.push(this.parsePosition(o[e]));return e=this.marketSymbols(e),this.filterByArrayPositions(n,"symbol",e,!1)}parsePosition(e,t){let i=this.safeString(e,"symbol"),s=(t=this.safeMarket(i,t)).symbol,r=this.safeInteger(e,"timestamp"),o=this.safeInteger(e,"position_type"),n=this.safeString(e,"maintenance_margin"),d=this.safeString(e,"current_value"),c=this.safeString(e,"position_cross"),h=a.Y.stringDiv(n,d),l=a.Y.stringDiv(n,c);return this.safePosition({info:e,id:void 0,symbol:s,timestamp:r,datetime:this.iso8601(r),lastUpdateTimestamp:void 0,hedged:void 0,side:1===o?"long":"short",contracts:this.safeNumber(e,"current_amount"),contractSize:this.safeNumber(t,"contractSize"),entryPrice:this.safeNumber(e,"entry_price"),markPrice:this.safeNumber(e,"mark_price"),lastPrice:void 0,notional:this.parseNumber(d),leverage:this.safeNumber(e,"leverage"),collateral:this.parseNumber(c),initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:this.parseNumber(n),maintenanceMarginPercentage:this.parseNumber(h),unrealizedPnl:this.safeNumber(e,"unrealized_value"),realizedPnl:this.safeNumber(e,"realized_value"),liquidationPrice:void 0,marginMode:void 0,percentage:void 0,marginRatio:this.parseNumber(l),stopLossPrice:void 0,takeProfitPrice:void 0})}async fetchMyLiquidations(e,t,i,s={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyLiquidations() requires a symbol argument");await this.loadMarkets();let a=this.market(e);if(!a.swap)throw new r.NotSupported(this.id+" fetchMyLiquidations() supports swap markets only");let o={symbol:a.id};void 0!==t&&(o.start_time=t),[o,s]=this.handleUntilOption("end_time",o,s);let n=await this.privateGetContractPrivateOrderHistory(this.extend(o,s)),d=this.safeList(n,"data",[]),c=[];for(let e=0;e<d.length;e++){let t=d[e];"liquidate"===this.safeString(t,"type")&&c.push(t)}return this.parseLiquidations(c,a,t,i)}parseLiquidation(e,t){let i=this.safeString(e,"symbol"),s=this.safeInteger(e,"update_time"),r=this.safeString(e,"deal_size"),o=this.safeString(t,"contractSize"),n=this.safeString(e,"deal_avg_price"),d=a.Y.stringMul(r,o),c=a.Y.stringMul(d,n);return this.safeLiquidation({info:e,symbol:this.safeSymbol(i,t),contracts:this.parseNumber(r),contractSize:this.parseNumber(o),price:this.parseNumber(n),baseValue:this.parseNumber(d),quoteValue:this.parseNumber(c),timestamp:s,datetime:this.iso8601(s)})}async editOrder(e,t,i,s,a,o,n={}){let d;await this.loadMarkets();let c=this.market(t);if(!c.swap)throw new r.NotSupported(this.id+" editOrder() does not support "+c.type+" markets, only swap markets are supported");let h=this.safeString(n,"stopLossPrice"),l=this.safeString(n,"takeProfitPrice"),p=this.safeStringN(n,["triggerPrice","stopPrice","trigger_price"]),u=this.safeDict(n,"stopLoss",{}),f=this.safeDict(n,"takeProfit",{}),m=this.safeString(u,"triggerPrice"),g=this.safeString(f,"triggerPrice"),v=void 0!==p,y=void 0!==h,b=void 0!==l,w=void 0!==m,S=void 0!==g,O={symbol:c.id},_=this.safeString(n,"clientOrderId");if(void 0!==_&&(n=this.omit(n,"clientOrderId"),O.client_order_id=_),void 0!==e&&(O.order_id=e),n=this.omit(n,["triggerPrice","stopPrice","stopLossPrice","takeProfitPrice","stopLoss","takeProfit"]),(v||y||b)&&(O.price_type=this.safeInteger(n,"price_type",1),void 0!==o&&(O.executive_price=this.priceToPrecision(t,o))),v)O.type=i,O.trigger_price=this.priceToPrecision(t,p),d=await this.privatePostContractPrivateModifyPlanOrder(this.extend(O,n));else if(y||b)O.category=i,y?O.trigger_price=this.priceToPrecision(t,h):O.trigger_price=this.priceToPrecision(t,l),d=await this.privatePostContractPrivateModifyTpSlOrder(this.extend(O,n));else if(w||S)w?(O.preset_stop_loss_price_type=this.safeInteger(n,"price_type",1),O.preset_stop_loss_price=this.priceToPrecision(t,m)):(O.preset_take_profit_price_type=this.safeInteger(n,"price_type",1),O.preset_take_profit_price=this.priceToPrecision(t,g)),d=await this.privatePostContractPrivateModifyPresetPlanOrder(this.extend(O,n));else throw new r.NotSupported(this.id+" editOrder() only supports trigger, stop loss and take profit orders");let T=this.safeDict(d,"data",{});return this.parseOrder(T,c)}async fetchLedger(e,t,i,s={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.currency(e));let a={};[a,s]=this.handleUntilOption("end_time",a,s);let o=this.fetchTransactionsRequest(0,void 0,t,i,s),n=await this.privateGetContractPrivateTransactionHistory(o),d=this.safeList(n,"data",[]);return this.parseLedger(d,r,t,i)}parseLedgerEntry(e,t){let i,s=this.safeString(e,"amount");a.Y.stringLe(s,"0")?(i="out",s=a.Y.stringMul("-1",s)):i="in";let r=this.safeString(e,"asset"),o=this.safeInteger(e,"time"),n=this.safeString(e,"type");return this.safeLedgerEntry({info:e,id:this.safeString(e,"tran_id"),direction:i,account:void 0,referenceAccount:void 0,referenceId:this.safeString(e,"tradeId"),type:this.parseLedgerEntryType(n),currency:this.safeCurrencyCode(r,t),amount:this.parseNumber(s),timestamp:o,datetime:this.iso8601(o),before:void 0,after:void 0,status:void 0,fee:void 0},t)}parseLedgerEntryType(e){return this.safeString({"Commission Fee":"fee","Funding Fee":"fee","Realized PNL":"trade",Transfer:"transfer","Liquidation Clearance":"settlement"},e,e)}fetchTransactionsRequest(e,t,i,s,r={}){let a,o={};return void 0!==e&&(o.flow_type=e),void 0!==t&&(a=this.market(t),o.symbol=a.id),void 0!==i&&(o.start_time=i),void 0!==s&&(o.page_size=s),[o,r]=this.handleUntilOption("end_time",o,r),this.extend(o,r)}async fetchFundingHistory(e,t,i,s={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));let a={};[a,s]=this.handleUntilOption("end_time",a,s);let o=this.fetchTransactionsRequest(3,e,t,i,s),n=await this.privateGetContractPrivateTransactionHistory(o),d=this.safeList(n,"data",[]);return this.parseFundingHistories(d,r,t,i)}parseFundingHistory(e,t){let i=this.safeString(e,"symbol"),s=this.safeString(e,"asset"),r=this.safeInteger(e,"time");return{info:e,symbol:this.safeSymbol(i,t,void 0,"swap"),code:this.safeCurrencyCode(s),timestamp:r,datetime:this.iso8601(r),id:this.safeString(e,"tran_id"),amount:this.safeNumber(e,"amount")}}parseFundingHistories(e,t,i,s){let r=[];for(let i=0;i<e.length;i++){let s=e[i];r.push(this.parseFundingHistory(s,t))}let a=this.sortBy(r,"timestamp");return this.filterBySinceLimit(a,i,s)}nonce(){return this.milliseconds()-this.options.timeDifference}sign(e,t="public",i="GET",s={},r,a){let o=e.split("/"),d=this.safeString(o,0,"spot"),c=this.implodeHostname(this.urls.api["spot"===d||"account"===d?"spot":"swap"])+"/"+this.implodeParams(e,s),h=this.omit(s,this.extractParams(e)),l="",p="GET"===i||"DELETE"===i;if(p&&Object.keys(h).length&&(c+="?"+(l=this.urlencode(h))),"private"===t){this.checkRequiredCredentials();let e=this.nonce().toString(),t=this.safeString(this.options,"brokerId","CCXTxBitmart000");r={"X-BM-KEY":this.apiKey,"X-BM-TIMESTAMP":e,"X-BM-BROKER-ID":t,"Content-Type":"application/json"},p||(l=a=this.json(h));let i=e+"#"+this.uid+"#"+l,s=this.hmac(this.encode(i),this.encode(this.secret),n.s);r["X-BM-SIGN"]=s}return{url:c,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,c){if(void 0===n)return;let h=this.safeStringLower(n,"message"),l=void 0!==h&&"ok"!==h&&"success"!==h,p=this.safeString(n,"code");if(void 0!==p&&"1000"!==p||l){let e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,p,e),this.throwBroadlyMatchedException(this.exceptions.broad,p,e),this.throwExactlyMatchedException(this.exceptions.exact,h,e),this.throwBroadlyMatchedException(this.exceptions.broad,h,e),new r.ExchangeError(e)}}}}}]);