"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[198],{4828:(e,t,i)=>{i.d(t,{A:()=>d});var s=i(5785),a=i(8119),r=i(6077),n=i(5432),o=i(3675);class d extends s.A{describe(){return this.deepExtend(super.describe(),{id:"bingx",name:"BingX",countries:["US"],rateLimit:100,version:"v1",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!1,addMargin:!0,cancelAllOrders:!0,cancelAllOrdersAfter:!0,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!0,closePosition:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!0,createMarketSellOrderWithCost:!0,createOrder:!0,createOrders:!0,createOrderWithTakeProfitAndStopLoss:!0,createStopLossOrder:!0,createStopOrder:!0,createTakeProfitOrder:!0,createTrailingAmountOrder:!0,createTrailingPercentOrder:!0,createTriggerOrder:!0,editOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchLeverage:!0,fetchLiquidations:!1,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMarkPrice:!0,fetchMarkPrices:!0,fetchMyLiquidations:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!0,fetchPositionHistory:!1,fetchPositionMode:!0,fetchPositions:!0,fetchPositionsHistory:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!0,sandbox:!0,setLeverage:!0,setMargin:!0,setMarginMode:!0,setPositionMode:!0,transfer:!0},hostname:"bingx.com",urls:{logo:"https://github-production-user-asset-6210df.s3.amazonaws.com/1294454/253675376-6983b72e-4999-4549-b177-33b374c195e3.jpg",api:{spot:"https://open-api.{hostname}/openApi",swap:"https://open-api.{hostname}/openApi",contract:"https://open-api.{hostname}/openApi",wallets:"https://open-api.{hostname}/openApi",user:"https://open-api.{hostname}/openApi",subAccount:"https://open-api.{hostname}/openApi",account:"https://open-api.{hostname}/openApi",copyTrading:"https://open-api.{hostname}/openApi",cswap:"https://open-api.{hostname}/openApi"},test:{swap:"https://open-api-vst.{hostname}/openApi"},www:"https://bingx.com/",doc:"https://bingx-api.github.io/docs/",referral:"https://bingx.com/invite/OHETOM"},fees:{tierBased:!0,spot:{feeSide:"get",maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},swap:{feeSide:"quote",maker:this.parseNumber("0.0002"),taker:this.parseNumber("0.0005")}},requiredCredentials:{apiKey:!0,secret:!0},api:{spot:{v1:{public:{get:{"server/time":1,"common/symbols":1,"market/trades":1,"market/depth":1,"market/kline":1,"ticker/24hr":1,"ticker/price":1,"ticker/bookTicker":1}},private:{get:{"trade/query":1,"trade/openOrders":1,"trade/historyOrders":1,"trade/myTrades":2,"user/commissionRate":5,"account/balance":2},post:{"trade/order":2,"trade/cancel":2,"trade/batchOrders":5,"trade/order/cancelReplace":5,"trade/cancelOrders":5,"trade/cancelOpenOrders":5,"trade/cancelAllAfter":5}}},v2:{public:{get:{"market/depth":1,"market/kline":1}}},v3:{private:{get:{"get/asset/transfer":1,"asset/transfer":1,"capital/deposit/hisrec":1,"capital/withdraw/history":1},post:{"post/asset/transfer":5}}}},swap:{v1:{public:{get:{"ticker/price":1,"market/historicalTrades":1,"market/markPriceKlines":1,"trade/multiAssetsRules":1}},private:{get:{"positionSide/dual":5,"trade/batchCancelReplace":5,"trade/fullOrder":2,maintMarginRatio:2,"trade/positionHistory":2,"positionMargin/history":2,"twap/openOrders":5,"twap/historyOrders":5,"twap/orderDetail":5,"trade/assetMode":5,"user/marginAssets":5},post:{"trade/cancelReplace":2,"positionSide/dual":5,"trade/batchCancelReplace":5,"trade/closePosition":2,"trade/getVst":5,"twap/order":5,"twap/cancelOrder":5,"trade/assetMode":5}}},v2:{public:{get:{"server/time":1,"quote/contracts":1,"quote/price":1,"quote/depth":1,"quote/trades":1,"quote/premiumIndex":1,"quote/fundingRate":1,"quote/klines":1,"quote/openInterest":1,"quote/ticker":1,"quote/bookTicker":1}},private:{get:{"user/balance":2,"user/positions":2,"user/income":2,"trade/openOrders":2,"trade/openOrder":2,"trade/order":2,"trade/marginType":5,"trade/leverage":2,"trade/forceOrders":1,"trade/allOrders":2,"trade/allFillOrders":2,"trade/fillHistory":2,"user/income/export":2,"user/commissionRate":2,"quote/bookTicker":1},post:{"trade/order":2,"trade/batchOrders":2,"trade/closeAllPositions":2,"trade/cancelAllAfter":5,"trade/marginType":5,"trade/leverage":5,"trade/positionMargin":5,"trade/order/test":2},delete:{"trade/order":2,"trade/batchOrders":2,"trade/allOpenOrders":2}}},v3:{public:{get:{"quote/klines":1}}}},cswap:{v1:{public:{get:{"market/contracts":1,"market/premiumIndex":1,"market/openInterest":1,"market/klines":1,"market/depth":1,"market/ticker":1}},private:{get:{"trade/leverage":2,"trade/forceOrders":2,"trade/allFillOrders":2,"trade/openOrders":2,"trade/orderDetail":2,"trade/orderHistory":2,"trade/marginType":2,"user/commissionRate":2,"user/positions":2,"user/balance":2},post:{"trade/order":2,"trade/leverage":2,"trade/allOpenOrders":2,"trade/closeAllPositions":2,"trade/marginType":2,"trade/positionMargin":2},delete:{"trade/allOpenOrders":2,"trade/cancelOrder":2}}}},contract:{v1:{private:{get:{allPosition:2,allOrders:2,balance:2}}}},wallets:{v1:{private:{get:{"capital/config/getall":5,"capital/deposit/address":5,"capital/innerTransfer/records":1,"capital/subAccount/deposit/address":5,"capital/deposit/subHisrec":2,"capital/subAccount/innerTransfer/records":1,"capital/deposit/riskRecords":5},post:{"capital/withdraw/apply":5,"capital/innerTransfer/apply":5,"capital/subAccountInnerTransfer/apply":2,"capital/deposit/createSubAddress":2}}}},subAccount:{v1:{private:{get:{list:10,assets:2,allAccountBalance:2},post:{create:10,"apiKey/create":2,"apiKey/edit":2,"apiKey/del":2,updateStatus:10}}}},account:{v1:{private:{get:{uid:1,"apiKey/query":2,"account/apiPermissions":5},post:{"innerTransfer/authorizeSubAccount":1}}},transfer:{v1:{private:{get:{"subAccount/asset/transferHistory":1},post:{"subAccount/transferAsset/supportCoins":1,"subAccount/transferAsset":1}}}}},user:{auth:{private:{post:{userDataStream:2},put:{userDataStream:2},delete:{userDataStream:2}}}},copyTrading:{v1:{private:{get:{"swap/trace/currentTrack":2},post:{"swap/trace/closeTrackOrder":2,"swap/trace/setTPSL":2,"spot/trader/sellOrder":10}}}},api:{v3:{private:{get:{"asset/transfer":1,"capital/deposit/hisrec":1,"capital/withdraw/history":1},post:{"post/asset/transfer":1}}}}},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},precisionMode:o.kb,exceptions:{exact:{400:a.BadRequest,401:a.AuthenticationError,403:a.PermissionDenied,404:a.BadRequest,429:a.DDoSProtection,418:a.PermissionDenied,500:a.ExchangeError,504:a.ExchangeError,100001:a.AuthenticationError,100412:a.AuthenticationError,100202:a.InsufficientFunds,100204:a.BadRequest,100400:a.BadRequest,100410:a.OperationFailed,100421:a.BadSymbol,100440:a.ExchangeError,100500:a.OperationFailed,100503:a.ExchangeError,80001:a.BadRequest,80012:a.InsufficientFunds,80014:a.BadRequest,80016:a.OrderNotFound,80017:a.OrderNotFound,100414:a.AccountSuspended,100419:a.PermissionDenied,100437:a.BadRequest,101204:a.InsufficientFunds,110425:a.InvalidOrder},broad:{}},commonCurrencies:{SNOW:"Snowman",OMNI:"OmniCat",NAP:"$NAP"},options:{defaultType:"spot",accountsByType:{spot:"FUND",swap:"PFUTURES",future:"SFUTURES"},accountsById:{FUND:"spot",PFUTURES:"swap",SFUTURES:"future"},recvWindow:5e3,broker:"CCXT",defaultNetworks:{ETH:"ETH",USDT:"ERC20",USDC:"ERC20",BTC:"BTC",LTC:"LTC"},networks:{ARB:"ARBITRUM",MATIC:"POLYGON"}},features:{defaultForLinear:{sandbox:!0,createOrder:{marginMode:!1,triggerPrice:!0,triggerPriceType:{last:!0,mark:!0,index:!0},triggerDirection:!1,stopLossPrice:!0,takeProfitPrice:!0,attachedStopLossTakeProfit:{triggerPriceType:{last:!0,mark:!0,index:!0},price:!0},timeInForce:{IOC:!0,FOK:!0,PO:!0,GTD:!1},hedged:!0,trailing:!0,leverage:!1,marketBuyRequiresPrice:!1,marketBuyByCost:!0,selfTradePrevention:!1,iceberg:!1},createOrders:{max:5},fetchMyTrades:{marginMode:!1,limit:512,daysBack:30,untilDays:30},fetchOrder:{marginMode:!1,trigger:!1,trailing:!1},fetchOpenOrders:{marginMode:!1,limit:void 0,trigger:!1,trailing:!1},fetchOrders:{marginMode:!1,limit:1e3,daysBack:2e4,untilDays:7,trigger:!1,trailing:!1},fetchClosedOrders:{marginMode:!1,limit:1e3,daysBack:void 0,daysBackCanceled:void 0,untilDays:7,trigger:!1,trailing:!1},fetchOHLCV:{limit:1440}},defaultForInverse:{extends:"defaultForLinear",fetchMyTrades:{limit:1e3,daysBack:void 0,untilDays:void 0},fetchOHLCV:{limit:1440},fetchOrders:void 0,fetchClosedOrders:{marginMode:!1,limit:1e3,daysBack:void 0,daysBackCanceled:void 0,untilDays:7,trigger:!1,trailing:!1}},spot:{extends:"defaultForLinear",createOrder:{triggerPriceType:void 0,attachedStopLossTakeProfit:void 0,trailing:!1},fetchMyTrades:{limit:1e3,daysBack:1,untilDays:1},fetchOrders:void 0,fetchClosedOrders:{limit:100,untilDays:void 0}},swap:{linear:{extends:"defaultForLinear"},inverse:{extends:"defaultForInverse"}},future:{linear:{extends:"defaultForLinear"},inverse:{extends:"defaultForInverse"}}}})}async fetchTime(e={}){let t=await this.swapV2PublicGetServerTime(e),i=this.safeDict(t,"data");return this.safeInteger(i,"serverTime")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1)||this.safeBool(this.options,"sandboxMode",!1))return;let t=await this.walletsV1PrivateGetCapitalConfigGetall(e),i=this.safeList(t,"data",[]),s={};for(let e=0;e<i.length;e++){let t;let a=i[e],r=this.safeString(a,"coin"),n=this.safeCurrencyCode(r),o=this.safeString(a,"name"),d=this.safeList(a,"networkList"),h={},l=!1,c=!1,p={};for(let e=0;e<d.length;e++){let i=d[e],s=this.safeString(i,"network"),a=this.networkIdToCode(s),r=this.safeBool(i,"isDefault"),n=this.safeBool(i,"depositEnable");n&&(l=!0);let o=this.safeBool(i,"withdrawEnable");o&&(c=!0);let f={withdraw:{min:this.safeNumber(i,"withdrawMin"),max:this.safeNumber(i,"withdrawMax")}};t=this.safeNumber(i,"withdrawFee"),r&&(p=f);let u=this.safeNumber(i,"withdrawPrecision"),m=n||o;h[a]={info:i,id:s,network:a,fee:t,active:m,deposit:n,withdraw:o,precision:u,limits:f}}let f=l||c;s[n]={info:a,code:n,id:r,precision:void 0,name:o,active:f,deposit:l,withdraw:c,networks:h,fee:t,limits:p}}return s}async fetchSpotMarkets(e){let t=await this.spotV1PublicGetCommonSymbols(e),i=this.safeDict(t,"data"),s=this.safeList(i,"symbols",[]);return this.parseMarkets(s)}async fetchSwapMarkets(e){let t=await this.swapV2PublicGetQuoteContracts(e),i=this.safeList(t,"data",[]);return this.parseMarkets(i)}async fetchInverseSwapMarkets(e){let t=await this.cswapV1PublicGetMarketContracts(e),i=this.safeList(t,"data",[]);return this.parseMarkets(i)}parseMarket(e){let t=this.safeString(e,"symbol"),i=t.split("-"),s=i[0],a=i[1],r=this.safeCurrencyCode(s),n=this.safeCurrencyCode(a),o=this.safeString(e,"currency"),d=!1,h=!0,l=this.safeNumber(e,"minTickSize");void 0!==l&&(o=s,d=!0,h=!1);let c=this.safeCurrencyCode(o),p=this.safeNumber(e,"tickSize");void 0===p&&(p=this.parseNumber(this.parsePrecision(this.safeString(e,"pricePrecision"))));let f=this.safeNumber(e,"stepSize");void 0===f&&(f=this.parseNumber(this.parsePrecision(this.safeString(e,"quantityPrecision"))));let u=void 0!==c?"swap":"spot",m="spot"===u,g="swap"===u,w=r+"/"+n;void 0!==c&&(w+=":"+c);let y=this.safeDict(this.fees,u,{}),v=g?this.parseNumber("1"):void 0,T=!1;"true"===this.safeString(e,"apiStateOpen")&&"true"===this.safeString(e,"apiStateClose")?T=!0:this.safeBool(e,"apiStateSell")&&this.safeBool(e,"apiStateBuy")&&"1"===this.safeString(e,"status")&&(T=!0);let P=m?void 0:d,k=m?void 0:h,S=this.safeInteger(e,"timeOnline");return 0===S&&(S=void 0),this.safeMarketStructure({id:t,symbol:w,base:r,quote:n,settle:c,baseId:s,quoteId:a,settleId:o,type:u,spot:m,margin:!1,swap:g,future:!1,option:!1,active:T,contract:g,linear:k,inverse:P,taker:this.safeNumber(y,"taker"),maker:this.safeNumber(y,"maker"),feeSide:this.safeString(y,"feeSide"),contractSize:v,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:f,price:p},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber2(e,"minQty","tradeMinQuantity"),max:this.safeNumber(e,"maxQty")},price:{min:l,max:void 0},cost:{min:this.safeNumberN(e,["minNotional","tradeMinUSDT","minTradeValue"]),max:this.safeNumber(e,"maxNotional")}},created:S,info:e})}async fetchMarkets(e={}){let t=[this.fetchSwapMarkets(e)];this.safeBool(this.options,"sandboxMode",!1)||(t.push(this.fetchInverseSwapMarkets(e)),t.push(this.fetchSpotMarkets(e)));let i=await Promise.all(t),s=this.safeList(i,0,[]),a=this.safeList(i,1,[]),r=this.safeList(i,2,[]),n=this.arrayConcat(s,a);return this.arrayConcat(r,n)}async fetchOHLCV(e,t="1m",i,s,a={}){let r;await this.loadMarkets();let n=!1;if([n,a]=this.handleOptionAndParams(a,"fetchOHLCV","paginate",!1),n)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,i,s,t,a,1440);let o=this.market(e),d={symbol:o.id};d.interval=this.safeString(this.timeframes,t,t),void 0!==i&&(d.startTime=Math.max(i-1,0)),void 0!==s&&(d.limit=s);let h=this.safeInteger2(a,"until","endTime");if(void 0!==h&&(a=this.omit(a,["until"]),d.endTime=h),o.spot)r=await this.spotV1PublicGetMarketKline(this.extend(d,a));else if(o.inverse)r=await this.cswapV1PublicGetMarketKlines(this.extend(d,a));else{let e=this.safeString(a,"price");a=this.omit(a,"price"),r="mark"===e?await this.swapV1PublicGetMarketMarkPriceKlines(this.extend(d,a)):await this.swapV3PublicGetQuoteKlines(this.extend(d,a))}let l=this.safeValue(r,"data",[]);return Array.isArray(l)||(l=[l]),this.parseOHLCVs(l,o,t,i,s)}parseOHLCV(e,t){return Array.isArray(e)?[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:[this.safeInteger2(e,"time","closeTime"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchTrades(e,t,i,s={}){let a,r;await this.loadMarkets();let n=this.market(e),o={symbol:n.id};void 0!==i&&(o.limit=Math.min(i,100)),[r,s]=this.handleMarketTypeAndParams("fetchTrades",n,s),a="spot"===r?await this.spotV1PublicGetMarketTrades(this.extend(o,s)):await this.swapV2PublicGetQuoteTrades(this.extend(o,s));let d=this.safeList(a,"data",[]);return this.parseTrades(d,n,t,i)}parseTrade(e,t){let i,s=this.safeIntegerN(e,["time","filledTm","T","tradeTime"]),a=this.safeString(e,"filledTm");void 0!==a&&(s=this.parse8601(a)),0===s&&(s=void 0);let n=this.safeString(e,"quoteQty"),o=this.safeStringN(e,["currency","N","commissionAsset"]),d=this.safeCurrencyCode(o),h=this.safeBool(e,"m"),l=this.safeString2(e,"s","symbol"),c=this.safeBoolN(e,["buyerMaker","isBuyerMaker","maker"]);(void 0!==c||void 0!==h)&&(i=c||h?"maker":"taker");let p=this.safeStringLower2(e,"side","S");void 0===p&&(void 0!==c||void 0!==h)&&(p=c||h?"sell":"buy",i="taker");let f=this.safeBool(e,"isBuyer");void 0!==f&&(p=f?"buy":"sell");let u=this.safeBool(e,"isMaker");void 0!==u&&(i=u?"maker":"taker");let m=this.safeStringN(e,["qty","amount","q"]);if(void 0!==t&&t.swap&&"volume"in e){let i=this.safeString(t.info,"tradeMinQuantity"),s=this.safeString(e,"volume");m=r.Y.stringMul(s,i)}return this.safeTrade({id:this.safeStringN(e,["id","t"]),info:e,timestamp:s,datetime:this.iso8601(s),symbol:this.safeSymbol(l,t,"-"),order:this.safeString2(e,"orderId","i"),type:this.safeStringLower(e,"o"),side:this.parseOrderSide(p),takerOrMaker:i,price:this.safeStringN(e,["price","p","tradePrice"]),amount:m,cost:n,fee:{cost:this.parseNumber(r.Y.stringAbs(this.safeString2(e,"commission","n"))),currency:d}},t)}async fetchOrderBook(e,t,i={}){let s,a;await this.loadMarkets();let r=this.market(e),n={symbol:r.id};void 0!==t&&(n.limit=t),[a,i]=this.handleMarketTypeAndParams("fetchOrderBook",r,i),s="spot"===a?await this.spotV1PublicGetMarketDepth(this.extend(n,i)):r.inverse?await this.cswapV1PublicGetMarketDepth(this.extend(n,i)):await this.swapV2PublicGetQuoteDepth(this.extend(n,i));let o=this.safeDict(s,"data",{}),d=this.safeInteger2(o,"T","ts");return this.parseOrderBook(o,r.symbol,d,"bids","asks",0,1)}async fetchFundingRate(e,t={}){let i;await this.loadMarkets();let s=this.market(e),a={symbol:s.id};i=s.inverse?await this.cswapV1PublicGetMarketPremiumIndex(this.extend(a,t)):await this.swapV2PublicGetQuotePremiumIndex(this.extend(a,t));let r=this.safeList(i,"data",[]);return this.parseFundingRate(r,s)}async fetchFundingRates(e,t={}){await this.loadMarkets(),e=this.marketSymbols(e,"swap",!0);let i=await this.swapV2PublicGetQuotePremiumIndex(this.extend(t)),s=this.safeList(i,"data",[]);return this.parseFundingRates(s,e)}parseFundingRate(e,t){let i=this.safeString(e,"symbol"),s=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:this.safeSymbol(i,t,"-","swap"),markPrice:this.safeNumber(e,"markPrice"),indexPrice:this.safeNumber(e,"indexPrice"),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"lastFundingRate"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:s,nextFundingDatetime:this.iso8601(s),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0,interval:void 0}}async fetchFundingRateHistory(e,t,i,s={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let r=!1;if([r,s]=this.handleOptionAndParams(s,"fetchFundingRateHistory","paginate"),r)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,i,"8h",s);let n=this.market(e),o={symbol:n.id};void 0!==t&&(o.startTime=t),void 0!==i&&(o.limit=i);let d=this.safeInteger2(s,"until","startTime");void 0!==d&&(s=this.omit(s,["until"]),o.startTime=d);let h=await this.swapV2PublicGetQuoteFundingRate(this.extend(o,s)),l=this.safeList(h,"data",[]),c=[];for(let e=0;e<l.length;e++){let t=l[e],i=this.safeString(t,"symbol"),s=this.safeSymbol(i,n,"-","swap"),a=this.safeInteger(t,"fundingTime");c.push({info:t,symbol:s,fundingRate:this.safeNumber(t,"fundingRate"),timestamp:a,datetime:this.iso8601(a)})}let p=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(p,n.symbol,t,i)}async fetchOpenInterest(e,t={}){let i;await this.loadMarkets();let s=this.market(e),a={symbol:s.id};i=s.inverse?await this.cswapV1PublicGetMarketOpenInterest(this.extend(a,t)):await this.swapV2PublicGetQuoteOpenInterest(this.extend(a,t));let r={};if(s.inverse){let e=this.safeList(i,"data",[]);r=this.safeDict(e,0,{})}else r=this.safeDict(i,"data",{});return this.parseOpenInterest(r,s)}parseOpenInterest(e,t){let i=this.safeInteger2(e,"time","timestamp"),s=this.safeString(e,"symbol"),a=this.safeSymbol(s,t,"-","swap"),r=this.safeNumber(e,"openInterest");return this.safeOpenInterest({symbol:a,baseVolume:void 0,quoteVolume:void 0,openInterestAmount:void 0,openInterestValue:r,timestamp:i,datetime:this.iso8601(i),info:e},t)}async fetchTicker(e,t={}){let i;await this.loadMarkets();let s=this.market(e),a={symbol:s.id};i=s.spot?await this.spotV1PublicGetTicker24hr(this.extend(a,t)):s.inverse?await this.cswapV1PublicGetMarketTicker(this.extend(a,t)):await this.swapV2PublicGetQuoteTicker(this.extend(a,t));let r=this.safeList(i,"data");if(void 0!==r){let e=this.safeDict(r,0,{});return this.parseTicker(e,s)}let n=this.safeDict(i,"data",{});return this.parseTicker(n,s)}async fetchTickers(e,t={}){let i,s,a,r;if(await this.loadMarkets(),void 0!==e){e=this.marketSymbols(e);let t=this.safeString(e,0);void 0!==t&&(i=this.market(t))}[s,t]=this.handleMarketTypeAndParams("fetchTickers",i,t),[a,t]=this.handleSubTypeAndParams("fetchTickers",i,t),r="spot"===s?await this.spotV1PublicGetTicker24hr(t):"inverse"===a?await this.cswapV1PublicGetMarketTicker(t):await this.swapV2PublicGetQuoteTicker(t);let n=this.safeList(r,"data");return this.parseTickers(n,e)}async fetchMarkPrice(e,t={}){let i,s;await this.loadMarkets();let a=this.market(e);[i,t]=this.handleSubTypeAndParams("fetchMarkPrice",a,t,"linear");let r={symbol:a.id};return Array.isArray((s="inverse"===i?await this.cswapV1PublicGetMarketPremiumIndex(this.extend(r,t)):await this.swapV2PublicGetQuotePremiumIndex(this.extend(r,t))).data)?this.parseTicker(this.safeDict(s.data,0,{}),a):this.parseTicker(s.data,a)}async fetchMarkPrices(e,t={}){let i,s,a;if(await this.loadMarkets(),void 0!==e){e=this.marketSymbols(e);let t=this.safeString(e,0);void 0!==t&&(i=this.market(t))}[s,t]=this.handleSubTypeAndParams("fetchMarkPrices",i,t,"linear"),a="inverse"===s?await this.cswapV1PublicGetMarketPremiumIndex(t):await this.swapV2PublicGetQuotePremiumIndex(t);let r=this.safeList(a,"data");return this.parseTickers(r,e)}parseTicker(e,t){let i=this.safeString(e,"symbol"),s=this.safeString(e,"lastQty"),a=(t=this.safeMarket(i,t,void 0,void 0===s?"spot":"swap")).symbol,r=this.safeString(e,"openPrice"),n=this.safeString(e,"highPrice"),o=this.safeString(e,"lowPrice"),d=this.safeString(e,"lastPrice"),h=this.safeString(e,"quoteVolume"),l=this.safeString(e,"volume"),c=this.safeString(e,"priceChangePercent");void 0!==c&&(c=c.replace("%",""));let p=this.safeString(e,"priceChange"),f=this.safeInteger(e,"closeTime");0===f&&(f=void 0);let u=this.iso8601(f),m=this.safeString(e,"bidPrice"),g=this.safeString(e,"bidQty"),w=this.safeString(e,"askPrice"),y=this.safeString(e,"askQty");return this.safeTicker({symbol:a,timestamp:f,datetime:u,high:n,low:o,bid:m,bidVolume:g,ask:w,askVolume:y,vwap:void 0,open:r,close:d,last:void 0,previousClose:void 0,change:p,percentage:c,average:void 0,baseVolume:l,quoteVolume:h,markPrice:this.safeString(e,"markPrice"),indexPrice:this.safeString(e,"indexPrice"),info:e},t)}async fetchBalance(e={}){let t,i,s;await this.loadMarkets(),[i,e]=this.handleOptionAndParams(e,"fetchBalance","standard",!1),[s,e]=this.handleSubTypeAndParams("fetchBalance",void 0,e);let[a,r]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);return t=i?await this.contractV1PrivateGetBalance(r):"spot"===a?await this.spotV1PrivateGetAccountBalance(r):"inverse"===s?await this.cswapV1PrivateGetUserBalance(r):await this.swapV2PrivateGetUserBalance(r),this.parseBalance(t)}parseBalance(e){let t={info:e},i=this.safeList(e,"data"),s=this.safeDict(i,0),a=this.safeDict(e,"data",{}),r=this.safeList(a,"balances"),n=this.safeDict(r,0);if(void 0!==s)for(let e=0;e<i.length;e++){let s=i[e],a=this.safeString(s,"asset"),r=this.safeCurrencyCode(a),n=this.account();n.free=this.safeString2(s,"availableMargin","availableBalance"),n.used=this.safeString(s,"usedMargin"),n.total=this.safeString(s,"maxWithdrawAmount"),t[r]=n}else if(void 0!==n)for(let e=0;e<r.length;e++){let i=r[e],s=this.safeString(i,"asset"),a=this.safeCurrencyCode(s),n=this.account();n.free=this.safeString(i,"free"),n.used=this.safeString(i,"locked"),t[a]=n}else{let i=this.safeDict(e,"data",{}),s=this.safeDict(i,"balance"),a=this.safeString(s,"asset"),r=this.safeCurrencyCode(a),n=this.account();n.free=this.safeString(s,"availableMargin"),n.used=this.safeString(s,"usedMargin"),t[r]=n}return this.safeBalance(t)}async fetchPositionHistory(e,t,i,s={}){let r;await this.loadMarkets();let n=this.market(e),o={symbol:n.id};if(void 0!==i&&(o.pageSize=i),void 0!==t&&(o.startTs=t),[o,s]=this.handleUntilOption("endTs",o,s),n.linear)r=await this.swapV1PrivateGetTradePositionHistory(this.extend(o,s));else throw new a.NotSupported(this.id+" fetchPositionHistory() is not supported for inverse swap positions");let d=this.safeDict(r,"data",{}),h=this.safeList(d,"positionHistory",[]),l=this.parsePositions(h);return this.filterBySymbolSinceLimit(l,e,t,i)}async fetchPositions(e,t={}){let i,s;if(await this.loadMarkets(),e=this.marketSymbols(e),[i,t]=this.handleOptionAndParams(t,"fetchPositions","standard",!1),i)s=await this.contractV1PrivateGetAllPosition(t);else{let i,a;if(void 0!==e){e=this.marketSymbols(e);let t=this.safeString(e,0);void 0!==t&&(i=this.market(t))}[a,t]=this.handleSubTypeAndParams("fetchPositions",i,t),s="inverse"===a?await this.cswapV1PrivateGetUserPositions(t):await this.swapV2PrivateGetUserPositions(t)}let a=this.safeList(s,"data",[]);return this.parsePositions(a,e)}async fetchPosition(e,t={}){let i;await this.loadMarkets();let s=this.market(e);if(!s.swap)throw new a.BadRequest(this.id+" fetchPosition() supports swap markets only");let r={symbol:s.id};i=s.inverse?await this.cswapV1PrivateGetUserPositions(this.extend(r,t)):await this.swapV2PrivateGetUserPositions(this.extend(r,t));let n=this.safeList(i,"data",[]),o=this.safeDict(n,0,{});return this.parsePosition(o,s)}parsePosition(e,t){let i,s=this.safeString(e,"symbol","");s=s.replace("/","-");let a=this.safeBool(e,"isolated");void 0!==a&&(i=a?"isolated":"cross");let r=this.safeInteger(e,"openTime");return this.safePosition({info:e,id:this.safeString(e,"positionId"),symbol:this.safeSymbol(s,t,"-","swap"),notional:this.safeNumber(e,"positionValue"),marginMode:i,liquidationPrice:void 0,entryPrice:this.safeNumber2(e,"avgPrice","entryPrice"),unrealizedPnl:this.safeNumber(e,"unrealizedProfit"),realizedPnl:this.safeNumber(e,"realisedProfit"),percentage:void 0,contracts:this.safeNumber(e,"positionAmt"),contractSize:void 0,markPrice:this.safeNumber(e,"markPrice"),lastPrice:void 0,side:this.safeStringLower(e,"positionSide"),hedged:void 0,timestamp:r,datetime:this.iso8601(r),lastUpdateTimestamp:this.safeInteger(e,"updateTime"),maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:void 0,initialMargin:this.safeNumber(e,"initialMargin"),initialMarginPercentage:void 0,leverage:this.safeNumber(e,"leverage"),marginRatio:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async createMarketOrderWithCost(e,t,i,s={}){return await this.createOrder(e,"market",t,i,void 0,this.extend({quoteOrderQty:i},s))}async createMarketBuyOrderWithCost(e,t,i={}){return await this.createOrder(e,"market","buy",t,void 0,this.extend({quoteOrderQty:t},i))}async createMarketSellOrderWithCost(e,t,i={}){return await this.createOrder(e,"market","sell",t,void 0,this.extend({quoteOrderQty:t},i))}createOrderRequest(e,t,i,s,n,o={}){let d,h;let l=this.market(e);[h,o]=this.handleMarketTypeAndParams("createOrder",l,o),t=t.toUpperCase();let c={symbol:l.id,type:t,side:i.toUpperCase()},p="MARKET"===t,f="spot"===h,u="TWAP"===t;if(u&&f)throw new a.BadSymbol(this.id+" createOrder() twap order supports swap contracts only");let m=this.safeString(o,"stopLossPrice"),g=this.safeString(o,"takeProfitPrice"),w=this.safeString2(o,"stopPrice","triggerPrice"),y=void 0!==w,v=void 0!==m,T=void 0!==g,P=f?"newClientOrderId":"clientOrderID",k=this.safeString2(o,P,"clientOrderId");void 0!==k&&(c[P]=k);let S=this.safeStringUpper(o,"timeInForce");if([d,o]=this.handlePostOnly(p,"PostOnly"===S,o),d||"PostOnly"===S?c.timeInForce="PostOnly":"IOC"===S?c.timeInForce="IOC":"GTC"===S&&(c.timeInForce="GTC"),f){let i=this.safeString2(o,"cost","quoteOrderQty");if(o=this.omit(o,"cost"),void 0!==i)c.quoteOrderQty=this.parseToNumeric(this.costToPrecision(e,i));else if(p&&void 0!==n){let e=r.Y.stringMul(this.numberToString(s),this.numberToString(n));c.quoteOrderQty=this.parseToNumeric(e)}else c.quantity=this.parseToNumeric(this.amountToPrecision(e,s));if(p||(c.price=this.parseToNumeric(this.priceToPrecision(e,n))),void 0!==w){if(p&&void 0===this.safeString(c,"quoteOrderQty"))throw new a.ArgumentsRequired(this.id+" createOrder() requires the cost parameter (or the amount + price) for placing spot market-buy trigger orders");c.stopPrice=this.priceToPrecision(e,w),"LIMIT"===t?c.type="TRIGGER_LIMIT":"MARKET"===t&&(c.type="TRIGGER_MARKET")}else if(void 0!==m||void 0!==g){let i=void 0!==m?m:g;"LIMIT"===t?c.type="TAKE_STOP_LIMIT":"MARKET"===t&&(c.type="TAKE_STOP_MARKET"),c.stopPrice=this.parseToNumeric(this.priceToPrecision(e,i))}}else{let a;if(u){let t={symbol:c.symbol,side:c.side,positionSide:"buy"===i?"LONG":"SHORT",triggerPrice:this.parseToNumeric(this.priceToPrecision(e,w)),totalAmount:this.parseToNumeric(this.amountToPrecision(e,s))};return this.extend(t,o)}"FOK"===S&&(c.timeInForce="FOK");let d=this.safeString(o,"trailingAmount"),h=this.safeString2(o,"trailingPercent","priceRate"),f=this.safeString(o,"trailingType","TRAILING_STOP_MARKET"),P=void 0!==d,k=void 0!==h,O=P||k,b=this.safeValue(o,"stopLoss"),M=this.safeValue(o,"takeProfit"),A=void 0!==b,I=void 0!==M;"LIMIT"!==t&&"TRIGGER_LIMIT"!==t&&"STOP"!==t&&"TAKE_PROFIT"!==t||O||(c.price=this.parseToNumeric(this.priceToPrecision(e,n)));let x=this.safeBool(o,"reduceOnly",!1);if(y)c.stopPrice=this.parseToNumeric(this.priceToPrecision(e,w)),p||"TRIGGER_MARKET"===t?c.type="TRIGGER_MARKET":("LIMIT"===t||"TRIGGER_LIMIT"===t)&&(c.type="TRIGGER_LIMIT");else if(v||T)x=!0,v?(c.stopPrice=this.parseToNumeric(this.priceToPrecision(e,m)),p||"STOP_MARKET"===t?c.type="STOP_MARKET":("LIMIT"===t||"STOP"===t)&&(c.type="STOP")):T&&(c.stopPrice=this.parseToNumeric(this.priceToPrecision(e,g)),p||"TAKE_PROFIT_MARKET"===t?c.type="TAKE_PROFIT_MARKET":("LIMIT"===t||"TAKE_PROFIT"===t)&&(c.type="TAKE_PROFIT"));else if(O){if(c.type=f,P)c.price=this.parseToNumeric(d);else if(k){let e=r.Y.stringDiv(h,"100");c.priceRate=this.parseToNumeric(e)}}if(A||I){let t=this.numberToString(s);if(A){let i=this.safeString2(b,"triggerPrice","stopPrice",b),s=this.safeString(b,"workingType","MARK_PRICE"),a=this.safeString(b,"type","STOP_MARKET"),r={stopPrice:this.parseToNumeric(this.priceToPrecision(e,i)),workingType:s,type:a},n=this.safeString(b,"price");void 0!==n&&(r.price=this.parseToNumeric(this.priceToPrecision(e,n)));let o=this.safeString(b,"quantity",t);r.quantity=this.parseToNumeric(this.amountToPrecision(e,o)),c.stopLoss=this.json(r)}if(I){let i=this.safeString2(M,"triggerPrice","stopPrice",M),s=this.safeString(M,"workingType","MARK_PRICE"),a=this.safeString(M,"type","TAKE_PROFIT_MARKET"),r={stopPrice:this.parseToNumeric(this.priceToPrecision(e,i)),workingType:s,type:a},n=this.safeString(M,"price");void 0!==n&&(r.price=this.parseToNumeric(this.priceToPrecision(e,n)));let o=this.safeString(M,"quantity",t);r.quantity=this.parseToNumeric(this.amountToPrecision(e,o)),c.takeProfit=this.json(r)}}this.safeBool(o,"hedged",!1)?(o=this.omit(o,"reduceOnly"),a=x?"buy"===i?"SHORT":"LONG":"buy"===i?"LONG":"SHORT"):a="BOTH",c.positionSide=a,c.quantity=l.inverse?s:this.parseToNumeric(this.amountToPrecision(e,s))}return o=this.omit(o,["hedged","triggerPrice","stopLossPrice","takeProfitPrice","trailingAmount","trailingPercent","trailingType","takeProfit","stopLoss","clientOrderId"]),this.extend(c,o)}async createOrder(e,t,i,s,a,r={}){let n;await this.loadMarkets();let o=this.market(e),d=this.safeBool(r,"test",!1);r=this.omit(r,"test");let h=this.createOrderRequest(e,t,i,s,a,r);"string"==typeof(n=o.swap?d?await this.swapV2PrivatePostTradeOrderTest(h):o.inverse?await this.cswapV1PrivatePostTradeOrder(h):"twap"===t?await this.swapV1PrivatePostTwapOrder(h):await this.swapV2PrivatePostTradeOrder(h):await this.spotV1PrivatePostTradeOrder(h))&&(n=this.fixStringifiedJsonMembers(n),n=this.parseJson(n));let l=this.safeDict(n,"data",{}),c={};return c=o.swap?o.inverse?n:this.safeDict(l,"order",l):l,this.parseOrder(c,o)}async createOrders(e,t={}){let i;await this.loadMarkets();let s=[],r=[];for(let t=0;t<e.length;t++){let i=e[t],a=this.safeString(i,"symbol"),n=this.safeString(i,"type");r.push(a);let o=this.safeString(i,"side"),d=this.safeNumber(i,"amount"),h=this.safeNumber(i,"price"),l=this.safeDict(i,"params",{}),c=this.createOrderRequest(a,n,o,d,h,l);s.push(c)}let n=this.marketSymbols(r,void 0,!1,!0,!0),o=n.length,d=this.market(n[0]),h={};if(d.swap){if(o>5)throw new a.InvalidOrder(this.id+" createOrders() can not create more than 5 orders at once for swap markets");h.batchOrders=this.json(s),i=await this.swapV2PrivatePostTradeBatchOrders(h)}else this.safeBool(t,"sync",!1)&&(h.sync=!0),h.data=this.json(s),i=await this.spotV1PrivatePostTradeBatchOrders(h);"string"==typeof i&&(i=this.fixStringifiedJsonMembers(i),i=this.parseJson(i));let l=this.safeDict(i,"data",{}),c=this.safeList(l,"orders",[]);return this.parseOrders(c,d)}parseOrderSide(e){return this.safeString({BUY:"buy",SELL:"sell",SHORT:"sell",LONG:"buy",ask:"sell",bid:"buy"},e,e)}parseOrderType(e){return this.safeString({trigger_market:"market",trigger_limit:"limit",stop_limit:"limit",stop_market:"market",take_profit_market:"market",stop:"limit"},e,e)}parseOrder(e,t){let i,s;let a=e,n=this.safeDict2(e,"newOrderResponse","orderOpenResponse");void 0!==n&&(e=n);let o=void 0===this.safeString2(e,"positionSide","ps")?"spot":"swap",d=this.safeString2(e,"symbol","s");void 0===t&&(t=this.safeMarket(d,void 0,void 0,o));let h=this.safeStringLower2(e,"side","S"),l=this.safeIntegerN(e,["time","transactTime","E","createdTime"]),c=this.safeInteger2(e,"updateTime","T"),p=this.safeStringUpperN(e,["status","X","orderStatus"]),f=this.safeString2(e,"feeAsset","N"),u=this.safeStringN(e,["fee","commission","n"]);void 0===f&&(f=t.spot&&"buy"===h?t.base:t.quote);let m=this.safeValue(e,"stopLoss");void 0!==m&&""!==m&&(i=this.omitZero(this.safeString(m,"stopLoss"))),void 0!==m&&"number"!=typeof m&&""!==m&&("string"==typeof m&&(m=this.parseJson(m)),i=this.omitZero(this.safeString(m,"stopPrice")));let g=this.safeValue(e,"takeProfit");void 0!==g&&""!==g&&(s=this.omitZero(this.safeString(g,"takeProfit"))),void 0!==g&&"number"!=typeof g&&""!==g&&("string"==typeof g&&(g=this.parseJson(g)),s=this.omitZero(this.safeString(g,"stopPrice")));let w=this.safeStringLower2(e,"type","o"),y=this.omitZero(this.safeString2(e,"StopPrice","stopPrice")),v=y;return void 0!==y&&(w.indexOf("stop")>-1&&void 0===i&&(i=y,v=void 0),w.indexOf("take")>-1&&void 0===s&&(s=y,v=void 0)),this.safeOrder({info:a,id:this.safeStringN(e,["orderId","i","mainOrderId"]),clientOrderId:this.safeStringN(e,["clientOrderID","clientOrderId","origClientOrderId","c"]),symbol:this.safeSymbol(d,t,"-",o),timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:c,lastUpdateTimestamp:this.safeInteger(e,"updateTime"),type:this.parseOrderType(w),timeInForce:this.safeString(e,"timeInForce"),postOnly:void 0,side:this.parseOrderSide(h),price:this.safeString2(e,"price","p"),triggerPrice:v,stopLossPrice:i,takeProfitPrice:s,average:this.safeString2(e,"avgPrice","ap"),cost:this.safeString(e,"cummulativeQuoteQty"),amount:this.safeStringN(e,["origQty","q","quantity","totalAmount"]),filled:this.safeString2(e,"executedQty","z"),remaining:void 0,status:this.parseOrderStatus(p),fee:{currency:f,cost:r.Y.stringAbs(u)},trades:void 0,reduceOnly:this.safeBool2(e,"reduceOnly","ro")},t)}parseOrderStatus(e){return this.safeString({NEW:"open",PENDING:"open",PARTIALLY_FILLED:"open",RUNNING:"open",FILLED:"closed",CANCELED:"canceled",CANCELLED:"canceled",FAILED:"canceled"},e,e)}async cancelOrder(e,t,i={}){let s,r;await this.loadMarkets();let n=this.safeBool(i,"twap",!1);if(i=this.omit(i,"twap"),n)s=await this.swapV1PrivatePostTwapCancelOrder(this.extend({mainOrderId:e},i));else{let n,o;if(void 0===t)throw new a.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");let d={symbol:(r=this.market(t)).id},h=this.safeString2(i,"clientOrderId","clientOrderID");i=this.omit(i,["clientOrderId"]),void 0!==h?d.clientOrderID=h:d.orderId=e,[n,i]=this.handleMarketTypeAndParams("cancelOrder",r,i),[o,i]=this.handleSubTypeAndParams("cancelOrder",r,i),s="spot"===n?await this.spotV1PrivatePostTradeCancel(this.extend(d,i)):"inverse"===o?await this.cswapV1PrivateDeleteTradeCancelOrder(this.extend(d,i)):await this.swapV2PrivateDeleteTradeOrder(this.extend(d,i))}let o=this.safeDict(s,"data",{}),d=this.safeDict(o,"order",o);return this.parseOrder(d,r)}async cancelAllOrders(e,t={}){let i;if(void 0===e)throw new a.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();let s=this.market(e),r={symbol:s.id};if(s.spot)i=await this.spotV1PrivatePostTradeCancelOpenOrders(this.extend(r,t));else if(s.swap)i=s.inverse?await this.cswapV1PrivateDeleteTradeAllOpenOrders(this.extend(r,t)):await this.swapV2PrivateDeleteTradeAllOpenOrders(this.extend(r,t));else throw new a.BadRequest(this.id+" cancelAllOrders is only supported for spot and swap markets.");let n=this.safeDict(i,"data",{}),o=this.safeList2(n,"success","orders",[]);return this.parseOrders(o)}async cancelOrders(e,t,i={}){let s;if(void 0===t)throw new a.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();let r=this.market(t),n={symbol:r.id},o=this.safeValue(i,"clientOrderIds");i=this.omit(i,"clientOrderIds");let d=e,h=void 0!==o;h&&(d=o);let l=[];for(let e=0;e<d.length;e++){let t=d[e].toString();l.push(t)}r.spot?(n[h?"clientOrderIDs":"orderIds"]=l.join(","),s=await this.spotV1PrivatePostTradeCancelOrders(this.extend(n,i))):(h?n.clientOrderIDList=this.json(l):n.orderIdList=l,s=await this.swapV2PrivateDeleteTradeBatchOrders(this.extend(n,i)));let c=this.safeDict(s,"data",{}),p=this.safeList2(c,"success","orders",[]);return this.parseOrders(p)}async cancelAllOrdersAfter(e,t={}){let i,s;await this.loadMarkets();let r=e>0,n={type:r?"ACTIVATE":"CLOSE",timeOut:r?this.parseToInt(e/1e3):0};if([s,t]=this.handleMarketTypeAndParams("cancelAllOrdersAfter",void 0,t),"spot"===s)i=await this.spotV1PrivatePostTradeCancelAllAfter(this.extend(n,t));else if("swap"===s)i=await this.swapV2PrivatePostTradeCancelAllAfter(this.extend(n,t));else throw new a.NotSupported(this.id+" cancelAllOrdersAfter() is not supported for "+s+" markets");return i}async fetchOrder(e,t,i={}){let s,r;await this.loadMarkets();let n=this.safeBool(i,"twap",!1);if(i=this.omit(i,"twap"),n)s=await this.swapV1PrivateGetTwapOrderDetail(this.extend({mainOrderId:e},i));else{let n,o;if(void 0===t)throw new a.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");let d={symbol:(r=this.market(t)).id,orderId:e};[n,i]=this.handleMarketTypeAndParams("fetchOrder",r,i),[o,i]=this.handleSubTypeAndParams("fetchOrder",r,i),s="spot"===n?await this.spotV1PrivateGetTradeQuery(this.extend(d,i)):"inverse"===o?await this.cswapV1PrivateGetTradeOrderDetail(this.extend(d,i)):await this.swapV2PrivateGetTradeOrder(this.extend(d,i))}let o=this.safeDict(s,"data",{}),d=this.safeDict(o,"order",o);return this.parseOrder(d,r)}async fetchOrders(e,t,i,s={}){let r,n;await this.loadMarkets();let o={};if(void 0!==e&&(r=this.market(e),o.symbol=r.id),[n,s]=this.handleMarketTypeAndParams("fetchOrders",r,s),"swap"!==n)throw new a.NotSupported(this.id+" fetchOrders() is only supported for swap markets");void 0!==i&&(o.limit=i),void 0!==t&&(o.startTime=t),[o,s]=this.handleUntilOption("endTime",o,s);let d=await this.swapV1PrivateGetTradeFullOrder(this.extend(o,s)),h=this.safeDict(d,"data",{}),l=this.safeList(h,"orders",[]);return this.parseOrders(l,r,t,i)}async fetchOpenOrders(e,t,i,s={}){let a,r,n,o;await this.loadMarkets();let d={};if(void 0!==e&&(a=this.market(e),d.symbol=a.id),[r,s]=this.handleMarketTypeAndParams("fetchOpenOrders",a,s),[n,s]=this.handleSubTypeAndParams("fetchOpenOrders",a,s),"spot"===r)o=await this.spotV1PrivateGetTradeOpenOrders(this.extend(d,s));else{let e=this.safeBool(s,"twap",!1);s=this.omit(s,"twap"),o=e?await this.swapV1PrivateGetTwapOpenOrders(this.extend(d,s)):"inverse"===n?await this.cswapV1PrivateGetTradeOpenOrders(this.extend(d,s)):await this.swapV2PrivateGetTradeOpenOrders(this.extend(d,s))}let h=this.safeDict(o,"data",{}),l=this.safeList2(h,"orders","list",[]);return this.parseOrders(l,a,t,i)}async fetchClosedOrders(e,t,i,s={}){await this.loadMarkets();let a=await this.fetchCanceledAndClosedOrders(e,t,i,s);return this.filterBy(a,"status","closed")}async fetchCanceledOrders(e,t,i,s={}){await this.loadMarkets();let a=await this.fetchCanceledAndClosedOrders(e,t,i,s);return this.filterBy(a,"status","canceled")}async fetchCanceledAndClosedOrders(e,t,i,s={}){let r,n,o,d;if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();let h=this.market(e),l={symbol:h.id};if([r,s]=this.handleMarketTypeAndParams("fetchClosedOrders",h,s),[n,s]=this.handleSubTypeAndParams("fetchClosedOrders",h,s),[o,s]=this.handleOptionAndParams(s,"fetchClosedOrders","standard",!1),o)d=await this.contractV1PrivateGetAllOrders(this.extend(l,s));else if("spot"===r)void 0!==i&&(l.limit=i),d=await this.spotV1PrivateGetTradeHistoryOrders(this.extend(l,s));else{let e=this.safeBool(s,"twap",!1);if(s=this.omit(s,"twap"),e){l.pageIndex=1,l.pageSize=void 0===i?100:i,l.startTime=void 0===t?1:t;let e=this.safeInteger(s,"until",this.milliseconds());s=this.omit(s,"until"),l.endTime=e,d=await this.swapV1PrivateGetTwapHistoryOrders(this.extend(l,s))}else d="inverse"===n?await this.cswapV1PrivateGetTradeOrderHistory(this.extend(l,s)):await this.swapV2PrivateGetTradeAllOrders(this.extend(l,s))}let c=this.safeDict(d,"data",{}),p=this.safeList2(c,"orders","list",[]);return this.parseOrders(p,h,t,i)}async transfer(e,t,i,s,a={}){await this.loadMarkets();let r=this.currency(e),n=this.safeDict(this.options,"accountsByType",{}),o=this.safeString(n,i,i),d=this.safeString(n,s,s),h={asset:r.id,amount:this.currencyToPrecision(e,t),type:o+"_"+d},l=await this.spotV3PrivateGetGetAssetTransfer(this.extend(h,a));return{info:l,id:this.safeString(l,"tranId"),timestamp:void 0,datetime:void 0,currency:e,amount:t,fromAccount:i,toAccount:s,status:void 0}}async fetchTransfers(e,t,i,s={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.currency(e));let n=this.safeDict(this.options,"accountsByType",{}),o=this.safeString(s,"fromAccount"),d=this.safeString(s,"toAccount"),h=this.safeString(n,o,o),l=this.safeString(n,d,d);if(void 0===h||void 0===l)throw new a.ExchangeError(this.id+" fromAccount & toAccount parameter are required");let c={type:h+"_"+l};void 0!==t&&(c.startTime=t),void 0!==i&&(c.size=i);let p=await this.spotV3PrivateGetAssetTransfer(this.extend(c,s)),f=this.safeList(p,"rows",[]);return this.parseTransfers(f,r,t,i)}parseTransfer(e,t){let i=this.safeString(e,"tranId"),s=this.safeInteger(e,"timestamp"),a=this.safeCurrencyCode(void 0,t),r=this.safeString(e,"status"),n=this.safeDict(this.options,"accountsById",{}),o=this.safeString(e,"type"),d=o.split("_"),h=this.safeString(d,0),l=this.safeString(o,1),c=this.safeString(n,h,h),p=this.safeString(n,l,l);return{info:e,id:i,timestamp:s,datetime:this.iso8601(s),currency:a,amount:this.safeNumber(e,"amount"),fromAccount:c,toAccount:p,status:r}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();let i=this.currency(e),s=this.safeInteger(this.options,"recvWindow"),a=this.safeInteger(this.parseParams,"recvWindow",s),r={coin:i.id,offset:0,limit:1e3,recvWindow:a},n=await this.walletsV1PrivateGetCapitalDepositAddress(this.extend(r,t)),o=this.safeList(this.safeDict(n,"data"),"data"),d=this.parseDepositAddresses(o,[i.code],!1);return this.indexBy(d,"network")}async fetchDepositAddress(e,t={}){let i=this.safeString(t,"network");t=this.omit(t,["network"]);let s=await this.fetchDepositAddressesByNetwork(e,t);if(void 0!==i)return this.safeDict(s,i);{let t=this.safeDict(this.options,"defaultNetworks"),i=this.safeString(t,e);if(void 0!==i)return this.safeDict(s,i);{let e=Object.keys(s),t=this.safeString(e,0);return this.safeDict(s,t)}}}parseDepositAddress(e,t){let i=this.safeString(e,"tag"),s=this.safeString(e,"coin"),a=(t=this.safeCurrency(s,t)).code,r=this.safeString(e,"addressWithPrefix"),n=this.safeString(e,"network"),o=this.networkIdToCode(n,a);return this.checkAddress(r),{info:e,currency:a,network:o,address:r,tag:i}}async fetchDeposits(e,t,i,s={}){let a;await this.loadMarkets();let r={};void 0!==e&&(a=this.currency(e),r.coin=a.id),void 0!==t&&(r.startTime=t),void 0!==i&&(r.limit=i);let n=await this.spotV3PrivateGetCapitalDepositHisrec(this.extend(r,s));return this.parseTransactions(n,a,t,i)}async fetchWithdrawals(e,t,i,s={}){let a;await this.loadMarkets();let r={};void 0!==e&&(a=this.currency(e),r.coin=a.id),void 0!==t&&(r.startTime=t),void 0!==i&&(r.limit=i);let n=await this.spotV3PrivateGetCapitalWithdrawHistory(this.extend(r,s));return this.parseTransactions(n,a,t,i)}parseTransaction(e,t){let i=this.safeValue(e,"data"),s=void 0===i?void 0:this.safeString(i,"id"),a=this.safeString(e,"id",s),r=this.safeString(e,"address"),n=this.safeString(e,"addressTag"),o=this.safeInteger(e,"insertTime"),d=this.iso8601(o);void 0===o&&(d=this.safeString(e,"applyTime"),o=this.parse8601(d));let h=this.safeString(e,"network"),l=this.safeString(e,"coin"),c=this.safeCurrencyCode(l,t);void 0!==c&&c!==h&&c.indexOf(h)>=0&&void 0!==h&&(c=c.replace(h,""));let p=this.safeString(e,"transferType");return{info:e,id:a,txid:this.safeString(e,"txId"),type:"0"===p?"deposit":"withdrawal",currency:c,network:this.networkIdToCode(h),amount:this.safeNumber(e,"amount"),status:this.parseTransactionStatus(this.safeString(e,"status")),timestamp:o,datetime:d,address:r,addressFrom:void 0,addressTo:r,tag:n,tagFrom:n,tagTo:void 0,updated:void 0,comment:this.safeString(e,"info"),fee:{currency:c,cost:this.safeNumber(e,"transactionFee"),rate:void 0},internal:void 0}}parseTransactionStatus(e){return this.safeString({0:"pending",1:"ok",10:"pending",20:"rejected",30:"ok",40:"rejected",50:"ok",60:"pending",70:"rejected",2:"pending",3:"rejected",4:"pending",5:"rejected",6:"ok"},e,e)}async setMarginMode(e,t,i={}){let s;if(void 0===t)throw new a.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");await this.loadMarkets();let r=this.market(t);if("swap"!==r.type)throw new a.BadSymbol(this.id+" setMarginMode() supports swap contracts only");if("CROSS"===(e=e.toUpperCase())&&(e="CROSSED"),"ISOLATED"!==e&&"CROSSED"!==e)throw new a.BadRequest(this.id+" setMarginMode() marginMode argument should be isolated or cross");let n={symbol:r.id,marginType:e};return([s,i]=this.handleSubTypeAndParams("setMarginMode",r,i),"inverse"===s)?await this.cswapV1PrivatePostTradeMarginType(this.extend(n,i)):await this.swapV2PrivatePostTradeMarginType(this.extend(n,i))}async addMargin(e,t,i={}){return await this.setMargin(e,t,this.extend({type:1},i))}async reduceMargin(e,t,i={}){return await this.setMargin(e,t,this.extend({type:2},i))}async setMargin(e,t,i={}){let s=this.safeInteger(i,"type");if(void 0===s||!this.inArray(s,[1,2]))throw new a.ArgumentsRequired(this.id+" setMargin() requires a type parameter either 1 (increase margin) or 2 (decrease margin)");await this.loadMarkets();let r=this.market(e),n={symbol:r.id,amount:this.amountToPrecision(r.symbol,t),type:s},o=await this.swapV2PrivatePostTradePositionMargin(this.extend(n,i));return this.parseMarginModification(o,r)}parseMarginModification(e,t){let i=this.safeString(e,"type");return{info:e,symbol:this.safeString(t,"symbol"),type:"1"===i?"add":"reduce",marginMode:"isolated",amount:this.safeNumber(e,"amount"),total:this.safeNumber(e,"margin"),code:this.safeString(t,"settle"),status:void 0,timestamp:void 0,datetime:void 0}}async fetchLeverage(e,t={}){let i;await this.loadMarkets();let s=this.market(e),a={symbol:s.id};i=s.inverse?await this.cswapV1PrivateGetTradeLeverage(this.extend(a,t)):await this.swapV2PrivateGetTradeLeverage(this.extend(a,t));let r=this.safeDict(i,"data",{});return this.parseLeverage(r,s)}parseLeverage(e,t){let i=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(i,t),marginMode:void 0,longLeverage:this.safeInteger(e,"longLeverage"),shortLeverage:this.safeInteger(e,"shortLeverage")}}async setLeverage(e,t,i={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");let s=this.safeStringUpper(i,"side");this.checkRequiredArgument("setLeverage",s,"side",["LONG","SHORT","BOTH"]),await this.loadMarkets();let r=this.market(t),n={symbol:r.id,side:s,leverage:e};return r.inverse?await this.cswapV1PrivatePostTradeLeverage(this.extend(n,i)):await this.swapV2PrivatePostTradeLeverage(this.extend(n,i))}async fetchMyTrades(e,t,i,s={}){let r,n,o;if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();let d=this.market(e),h={};if([o,s]=this.handleSubTypeAndParams("fetchMyTrades",d,s),"inverse"===o){if(void 0===this.safeString(s,"orderId"))throw new a.ArgumentsRequired(this.id+" fetchMyTrades() requires an orderId argument for inverse swap trades");n=await this.cswapV1PrivateGetTradeAllFillOrders(this.extend(h,s)),r=this.safeList(n,"data",[])}else{h.symbol=d.id;let e=this.milliseconds();void 0!==t?h[d.spot?"startTime":"startTs"]=t:d.swap&&(h.startTs=e-2592e6);let a=this.safeInteger(s,"until");if(s=this.omit(s,"until"),void 0!==a?h[d.spot?"endTime":"endTs"]=a:d.swap&&(h.endTs=e),d.spot){void 0!==i&&(h.limit=i),n=await this.spotV1PrivateGetTradeMyTrades(this.extend(h,s));let e=this.safeDict(n,"data",{});r=this.safeList(e,"fills",[])}else{let e=this.safeStringUpper(s,"tradingUnit","CONT");s=this.omit(s,"tradingUnit"),h.tradingUnit=e,n=await this.swapV2PrivateGetTradeAllFillOrders(this.extend(h,s));let t=this.safeDict(n,"data",{});r=this.safeList(t,"fill_orders",[])}}return this.parseTrades(r,d,t,i,s)}parseDepositWithdrawFee(e,t){let i=this.safeList(e,"networkList",[]),s=i.length,a={info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}};if(0!==s)for(let e=0;e<s;e++){let s=i[e],r=this.safeString(s,"network"),n=this.safeBool(s,"isDefault"),o=this.safeString(t,"code"),d=this.networkIdToCode(r,o);a.networks[d]={deposit:{fee:void 0,percentage:void 0},withdraw:{fee:this.safeNumber(s,"withdrawFee"),percentage:!1}},n&&(a.withdraw.fee=this.safeNumber(s,"withdrawFee"),a.withdraw.percentage=!1)}return a}async fetchDepositWithdrawFees(e,t={}){await this.loadMarkets();let i=await this.walletsV1PrivateGetCapitalConfigGetall(t),s=this.safeList(i,"data");return this.parseDepositWithdrawFees(s,e,"coin")}async withdraw(e,t,i,s,r={}){[s,r]=this.handleWithdrawTagAndParams(s,r),this.checkAddress(i),await this.loadMarkets();let n=this.currency(e),o=this.safeInteger(r,"walletType");if(void 0===o&&(o=1),!this.inArray(o,[1,2,3]))throw new a.BadRequest(this.id+" withdraw() requires either 1 fund account, 2 standard futures account, 3 perpetual account for walletType");let d={coin:n.id,address:i,amount:this.numberToString(t),walletType:o},h=this.safeStringUpper(r,"network");void 0!==h&&(d.network=this.networkCodeToId(h)),void 0!==s&&(d.addressTag=s),r=this.omit(r,["walletType","network"]);let l=await this.walletsV1PrivatePostCapitalWithdrawApply(this.extend(d,r)),c=this.safeValue(l,"data");return this.parseTransaction(c)}parseParams(e){let t=this.keysort(e),i=Object.keys(t);for(let e=0;e<i.length;e++){let s=i[e],a=t[s];if(Array.isArray(a)){let e="[";for(let t=0;t<a.length;t++){let i=a[t];t>0&&(e+=","),e+=i.toString()}e+="]",t[s]=e}}return t}async fetchMyLiquidations(e,t,i,s={}){let a,r,n,o;await this.loadMarkets();let d={autoCloseType:"LIQUIDATION"};if([d,s]=this.handleUntilOption("endTime",d,s),void 0!==e&&(a=this.market(e),d.symbol=a.id),void 0!==t&&(d.startTime=t),void 0!==i&&(d.limit=i),[r,s]=this.handleSubTypeAndParams("fetchMyLiquidations",a,s),"inverse"===r)n=await this.cswapV1PrivateGetTradeForceOrders(this.extend(d,s)),o=this.safeList(n,"data",[]);else{n=await this.swapV2PrivateGetTradeForceOrders(this.extend(d,s));let e=this.safeDict(n,"data",{});o=this.safeList(e,"orders",[])}return this.parseLiquidations(o,a,t,i)}parseLiquidation(e,t){let i=this.safeString(e,"symbol"),s=this.safeInteger(e,"time"),a=this.safeString(e,"executedQty"),n=this.safeString(t,"contractSize"),o=this.safeString(e,"avgPrice"),d=r.Y.stringMul(a,n),h=r.Y.stringMul(d,o);return this.safeLiquidation({info:e,symbol:this.safeSymbol(i,t),contracts:this.parseNumber(a),contractSize:this.parseNumber(n),price:this.parseNumber(o),baseValue:this.parseNumber(d),quoteValue:this.parseNumber(h),timestamp:s,datetime:this.iso8601(s)})}async closePosition(e,t,i={}){let s;await this.loadMarkets();let a=this.market(e),r=this.safeString(i,"positionId"),n={};void 0!==r?s=await this.swapV1PrivatePostTradeClosePosition(this.extend(n,i)):(n.symbol=a.id,s=a.inverse?await this.cswapV1PrivatePostTradeCloseAllPositions(this.extend(n,i)):await this.swapV2PrivatePostTradeCloseAllPositions(this.extend(n,i)));let o=this.safeDict(s,"data");return this.parseOrder(o,a)}async closeAllPositions(e={}){let t,i,s;await this.loadMarkets();let r=this.safeInteger(this.options,"recvWindow"),n=this.safeInteger(this.parseParams,"recvWindow",r);if([t,e]=this.handleMarketTypeAndParams("closeAllPositions",void 0,e),[i,e]=this.handleSubTypeAndParams("closeAllPositions",void 0,e),"margin"===t)throw new a.BadRequest(this.id+" closePositions () cannot be used for "+t+" markets");let o={recvWindow:n};s="inverse"===i?await this.cswapV1PrivatePostTradeCloseAllPositions(this.extend(o,e)):await this.swapV2PrivatePostTradeCloseAllPositions(this.extend(o,e));let d=this.safeDict(s,"data",{}),h=this.safeList(d,"success",[]),l=[];for(let e=0;e<h.length;e++){let t=this.parsePosition({positionId:h[e]});l.push(t)}return l}async fetchPositionMode(e,t={}){let i=await this.swapV1PrivateGetPositionSideDual(t),s=this.safeDict(i,"data",{});return{info:i,hedged:"true"===this.safeString(s,"dualSidePosition")}}async setPositionMode(e,t,i={}){return await this.swapV1PrivatePostPositionSideDual(this.extend({dualSidePosition:e?"true":"false"},i))}async editOrder(e,t,i,s,a,r,n={}){let o;await this.loadMarkets();let d=this.market(t),h=this.createOrderRequest(t,i,s,a,r,n);h.cancelOrderId=e,h.cancelReplaceMode="STOP_ON_FAILURE",o=d.swap?await this.swapV1PrivatePostTradeCancelReplace(this.extend(h,n)):await this.spotV1PrivatePostTradeOrderCancelReplace(this.extend(h,n));let l=this.safeDict(o,"data");return this.parseOrder(l,d)}async fetchMarginMode(e,t={}){let i,s;await this.loadMarkets();let a=this.market(e),r={symbol:a.id};[i,t]=this.handleSubTypeAndParams("fetchMarginMode",a,t),s="inverse"===i?await this.cswapV1PrivateGetTradeMarginType(this.extend(r,t)):await this.swapV2PrivateGetTradeMarginType(this.extend(r,t));let n=this.safeDict(s,"data",{});return this.parseMarginMode(n,a)}parseMarginMode(e,t){let i=this.safeString(e,"symbol"),s=this.safeStringLower(e,"marginType");return s="crossed"===s?"cross":s,{info:e,symbol:this.safeSymbol(i,t,"-","swap"),marginMode:s}}async fetchTradingFee(e,t={}){let i;await this.loadMarkets();let s=this.market(e),a={symbol:s.id},r={},n=this.safeDict(i,"data",{});return s.spot?(i=await this.spotV1PrivateGetUserCommissionRate(this.extend(a,t)),r=n):s.inverse?(i=await this.cswapV1PrivateGetUserCommissionRate(t),r=n):(i=await this.swapV2PrivateGetUserCommissionRate(t),r=this.safeDict(n,"commission",{})),this.parseTradingFee(r,s)}parseTradingFee(e,t){return{info:e,symbol:void 0!==t?t.symbol:void 0,maker:this.safeNumber(e,"makerCommissionRate"),taker:this.safeNumber(e,"takerCommissionRate"),percentage:!1,tierBased:!1}}sign(e,t="public",i="GET",s={},r,o){let d=t[0],h=t[1],l=t[2];if(this.safeBool(this.options,"sandboxMode",!1)&&"swap"!==d)throw new a.NotSupported(this.id+" does not have a testnet/sandbox URL for "+d+" endpoints");let c=this.implodeHostname(this.urls.api[d]);if(e=this.implodeParams(e,s),"transfer"===h&&(d="account/transfer",h=t[2],l=t[3]),"account/apiPermissions"!==e&&("spot"===d&&"v3"===h?c+="/api":c+="/"+d),c+="/"+h+"/"+e,(s=this.omit(s,this.extractParams(e))).timestamp=this.nonce(),s=this.keysort(s),"public"===l)Object.keys(s).length&&(c+="?"+this.urlencode(s));else if("private"===l){this.checkRequiredCredentials();let e=("subAccount"===d||"account/transfer"===d)&&"POST"===i,t=this.parseParams(s),a=this.hmac(this.encode(this.rawencode(t)),this.encode(this.secret),n.s);r={"X-BX-APIKEY":this.apiKey,"X-SOURCE-KEY":this.safeString(this.options,"broker","CCXT")},e?(r["Content-Type"]="application/json",t.signature=a,o=this.json(t)):c+="?"+this.urlencode(t)+"&signature="+a}return{url:c,method:i,body:o,headers:r}}nonce(){return this.milliseconds()}setSandboxMode(e){super.setSandboxMode(e),this.options.sandboxMode=e}handleErrors(e,t,i,s,r,n,o,d,h){if(void 0===o)return;let l=this.safeString(o,"code"),c=this.safeString(o,"msg");if(void 0!==l&&"0"!==l){let e=this.id+" "+n;throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwExactlyMatchedException(this.exceptions.exact,l,e),this.throwBroadlyMatchedException(this.exceptions.broad,c,e),new a.ExchangeError(e)}}}}}]);