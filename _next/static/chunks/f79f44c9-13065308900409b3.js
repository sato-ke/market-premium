"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[419],{937:(t,e,i)=>{i.d(e,{k:()=>eo});var s=i(7411),r=i(8119),o=i(6077),a=i(2074),n=i(5979),h=i(328),d=i(8715),c=i(9378),p=i(7330),l=i(329),u=i(1150),f=i(7233),y=i(5287),m=i(5714).Buffer;let{isNode:w,selfIsDefined:g,deepExtend:v,extend:S,clone:b,flatten:k,unique:O,indexBy:N,sortBy:P,sortBy2:x,safeFloat2:T,groupBy:A,aggregate:M,uuid:L,unCamelCase:C,precisionFromString:B,Throttler:W,capitalize:I,now:R,decimalToPrecision:F,safeValue:D,safeValue2:E,safeString:q,safeString2:_,seconds:V,milliseconds:H,binaryToBase16:j,numberToBE:U,base16ToBinary:Y,iso8601:G,omit:Z,isJsonEncodedObject:z,safeInteger:J,sum:K,omitZero:X,implodeParams:$,extractParams:Q,json:tt,merge:te,binaryConcat:ti,hash:ts,ecdsa:tr,arrayConcat:to,encode:ta,urlencode:tn,hmac:th,numberToString:td,roundTimeframe:tc,parseTimeframe:tp,safeInteger2:tl,safeStringLower:tu,parse8601:tf,yyyymmdd:ty,safeStringUpper:tm,safeTimestamp:tw,binaryConcatArray:tg,uuidv1:tv,numberToLE:tS,ymdhms:tb,stringToBase64:tk,decode:tO,uuid22:tN,safeIntegerProduct2:tP,safeIntegerProduct:tx,safeStringLower2:tT,yymmdd:tA,base58ToBinary:tM,binaryToBase58:tL,safeTimestamp2:tC,rawencode:tB,keysort:tW,inArray:tI,isEmpty:tR,ordered:tF,filterBy:tD,uuid16:tE,safeFloat:tq,base64ToBinary:t_,safeStringUpper2:tV,urlencodeWithArrayRepeat:tH,microseconds:tj,binaryToBase64:tU,strip:tY,toArray:tG,safeFloatN:tZ,safeIntegerN:tz,safeIntegerProductN:tJ,safeTimestampN:tK,safeValueN:tX,safeStringN:t$,safeStringLowerN:tQ,safeStringUpperN:t0,urlencodeNested:t1,urlencodeBase64:t2,parseDate:t3,ymd:t4,base64ToString:t5,crc32:t6,packb:t7,TRUNCATE:t8,ROUND:t9,DECIMAL_PLACES:et,NO_PADDING:ee,TICK_SIZE:ei,SIGNIFICANT_DIGITS:es,sleep:er}=s;class eo{constructor(t={}){this.isSandboxModeEnabled=!1,this.throttleProp=void 0,this.sleep=er,this.api=void 0,this.certified=!1,this.pro=!1,this.countries=void 0,this.userAgent=void 0,this.user_agent=void 0,this.userAgents={chrome:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",chrome39:"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36",chrome100:"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36"},this.headers={},this.origin="*",this.agent=void 0,this.nodeHttpModuleLoaded=!1,this.httpAgent=void 0,this.httpsAgent=void 0,this.minFundingAddressLength=1,this.substituteCommonCurrencyCodes=!0,this.quoteJsonNumbers=!0,this.number=Number,this.handleContentTypeApplicationZip=!1,this.reduceFees=!0,this.validateServerSsl=!0,this.validateClientSsl=!1,this.timeout=1e4,this.verbose=!1,this.twofa=void 0,this.balance={},this.liquidations={},this.orderbooks={},this.tickers={},this.fundingRates={},this.bidsasks={},this.orders=void 0,this.triggerOrders=void 0,this.transactions={},this.myLiquidations={},this.requiresWeb3=!1,this.requiresEddsa=!1,this.precision=void 0,this.enableLastJsonResponse=!1,this.enableLastHttpResponse=!0,this.enableLastResponseHeaders=!0,this.last_http_response=void 0,this.last_json_response=void 0,this.last_response_headers=void 0,this.last_request_headers=void 0,this.last_request_body=void 0,this.last_request_url=void 0,this.last_request_path=void 0,this.id="Exchange",this.markets=void 0,this.features=void 0,this.status=void 0,this.rateLimit=void 0,this.tokenBucket=void 0,this.throttler=void 0,this.enableRateLimit=void 0,this.httpExceptions=void 0,this.limits=void 0,this.markets_by_id=void 0,this.symbols=void 0,this.ids=void 0,this.currencies={},this.baseCurrencies=void 0,this.quoteCurrencies=void 0,this.currencies_by_id=void 0,this.codes=void 0,this.reloadingMarkets=void 0,this.marketsLoading=void 0,this.accounts=void 0,this.accountsById=void 0,this.commonCurrencies=void 0,this.hostname=void 0,this.precisionMode=void 0,this.paddingMode=void 0,this.exceptions={},this.timeframes={},this.version=void 0,this.marketsByAltname=void 0,this.name=void 0,this.targetAccount=void 0,this.stablePairs={},this.clients={},this.newUpdates=!0,this.streaming={},this.alias=!1,this.deepExtend=v,this.isNode=w,this.keys=s.keys,this.values=s.values,this.extend=S,this.clone=b,this.flatten=k,this.unique=O,this.indexBy=N,this.roundTimeframe=tc,this.sortBy=P,this.sortBy2=x,this.groupBy=A,this.aggregate=M,this.uuid=L,this.unCamelCase=C,this.precisionFromString=B,this.capitalize=I,this.now=R,this.decimalToPrecision=F,this.safeValue=D,this.safeValue2=E,this.safeString=q,this.safeString2=_,this.safeFloat=tq,this.safeFloat2=T,this.seconds=V,this.milliseconds=H,this.binaryToBase16=j,this.numberToBE=U,this.base16ToBinary=Y,this.iso8601=G,this.omit=Z,this.isJsonEncodedObject=z,this.safeInteger=J,this.sum=K,this.omitZero=X,this.implodeParams=$,this.extractParams=Q,this.json=tt,this.vwap=s.vwap,this.merge=te,this.binaryConcat=ti,this.hash=ts,this.arrayConcat=to,this.encode=ta,this.urlencode=tn,this.hmac=th,this.numberToString=td,this.parseTimeframe=tp,this.safeInteger2=tl,this.safeStringLower=tu,this.parse8601=tf,this.yyyymmdd=ty,this.safeStringUpper=tm,this.safeTimestamp=tw,this.binaryConcatArray=tg,this.uuidv1=tv,this.numberToLE=tS,this.ymdhms=tb,this.yymmdd=tA,this.stringToBase64=tk,this.decode=tO,this.uuid22=tN,this.safeIntegerProduct2=tP,this.safeIntegerProduct=tx,this.binaryToBase58=tL,this.base58ToBinary=tM,this.base64ToBinary=t_,this.safeTimestamp2=tC,this.rawencode=tB,this.keysort=tW,this.inArray=tI,this.safeStringLower2=tT,this.safeStringUpper2=tV,this.isEmpty=tR,this.ordered=tF,this.filterBy=tD,this.uuid16=tE,this.urlencodeWithArrayRepeat=tH,this.microseconds=tj,this.binaryToBase64=tU,this.strip=tY,this.toArray=tG,this.safeFloatN=tZ,this.safeIntegerN=tz,this.safeIntegerProductN=tJ,this.safeTimestampN=tK,this.safeValueN=tX,this.safeStringN=t$,this.safeStringLowerN=tQ,this.safeStringUpperN=t0,this.urlencodeNested=t1,this.parseDate=t3,this.ymd=t4,this.base64ToString=t5,this.crc32=t6,this.packb=t7,this.urlencodeBase64=t2,this.httpProxyAgentModule=void 0,this.httpsProxyAgentModule=void 0,this.socksProxyAgentModule=void 0,this.socksProxyAgentModuleChecked=!1,this.proxyDictionaries={},this.proxiesModulesLoading=void 0,Object.assign(this,s),this.options=this.getDefaultOptions(),this.headers={},this.origin="*",this.minFundingAddressLength=1,this.substituteCommonCurrencyCodes=!0,this.quoteJsonNumbers=!0,this.number=Number,this.handleContentTypeApplicationZip=!1,this.reduceFees=!0,this.fetchImplementation=void 0,this.validateServerSsl=!0,this.validateClientSsl=!1,this.timeout=1e4,this.verbose=!1,this.twofa=void 0,this.apiKey=void 0,this.secret=void 0,this.uid=void 0,this.login=void 0,this.password=void 0,this.privateKey=void 0,this.walletAddress=void 0,this.token=void 0,this.balance={},this.orderbooks={},this.tickers={},this.liquidations={},this.orders=void 0,this.trades={},this.transactions={},this.ohlcvs={},this.myLiquidations={},this.myTrades=void 0,this.positions=void 0,this.requiresWeb3=!1,this.requiresEddsa=!1,this.lastRestRequestTimestamp=0,this.enableLastJsonResponse=!0,this.enableLastHttpResponse=!0,this.enableLastResponseHeaders=!0,this.last_http_response=void 0,this.last_json_response=void 0,this.last_response_headers=void 0,this.last_request_headers=void 0,this.last_request_body=void 0,this.last_request_url=void 0,this.last_request_path=void 0;let e=(t=this)=>{if(null!==t){let i=Object.getOwnPropertyNames(t);for(let t=0;t<i.length;t++){let e=i[t];this[C(e)]=this[e]}e(Object.getPrototypeOf(t))}};e();let i=Object.entries(this.describe()).concat(Object.entries(t));for(let t=0;t<i.length;t++){let[e,s]=i[t];s&&Object.getPrototypeOf(s)===Object.prototype?this[e]=this.deepExtend(this[e],s):this[e]=s}this.validateServerSsl;let r=Object.keys(this.has);for(let t=0;t<r.length;t++){let e=r[t];this["has"+this.capitalize(e)]=!!this.has[e]}this.api&&this.defineRestApi(this.api,"request"),this.initRestRateLimiter(),this.markets&&this.setMarkets(this.markets),this.newUpdates=void 0===this.options.newUpdates||this.options.newUpdates,this.afterConstruct();let o=this.safeBool2(this.options,"sandbox","testnet",!1);o&&this.setSandboxMode(o)}encodeURIComponent(...t){return encodeURIComponent(...t)}checkRequiredVersion(t,e=!0){let i=!0,[s,o,a]=t.split("."),[n,h,d]=eo.ccxtVersion.split("."),c=this.parseToInt(s),p=this.parseToInt(o),l=this.parseToInt(a),u=this.parseToInt(n),f=this.parseToInt(h),y=this.parseToInt(d);if(c>u&&(i=!1),c===u&&(p>f?i=!1:p===f&&l>y&&(i=!1)),!i){if(!e)return e;throw new r.NotSupported("Your current version of CCXT is "+eo.ccxtVersion+", a newer version "+t+" is required, please, upgrade your version of CCXT")}return i}initRestRateLimiter(){if(void 0===this.rateLimit)throw Error(this.id+".rateLimit property is not configured");this.tokenBucket=this.extend({delay:.001,capacity:1,cost:1,maxCapacity:1e3,refillRate:this.rateLimit>0?1/this.rateLimit:Number.MAX_VALUE},this.tokenBucket),this.throttler=new W(this.tokenBucket)}throttle(t){return this.throttler.throttle(t)}defineRestApiEndpoint(t,e,i,s,r,o,a={}){let n=r.split(/[^a-zA-Z0-9]/),h=n.map(this.capitalize).join(""),d=n.map(t=>t.trim().toLowerCase()).filter(t=>t.length>0).join("_"),c=[o[0]].concat(o.slice(1).map(this.capitalize)).join(""),p=[o[0]].concat(o.slice(1).map(t=>t.trim()).filter(t=>t.length>0)).join("_"),l=c+s+this.capitalize(h),u=o.length>1?o:o[0],f=async(i={},s={})=>this[t](r,u,e,i,void 0,void 0,a,s);this[l]=f,this[p+"_"+i+"_"+d]=f}defineRestApi(t,e,i=[]){let s=Object.keys(t);for(let o=0;o<s.length;o++){let a=s[o],n=t[a],h=a.toUpperCase(),d=a.toLowerCase(),c=this.capitalize(d);if(Array.isArray(n))for(let t=0;t<n.length;t++){let s=n[t].trim();this.defineRestApiEndpoint(e,h,d,c,s,i)}else if(a.match(/^(?:get|post|put|delete|head|patch)$/i)){let t=Object.keys(n);for(let s=0;s<t.length;s++){let o=t[s],a=o.trim(),p=n[o];if("object"==typeof p)this.defineRestApiEndpoint(e,h,d,c,a,i,p);else if("number"==typeof p)this.defineRestApiEndpoint(e,h,d,c,a,i,{cost:p});else throw new r.NotSupported(this.id+" defineRestApi() API format is not supported, API leafs must strings, objects or numbers")}}else this.defineRestApi(n,e,i.concat([a]))}}log(...t){console.log(...t)}async loadProxyModules(){return void 0===this.proxiesModulesLoading&&(this.proxiesModulesLoading=(async()=>{try{this.httpProxyAgentModule=await import("../static_dependencies/proxies/http-proxy-agent/index.js"),this.httpsProxyAgentModule=await import("../static_dependencies/proxies/https-proxy-agent/index.js")}catch(t){try{this.httpProxyAgentModule=await import("http-proxy-agent"),this.httpsProxyAgentModule=await import("https-proxy-agent")}catch(t){}}if(!1===this.socksProxyAgentModuleChecked){try{this.socksProxyAgentModule=await import("socks-proxy-agent")}catch(t){}this.socksProxyAgentModuleChecked=!0}})()),await this.proxiesModulesLoading}setProxyAgents(t,e,i){let s;if(!w&&(t||e||i))throw new r.NotSupported(this.id+' - proxies in browser-side projects are not supported. You have several choices: [A] Use `exchange.proxyUrl` property to redirect requests through local/remote cors-proxy server (find sample file named "sample-local-proxy-server-with-cors" in https://github.com/ccxt/ccxt/tree/master/examples/ folder, which can be used for REST requests only) [B] override `exchange.fetch` && `exchange.watch` methods to send requests through your custom proxy');if(t){if(void 0===this.httpProxyAgentModule)throw new r.NotSupported(this.id+" you need to load JS proxy modules with `.loadProxyModules()` method at first to use proxies");t in this.proxyDictionaries||(this.proxyDictionaries[t]=new this.httpProxyAgentModule.HttpProxyAgent(t)),s=this.proxyDictionaries[t]}else if(e){if(void 0===this.httpsProxyAgentModule)throw new r.NotSupported(this.id+" you need to load JS proxy modules with `.loadProxyModules()` method at first to use proxies");e in this.proxyDictionaries||(this.proxyDictionaries[e]=new this.httpsProxyAgentModule.HttpsProxyAgent(e)),(s=this.proxyDictionaries[e]).keepAlive=!0}else if(i){if(void 0===this.socksProxyAgentModule)throw new r.NotSupported(this.id+' - to use SOCKS proxy with ccxt, at first you need install module "npm i socks-proxy-agent" and then initialize proxies with `.loadProxyModules()` method');i in this.proxyDictionaries||(this.proxyDictionaries[i]=new this.socksProxyAgentModule.SocksProxyAgent(i)),s=this.proxyDictionaries[i]}return s}async loadHttpProxyAgent(){if(!this.httpAgent){let t=await import("node:http");this.httpAgent=new t.Agent}return this.httpAgent}getHttpAgentIfNeeded(t){if(w&&"ws://"===t.substring(0,5)){if(void 0===this.httpAgent)throw new r.NotSupported(this.id+" to use proxy with non-ssl ws:// urls, at first run  `await exchange.loadHttpProxyAgent()` method");return this.httpAgent}}async fetch(t,e="GET",i,s){if(w&&!this.nodeHttpModuleLoaded){this.nodeHttpModuleLoaded=!0;let t=await import("node:https");this.httpsAgent=new t.Agent({keepAlive:!0})}i=this.extend(this.headers,i);let o=this.checkProxyUrlSettings(t,e,i,s),a=!1;void 0!==o&&(w&&(i=this.extend({Origin:this.origin},i),"http:"===o.substring(0,5)&&(await this.loadHttpProxyAgent(),a=this.httpAgent)),t=o+t);let[n,h,d]=this.checkProxySettings(t,e,i,s);this.checkConflictingProxies(n||h||d,o),w&&await this.loadProxyModules();let c=this.setProxyAgents(n,h,d),p=void 0!==this.userAgent?this.userAgent:this.user_agent;if(p&&w&&("string"==typeof p?i=this.extend({"User-Agent":p},i):"object"==typeof p&&"User-Agent"in p&&(i=this.extend(p,i))),i=this.setHeaders(i),this.verbose&&this.log("fetch Request:\n",this.id,e,t,"\nRequestHeaders:\n",i,"\nRequestBody:\n",s,"\n"),void 0===this.fetchImplementation){if(w){void 0===this.agent&&(this.agent=this.httpsAgent);try{let t=await import("../static_dependencies/node-fetch/index.js");this.AbortError=t.AbortError,this.fetchImplementation=t.default,this.FetchError=t.FetchError}catch(t){if("function"==typeof fetch)this.fetchImplementation=fetch,this.AbortError=DOMException,this.FetchError=TypeError;else throw Error('Seems, "fetch" function is not available in your node-js version, please use latest node-js version')}}else this.fetchImplementation=g()?self.fetch:fetch,this.AbortError=DOMException,this.FetchError=TypeError}let l=this.fetchImplementation,u={method:e,headers:i,body:s,timeout:this.timeout};this.agent&&(u.agent=this.agent),a?u.agent=a:c&&(u.agent=c);let f=new AbortController;u.signal=f.signal;let y=setTimeout(()=>{f.abort()},this.timeout);try{let r=await l(t,u);return clearTimeout(y),this.handleRestResponse(r,t,e,i,s)}catch(i){if(i instanceof this.AbortError)throw new r.RequestTimeout(this.id+" "+e+" "+t+" request timed out ("+this.timeout+" ms)");if(i instanceof this.FetchError)throw new r.NetworkError(this.id+" "+e+" "+t+" fetch failed");throw i}}parseJson(t){try{if(this.isJsonEncodedObject(t))return JSON.parse(this.onJsonResponse(t))}catch(t){return}}getResponseHeaders(t){let e={};return t.headers.forEach((t,i)=>{e[i=i.split("-").map(t=>this.capitalize(t)).join("-")]=t}),e}handleRestResponse(t,e,i="GET",s,r){let o=this.getResponseHeaders(t);if(this.handleContentTypeApplicationZip&&"application/zip"===o["Content-Type"]){let s=t.buffer();return this.enableLastResponseHeaders&&(this.last_response_headers=o),this.enableLastHttpResponse&&(this.last_http_response=s),this.verbose&&this.log("handleRestResponse:\n",this.id,i,e,t.status,t.statusText,"\nResponseHeaders:\n",o,"ZIP redacted","\n"),s}return t.text().then(a=>{let n=this.onRestResponse(t.status,t.statusText,e,i,o,a,s,r),h=this.parseJson(n);return this.enableLastResponseHeaders&&(this.last_response_headers=o),this.enableLastHttpResponse&&(this.last_http_response=a),this.enableLastJsonResponse&&(this.last_json_response=h),this.verbose&&this.log("handleRestResponse:\n",this.id,i,e,t.status,t.statusText,"\nResponseHeaders:\n",o,"\nResponseBody:\n",a,"\n"),this.handleErrors(t.status,t.statusText,e,i,o,a,h,s,r)||this.handleHttpStatusCode(t.status,t.statusText,e,i,a),h||a})}onRestResponse(t,e,i,s,r,o,a,n){return o.trim()}onJsonResponse(t){return this.quoteJsonNumbers?t.replace(/":([+.0-9eE-]+)([,}])/g,'":"$1"$2'):t}async loadMarketsHelper(t=!1,e={}){let i;if(!t&&this.markets)return this.markets_by_id?this.markets:this.setMarkets(this.markets);!0===this.has.fetchCurrencies&&(i=await this.fetchCurrencies());let s=await this.fetchMarkets(e);return this.setMarkets(s,i)}async loadMarkets(t=!1,e={}){return(!t||this.reloadingMarkets)&&this.marketsLoading||(this.reloadingMarkets=!0,this.marketsLoading=this.loadMarketsHelper(t,e).then(t=>(this.reloadingMarkets=!1,t),t=>{throw this.reloadingMarkets=!1,t})),this.marketsLoading}async fetchCurrencies(t={}){return new Promise((t,e)=>t(this.currencies))}async fetchCurrenciesWs(t={}){return new Promise((t,e)=>t(this.currencies))}async fetchMarkets(t={}){return new Promise((t,e)=>t(Object.values(this.markets)))}async fetchMarketsWs(t={}){return new Promise((t,e)=>t(Object.values(this.markets)))}checkRequiredDependencies(){}parseNumber(t,e){if(void 0===t)return e;try{let e=this.numberToString(t);if(e.indexOf("e-")>-1)return this.number(td(parseFloat(e)));return this.number(e)}catch(t){return e}}checkOrderArguments(t,e,i,s,o,a){if(void 0===o&&"limit"===e)throw new r.ArgumentsRequired(this.id+" createOrder() requires a price argument for a limit order");if(s<=0)throw new r.ArgumentsRequired(this.id+" createOrder() amount should be above 0")}handleHttpStatusCode(t,e,i,s,r){let o=t.toString();if(o in this.httpExceptions)throw new this.httpExceptions[o](this.id+" "+s+" "+i+" "+o+" "+e+" "+r)}remove0xPrefix(t){return"0x"===t.slice(0,2)?t.slice(2):t}spawn(t,...e){let i=(0,n.K)();return setTimeout(()=>{t.apply(this,e).then(i.resolve).catch(i.reject)},0),i}delay(t,e,...i){setTimeout(()=>{this.spawn(e,...i)},t)}orderBook(t={},e=Number.MAX_SAFE_INTEGER){return new h.Mi(t,e)}indexedOrderBook(t={},e=Number.MAX_SAFE_INTEGER){return new h.nS(t,e)}countedOrderBook(t={},e=Number.MAX_SAFE_INTEGER){return new h.if(t,e)}handleMessage(t,e){}ping(t){}client(t){if(this.clients=this.clients||{},!this.clients[t]){let e=this.handleMessage.bind(this),i=this.onError.bind(this),s=this.onClose.bind(this),r=this.onConnected.bind(this),o=this.safeValue(this.options,"ws",{}),[n,h,d]=this.checkWsProxySettings(),c=this.setProxyAgents(n,h,d),p=this.getHttpAgentIfNeeded(t),l=c||p||this.agent,u=this.deepExtend(this.streaming,{log:this.log?this.log.bind(this):this.log,ping:this.ping?this.ping.bind(this):this.ping,verbose:this.verbose,throttler:new W(this.tokenBucket),options:{agent:l}},o);this.clients[t]=new a.A(t,e,i,s,r,u)}return this.clients[t]}watchMultiple(t,e,i,s,r){let o=this.client(t),a=n.K.race(e.map(t=>o.future(t))),h=[];if(void 0!==s)for(let t=0;t<s.length;t++){let e=s[t];o.subscriptions[e]||(h.push(e),o.subscriptions[e]=r||!0)}let d=o.connect(0);return(void 0===s||h.length)&&d.then(()=>{let t=this.safeValue(this.options,"ws"),e=this.safeValue(t,"cost",1);i&&(this.enableRateLimit&&o.throttle?o.throttle(e).then(()=>{o.send(i)}).catch(t=>{for(let t=0;t<h.length;t++){let e=h[t];delete o.subscriptions[e]}a.reject(t)}):o.send(i).catch(t=>{for(let t=0;t<h.length;t++){let e=h[t];delete o.subscriptions[e]}a.reject(t)}))}).catch(t=>{for(let t=0;t<h.length;t++){let e=h[t];delete o.subscriptions[e]}a.reject(t)}),a}watch(t,e,i,s,r){let o=this.client(t);if(void 0===s&&e in o.futures)return o.futures[e];let a=o.future(e),n=o.subscriptions[s];n||(o.subscriptions[s]=r||!0);let h=o.connect(0);return n||h.then(()=>{let t=this.safeValue(this.options,"ws"),e=this.safeValue(t,"cost",1);i&&(this.enableRateLimit&&o.throttle?o.throttle(e).then(()=>{o.send(i)}).catch(t=>{o.onError(t)}):o.send(i).catch(t=>{o.onError(t)}))}).catch(t=>{delete o.subscriptions[s],a.reject(t)}),a}onConnected(t,e){}onError(t,e){t.url in this.clients&&this.clients[t.url].error&&delete this.clients[t.url]}onClose(t,e){t.error||this.clients[t.url]&&delete this.clients[t.url]}async close(){let t=Object.values(this.clients||{}),e=[];for(let i=0;i<t.length;i++){let s=t[i];s.error=new r.ExchangeClosedByUser(this.id+" closedByUser"),e.push(s.close())}await Promise.all(e);for(let e=0;e<t.length;e++){let i=t[e];delete this.clients[i.url]}}async loadOrderBook(t,e,i,s,o={}){if(!(i in this.orderbooks)){t.reject(new r.ExchangeError(this.id+" loadOrderBook() orderbook is not initiated"),e);return}let a=this.handleOption("watchOrderBook","snapshotMaxRetries",3),n=0;try{let h=this.orderbooks[i];for(;n<a;){let r=h.cache,a=await this.fetchRestOrderBookSafe(i,s,o),d=this.getCacheIndex(a,r);if(d>=0){h.reset(a),this.handleDeltas(h,r.slice(d)),h.cache.length=0,t.resolve(h,e);return}n++}t.reject(new r.ExchangeError(this.id+" nonce is behind the cache after "+a.toString()+" tries."),e),delete this.clients[t.url]}catch(r){t.reject(r,e),await this.loadOrderBook(t,e,i,s,o)}}convertToBigInt(t){return BigInt(t)}stringToCharsArray(t){return t.split("")}valueIsDefined(t){return null!=t}arraySlice(t,e,i){return void 0===i?t.slice(e):t.slice(e,i)}getProperty(t,e,i){return e in t?t[e]:i}setProperty(t,e,i){t[e]=i}axolotl(t,e,i){return(0,d.Sw)(t,e,i)}fixStringifiedJsonMembers(t){let e=t.replaceAll("\\","");return(e=e.replaceAll('"{',"{")).replaceAll('}"',"}")}ethAbiEncode(t,e){return this.base16ToBinary(p.Ay.encode(t,e).slice(2))}ethEncodeStructuredData(t,e,i){return this.base16ToBinary(l.zl.encode(t,e,i).slice(-132))}retrieveStarkAccount(t,e,i){let s=(0,f.b)(t),r=(0,f.$u)(s),o=y.fP.compile({implementation:e,selector:y.tW.getSelectorFromName("initialize"),calldata:y.fP.compile({signer:r,guardian:"0"})}),a=y.tW.calculateContractAddressFromHash(r,i,o,0);return{privateKey:s,publicKey:r,address:a}}starknetEncodeStructuredData(t,e,i,s){let o=Object.keys(e);if(o.length>1)throw new r.NotSupported(this.id+"starknetEncodeStructuredData only support single type");let a={domain:t,primaryType:o[0],types:this.extend({StarkNetDomain:[{name:"name",type:"felt"},{name:"chainId",type:"felt"},{name:"version",type:"felt"}]},e),message:i};return y.pp.getMessageHash(a,s)}starknetSign(t,e){let i=(0,f._S)(t.replace("0x",""),e.slice(-64));return this.json([i.r.toString(),i.s.toString()])}intToBase16(t){return t.toString(16)}extendExchangeOptions(t){this.options=this.extend(this.options,t)}createSafeDictionary(){return{}}randomBytes(t){let e=new u.D,i=[];return i.length=t,e.nextBytes(i),m.from(i).toString("hex")}randNumber(t){let e="";for(let i=0;i<t;i++)e+=Math.floor(10*Math.random());return parseInt(e,10)}describe(){return{id:void 0,name:void 0,countries:void 0,enableRateLimit:!0,rateLimit:2e3,timeout:this.timeout,certified:!1,pro:!1,alias:!1,dex:!1,has:{publicAPI:!0,privateAPI:!0,CORS:void 0,sandbox:void 0,spot:void 0,margin:void 0,swap:void 0,future:void 0,option:void 0,addMargin:void 0,borrowCrossMargin:void 0,borrowIsolatedMargin:void 0,borrowMargin:void 0,cancelAllOrders:void 0,cancelAllOrdersWs:void 0,cancelOrder:!0,cancelOrderWs:void 0,cancelOrders:void 0,cancelOrdersWs:void 0,closeAllPositions:void 0,closePosition:void 0,createDepositAddress:void 0,createLimitBuyOrder:void 0,createLimitBuyOrderWs:void 0,createLimitOrder:!0,createLimitOrderWs:void 0,createLimitSellOrder:void 0,createLimitSellOrderWs:void 0,createMarketBuyOrder:void 0,createMarketBuyOrderWs:void 0,createMarketBuyOrderWithCost:void 0,createMarketBuyOrderWithCostWs:void 0,createMarketOrder:!0,createMarketOrderWs:!0,createMarketOrderWithCost:void 0,createMarketOrderWithCostWs:void 0,createMarketSellOrder:void 0,createMarketSellOrderWs:void 0,createMarketSellOrderWithCost:void 0,createMarketSellOrderWithCostWs:void 0,createOrder:!0,createOrderWs:void 0,createOrders:void 0,createOrderWithTakeProfitAndStopLoss:void 0,createOrderWithTakeProfitAndStopLossWs:void 0,createPostOnlyOrder:void 0,createPostOnlyOrderWs:void 0,createReduceOnlyOrder:void 0,createReduceOnlyOrderWs:void 0,createStopLimitOrder:void 0,createStopLimitOrderWs:void 0,createStopLossOrder:void 0,createStopLossOrderWs:void 0,createStopMarketOrder:void 0,createStopMarketOrderWs:void 0,createStopOrder:void 0,createStopOrderWs:void 0,createTakeProfitOrder:void 0,createTakeProfitOrderWs:void 0,createTrailingAmountOrder:void 0,createTrailingAmountOrderWs:void 0,createTrailingPercentOrder:void 0,createTrailingPercentOrderWs:void 0,createTriggerOrder:void 0,createTriggerOrderWs:void 0,deposit:void 0,editOrder:"emulated",editOrderWs:void 0,fetchAccounts:void 0,fetchBalance:!0,fetchBalanceWs:void 0,fetchBidsAsks:void 0,fetchBorrowInterest:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledAndClosedOrders:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:void 0,fetchClosedOrdersWs:void 0,fetchConvertCurrencies:void 0,fetchConvertQuote:void 0,fetchConvertTrade:void 0,fetchConvertTradeHistory:void 0,fetchCrossBorrowRate:void 0,fetchCrossBorrowRates:void 0,fetchCurrencies:"emulated",fetchCurrenciesWs:"emulated",fetchDeposit:void 0,fetchDepositAddress:void 0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:void 0,fetchDeposits:void 0,fetchDepositsWithdrawals:void 0,fetchDepositsWs:void 0,fetchDepositWithdrawFee:void 0,fetchDepositWithdrawFees:void 0,fetchFundingHistory:void 0,fetchFundingRate:void 0,fetchFundingRateHistory:void 0,fetchFundingInterval:void 0,fetchFundingIntervals:void 0,fetchFundingRates:void 0,fetchGreeks:void 0,fetchIndexOHLCV:void 0,fetchIsolatedBorrowRate:void 0,fetchIsolatedBorrowRates:void 0,fetchMarginAdjustmentHistory:void 0,fetchIsolatedPositions:void 0,fetchL2OrderBook:!0,fetchL3OrderBook:void 0,fetchLastPrices:void 0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverage:void 0,fetchLeverages:void 0,fetchLeverageTiers:void 0,fetchLiquidations:void 0,fetchLongShortRatio:void 0,fetchLongShortRatioHistory:void 0,fetchMarginMode:void 0,fetchMarginModes:void 0,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarketsWs:void 0,fetchMarkOHLCV:void 0,fetchMyLiquidations:void 0,fetchMySettlementHistory:void 0,fetchMyTrades:void 0,fetchMyTradesWs:void 0,fetchOHLCV:void 0,fetchOHLCVWs:void 0,fetchOpenInterest:void 0,fetchOpenInterests:void 0,fetchOpenInterestHistory:void 0,fetchOpenOrder:void 0,fetchOpenOrders:void 0,fetchOpenOrdersWs:void 0,fetchOption:void 0,fetchOptionChain:void 0,fetchOrder:void 0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrderBookWs:void 0,fetchOrders:void 0,fetchOrdersByStatus:void 0,fetchOrdersWs:void 0,fetchOrderTrades:void 0,fetchOrderWs:void 0,fetchPosition:void 0,fetchPositionHistory:void 0,fetchPositionsHistory:void 0,fetchPositionWs:void 0,fetchPositionMode:void 0,fetchPositions:void 0,fetchPositionsWs:void 0,fetchPositionsForSymbol:void 0,fetchPositionsForSymbolWs:void 0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:void 0,fetchSettlementHistory:void 0,fetchStatus:void 0,fetchTicker:!0,fetchTickerWs:void 0,fetchTickers:void 0,fetchMarkPrices:void 0,fetchTickersWs:void 0,fetchTime:void 0,fetchTrades:!0,fetchTradesWs:void 0,fetchTradingFee:void 0,fetchTradingFees:void 0,fetchTradingFeesWs:void 0,fetchTradingLimits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchTransactions:void 0,fetchTransfer:void 0,fetchTransfers:void 0,fetchUnderlyingAssets:void 0,fetchVolatilityHistory:void 0,fetchWithdrawAddresses:void 0,fetchWithdrawal:void 0,fetchWithdrawals:void 0,fetchWithdrawalsWs:void 0,fetchWithdrawalWhitelist:void 0,reduceMargin:void 0,repayCrossMargin:void 0,repayIsolatedMargin:void 0,setLeverage:void 0,setMargin:void 0,setMarginMode:void 0,setPositionMode:void 0,signIn:void 0,transfer:void 0,watchBalance:void 0,watchMyTrades:void 0,watchOHLCV:void 0,watchOHLCVForSymbols:void 0,watchOrderBook:void 0,watchOrderBookForSymbols:void 0,watchOrders:void 0,watchOrdersForSymbols:void 0,watchPosition:void 0,watchPositions:void 0,watchStatus:void 0,watchTicker:void 0,watchTickers:void 0,watchTrades:void 0,watchTradesForSymbols:void 0,watchLiquidations:void 0,watchLiquidationsForSymbols:void 0,watchMyLiquidations:void 0,watchMyLiquidationsForSymbols:void 0,withdraw:void 0,ws:void 0},urls:{logo:void 0,api:void 0,www:void 0,doc:void 0,fees:void 0},api:void 0,requiredCredentials:{apiKey:!0,secret:!0,uid:!1,accountId:!1,login:!1,password:!1,twofa:!1,privateKey:!1,walletAddress:!1,token:!1},markets:void 0,currencies:{},timeframes:void 0,fees:{trading:{tierBased:void 0,percentage:void 0,taker:void 0,maker:void 0},funding:{tierBased:void 0,percentage:void 0,withdraw:{},deposit:{}}},status:{status:"ok",updated:void 0,eta:void 0,url:void 0},exceptions:void 0,httpExceptions:{422:r.ExchangeError,418:r.DDoSProtection,429:r.RateLimitExceeded,404:r.ExchangeNotAvailable,409:r.ExchangeNotAvailable,410:r.ExchangeNotAvailable,451:r.ExchangeNotAvailable,500:r.ExchangeNotAvailable,501:r.ExchangeNotAvailable,502:r.ExchangeNotAvailable,520:r.ExchangeNotAvailable,521:r.ExchangeNotAvailable,522:r.ExchangeNotAvailable,525:r.ExchangeNotAvailable,526:r.ExchangeNotAvailable,400:r.ExchangeNotAvailable,403:r.ExchangeNotAvailable,405:r.ExchangeNotAvailable,503:r.ExchangeNotAvailable,530:r.ExchangeNotAvailable,408:r.RequestTimeout,504:r.RequestTimeout,401:r.AuthenticationError,407:r.AuthenticationError,511:r.AuthenticationError},commonCurrencies:{XBT:"BTC",BCC:"BCH",BCHSV:"BSV"},precisionMode:ei,paddingMode:ee,limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}}}safeBoolN(t,e,i){let s=this.safeValueN(t,e,i);return"boolean"==typeof s?s:i}safeBool2(t,e,i,s){return this.safeBoolN(t,[e,i],s)}safeBool(t,e,i){return this.safeBoolN(t,[e],i)}safeDictN(t,e,i){let s=this.safeValueN(t,e,i);return void 0===s?i:"object"!=typeof s||Array.isArray(s)?i:s}safeDict(t,e,i){return this.safeDictN(t,[e],i)}safeDict2(t,e,i,s){return this.safeDictN(t,[e,i],s)}safeListN(t,e,i){let s=this.safeValueN(t,e,i);return void 0===s?i:Array.isArray(s)?s:i}safeList2(t,e,i,s){return this.safeListN(t,[e,i],s)}safeList(t,e,i){return this.safeListN(t,[e],i)}handleDeltas(t,e){for(let i=0;i<e.length;i++)this.handleDelta(t,e[i])}handleDelta(t,e){throw new r.NotSupported(this.id+" handleDelta not supported yet")}handleDeltasWithKeys(t,e,i=0,s=1,r=2){for(let o=0;o<e.length;o++){let a=this.parseBidAsk(e[o],i,s,r);t.storeArray(a)}}getCacheIndex(t,e){return -1}findTimeframe(t,e){void 0===e&&(e=this.timeframes);let i=Object.keys(e);for(let s=0;s<i.length;s++){let r=i[s];if(e[r]===t)return r}}checkProxyUrlSettings(t,e,i,s){let o;let a=[];if(void 0!==this.proxyUrl&&(a.push("proxyUrl"),o=this.proxyUrl),void 0!==this.proxy_url&&(a.push("proxy_url"),o=this.proxy_url),void 0!==this.proxyUrlCallback&&(a.push("proxyUrlCallback"),o=this.proxyUrlCallback(t,e,i,s)),void 0!==this.proxy_url_callback&&(a.push("proxy_url_callback"),o=this.proxy_url_callback(t,e,i,s)),void 0!==this.proxy&&(a.push("proxy"),o="function"==typeof this.proxy?this.proxy(t,e,i,s):this.proxy),a.length>1){let t=a.join(",");throw new r.InvalidProxySettings(this.id+" you have multiple conflicting proxy settings ("+t+"), please use only one from : proxyUrl, proxy_url, proxyUrlCallback, proxy_url_callback")}return o}checkProxySettings(t,e,i,s){let o,a,n;let h=[],d=this.valueIsDefined(this.httpProxy),c=this.valueIsDefined(this.http_proxy);(d||c)&&(h.push("httpProxy"),o=d?this.httpProxy:this.http_proxy);let p=this.valueIsDefined(this.httpProxyCallback),l=this.valueIsDefined(this.http_proxy_callback);(p||l)&&(h.push("httpProxyCallback"),o=p?this.httpProxyCallback(t,e,i,s):this.http_proxy_callback(t,e,i,s));let u=this.valueIsDefined(this.httpsProxy),f=this.valueIsDefined(this.https_proxy);(u||f)&&(h.push("httpsProxy"),a=u?this.httpsProxy:this.https_proxy);let y=this.valueIsDefined(this.httpsProxyCallback),m=this.valueIsDefined(this.https_proxy_callback);(y||m)&&(h.push("httpsProxyCallback"),a=y?this.httpsProxyCallback(t,e,i,s):this.https_proxy_callback(t,e,i,s));let w=this.valueIsDefined(this.socksProxy),g=this.valueIsDefined(this.socks_proxy);(w||g)&&(h.push("socksProxy"),n=w?this.socksProxy:this.socks_proxy);let v=this.valueIsDefined(this.socksProxyCallback),S=this.valueIsDefined(this.socks_proxy_callback);if((v||S)&&(h.push("socksProxyCallback"),n=v?this.socksProxyCallback(t,e,i,s):this.socks_proxy_callback(t,e,i,s)),h.length>1){let t=h.join(",");throw new r.InvalidProxySettings(this.id+" you have multiple conflicting proxy settings ("+t+"), please use only one from: httpProxy, httpsProxy, httpProxyCallback, httpsProxyCallback, socksProxy, socksProxyCallback")}return[o,a,n]}checkWsProxySettings(){let t,e,i;let s=[],o=this.valueIsDefined(this.wsProxy),a=this.valueIsDefined(this.ws_proxy);(o||a)&&(s.push("wsProxy"),t=o?this.wsProxy:this.ws_proxy);let n=this.valueIsDefined(this.wssProxy),h=this.valueIsDefined(this.wss_proxy);(n||h)&&(s.push("wssProxy"),e=n?this.wssProxy:this.wss_proxy);let d=this.valueIsDefined(this.wsSocksProxy),c=this.valueIsDefined(this.ws_socks_proxy);if((d||c)&&(s.push("wsSocksProxy"),i=d?this.wsSocksProxy:this.ws_socks_proxy),s.length>1){let t=s.join(",");throw new r.InvalidProxySettings(this.id+" you have multiple conflicting proxy settings ("+t+"), please use only one from: wsProxy, wssProxy, wsSocksProxy")}return[t,e,i]}checkConflictingProxies(t,e){if(t&&e)throw new r.InvalidProxySettings(this.id+" you have multiple conflicting proxy settings, please use only one from : proxyUrl, httpProxy, httpsProxy, socksProxy")}checkAddress(t){if(void 0===t)throw new r.InvalidAddress(this.id+" address is undefined");if(1===this.unique(this.stringToCharsArray(t)).length||t.length<this.minFundingAddressLength||t.indexOf(" ")>-1)throw new r.InvalidAddress(this.id+" address is invalid or has less than "+this.minFundingAddressLength.toString()+' characters: "'+t.toString()+'"');return t}findMessageHashes(t,e){let i=[],s=Object.keys(t.futures);for(let t=0;t<s.length;t++){let r=s[t];r.indexOf(e)>=0&&i.push(r)}return i}filterByLimit(t,e,i="timestamp",s=!1){if(this.valueIsDefined(e)){let r=t.length;if(r>0){let o=!0;if(i in t[0]){let e=t[0][i],s=t[r-1][i];void 0!==e&&void 0!==s&&(o=e<=s)}s?(e>r&&(e=r),t=o?this.arraySlice(t,0,e):this.arraySlice(t,-e)):t=o?this.arraySlice(t,-e):this.arraySlice(t,0,e)}}return t}filterBySinceLimit(t,e,i,s="timestamp",r=!1){let o=this.valueIsDefined(e),a=this.toArray(t),n=a;if(o){n=[];for(let t=0;t<a.length;t++){let i=a[t],r=this.safeValue(i,s);r&&r>=e&&n.push(i)}}return r&&void 0!==i?this.arraySlice(n,-i):this.filterByLimit(n,i,s,!r&&o)}filterByValueSinceLimit(t,e,i,s,r,o="timestamp",a=!1){let n=this.valueIsDefined(i),h=this.valueIsDefined(s),d=this.toArray(t),c=d;if(n||h){c=[];for(let t=0;t<d.length;t++){let r=d[t],a=r[e]===i,p=!n||a,l=this.safeValue(r,o),u=l&&void 0!==s&&l>=s,f=!h||u;p&&f&&c.push(r)}}return a&&void 0!==r?this.arraySlice(c,-r):this.filterByLimit(c,r,o,h)}setSandboxMode(t){if(t){if("test"in this.urls)"string"==typeof this.urls.api?(this.urls.apiBackup=this.urls.api,this.urls.api=this.urls.test):(this.urls.apiBackup=this.clone(this.urls.api),this.urls.api=this.clone(this.urls.test));else throw new r.NotSupported(this.id+" does not have a sandbox URL");this.isSandboxModeEnabled=!0}else if("apiBackup"in this.urls){"string"==typeof this.urls.api?this.urls.api=this.urls.apiBackup:this.urls.api=this.clone(this.urls.apiBackup);let t=this.omit(this.urls,"apiBackup");this.urls=t,this.isSandboxModeEnabled=!1}}sign(t,e="public",i="GET",s={},r,o){return{}}async fetchAccounts(t={}){throw new r.NotSupported(this.id+" fetchAccounts() is not supported yet")}async fetchTrades(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchTrades() is not supported yet")}async fetchTradesWs(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchTradesWs() is not supported yet")}async watchLiquidations(t,e,i,s={}){if(this.has.watchLiquidationsForSymbols)return await this.watchLiquidationsForSymbols([t],e,i,s);throw new r.NotSupported(this.id+" watchLiquidations() is not supported yet")}async watchLiquidationsForSymbols(t,e,i,s={}){throw new r.NotSupported(this.id+" watchLiquidationsForSymbols() is not supported yet")}async watchMyLiquidations(t,e,i,s={}){if(this.has.watchMyLiquidationsForSymbols)return this.watchMyLiquidationsForSymbols([t],e,i,s);throw new r.NotSupported(this.id+" watchMyLiquidations() is not supported yet")}async watchMyLiquidationsForSymbols(t,e,i,s={}){throw new r.NotSupported(this.id+" watchMyLiquidationsForSymbols() is not supported yet")}async watchTrades(t,e,i,s={}){throw new r.NotSupported(this.id+" watchTrades() is not supported yet")}async unWatchTrades(t,e={}){throw new r.NotSupported(this.id+" unWatchTrades() is not supported yet")}async watchTradesForSymbols(t,e,i,s={}){throw new r.NotSupported(this.id+" watchTradesForSymbols() is not supported yet")}async unWatchTradesForSymbols(t,e={}){throw new r.NotSupported(this.id+" unWatchTradesForSymbols() is not supported yet")}async watchMyTradesForSymbols(t,e,i,s={}){throw new r.NotSupported(this.id+" watchMyTradesForSymbols() is not supported yet")}async watchOrdersForSymbols(t,e,i,s={}){throw new r.NotSupported(this.id+" watchOrdersForSymbols() is not supported yet")}async watchOHLCVForSymbols(t,e,i,s={}){throw new r.NotSupported(this.id+" watchOHLCVForSymbols() is not supported yet")}async unWatchOHLCVForSymbols(t,e={}){throw new r.NotSupported(this.id+" unWatchOHLCVForSymbols() is not supported yet")}async watchOrderBookForSymbols(t,e,i={}){throw new r.NotSupported(this.id+" watchOrderBookForSymbols() is not supported yet")}async unWatchOrderBookForSymbols(t,e={}){throw new r.NotSupported(this.id+" unWatchOrderBookForSymbols() is not supported yet")}async fetchDepositAddresses(t,e={}){throw new r.NotSupported(this.id+" fetchDepositAddresses() is not supported yet")}async fetchOrderBook(t,e,i={}){throw new r.NotSupported(this.id+" fetchOrderBook() is not supported yet")}async fetchOrderBookWs(t,e,i={}){throw new r.NotSupported(this.id+" fetchOrderBookWs() is not supported yet")}async fetchMarginMode(t,e={}){if(this.has.fetchMarginModes){let i=await this.fetchMarginModes([t],e);return this.safeDict(i,t)}throw new r.NotSupported(this.id+" fetchMarginMode() is not supported yet")}async fetchMarginModes(t,e={}){throw new r.NotSupported(this.id+" fetchMarginModes () is not supported yet")}async fetchRestOrderBookSafe(t,e,i={}){let s=this.handleOption("watchOrderBook","maxRetries",3);for(let r=0;r<s;r++)try{return await this.fetchOrderBook(t,e,i)}catch(t){if(r+1===s)throw t}}async watchOrderBook(t,e,i={}){throw new r.NotSupported(this.id+" watchOrderBook() is not supported yet")}async unWatchOrderBook(t,e={}){throw new r.NotSupported(this.id+" unWatchOrderBook() is not supported yet")}async fetchTime(t={}){throw new r.NotSupported(this.id+" fetchTime() is not supported yet")}async fetchTradingLimits(t,e={}){throw new r.NotSupported(this.id+" fetchTradingLimits() is not supported yet")}parseCurrency(t){throw new r.NotSupported(this.id+" parseCurrency() is not supported yet")}parseCurrencies(t){let e={},i=this.toArray(t);for(let t=0;t<i.length;t++){let s=this.parseCurrency(i[t]);e[s.code]=s}return e}parseMarket(t){throw new r.NotSupported(this.id+" parseMarket() is not supported yet")}parseMarkets(t){let e=[];for(let i=0;i<t.length;i++)e.push(this.parseMarket(t[i]));return e}parseTicker(t,e){throw new r.NotSupported(this.id+" parseTicker() is not supported yet")}parseDepositAddress(t,e){throw new r.NotSupported(this.id+" parseDepositAddress() is not supported yet")}parseTrade(t,e){throw new r.NotSupported(this.id+" parseTrade() is not supported yet")}parseTransaction(t,e){throw new r.NotSupported(this.id+" parseTransaction() is not supported yet")}parseTransfer(t,e){throw new r.NotSupported(this.id+" parseTransfer() is not supported yet")}parseAccount(t){throw new r.NotSupported(this.id+" parseAccount() is not supported yet")}parseLedgerEntry(t,e){throw new r.NotSupported(this.id+" parseLedgerEntry() is not supported yet")}parseOrder(t,e){throw new r.NotSupported(this.id+" parseOrder() is not supported yet")}async fetchCrossBorrowRates(t={}){throw new r.NotSupported(this.id+" fetchCrossBorrowRates() is not supported yet")}async fetchIsolatedBorrowRates(t={}){throw new r.NotSupported(this.id+" fetchIsolatedBorrowRates() is not supported yet")}parseMarketLeverageTiers(t,e){throw new r.NotSupported(this.id+" parseMarketLeverageTiers() is not supported yet")}async fetchLeverageTiers(t,e={}){throw new r.NotSupported(this.id+" fetchLeverageTiers() is not supported yet")}parsePosition(t,e){throw new r.NotSupported(this.id+" parsePosition() is not supported yet")}parseFundingRateHistory(t,e){throw new r.NotSupported(this.id+" parseFundingRateHistory() is not supported yet")}parseBorrowInterest(t,e){throw new r.NotSupported(this.id+" parseBorrowInterest() is not supported yet")}parseIsolatedBorrowRate(t,e){throw new r.NotSupported(this.id+" parseIsolatedBorrowRate() is not supported yet")}parseWsTrade(t,e){throw new r.NotSupported(this.id+" parseWsTrade() is not supported yet")}parseWsOrder(t,e){throw new r.NotSupported(this.id+" parseWsOrder() is not supported yet")}parseWsOrderTrade(t,e){throw new r.NotSupported(this.id+" parseWsOrderTrade() is not supported yet")}parseWsOHLCV(t,e){return this.parseOHLCV(t,e)}async fetchFundingRates(t,e={}){throw new r.NotSupported(this.id+" fetchFundingRates() is not supported yet")}async fetchFundingIntervals(t,e={}){throw new r.NotSupported(this.id+" fetchFundingIntervals() is not supported yet")}async watchFundingRate(t,e={}){throw new r.NotSupported(this.id+" watchFundingRate() is not supported yet")}async watchFundingRates(t,e={}){throw new r.NotSupported(this.id+" watchFundingRates() is not supported yet")}async watchFundingRatesForSymbols(t,e={}){return await this.watchFundingRates(t,e)}async transfer(t,e,i,s,o={}){throw new r.NotSupported(this.id+" transfer() is not supported yet")}async withdraw(t,e,i,s,o={}){throw new r.NotSupported(this.id+" withdraw() is not supported yet")}async createDepositAddress(t,e={}){throw new r.NotSupported(this.id+" createDepositAddress() is not supported yet")}async setLeverage(t,e,i={}){throw new r.NotSupported(this.id+" setLeverage() is not supported yet")}async fetchLeverage(t,e={}){if(this.has.fetchLeverages){let i=await this.fetchLeverages([t],e);return this.safeDict(i,t)}throw new r.NotSupported(this.id+" fetchLeverage() is not supported yet")}async fetchLeverages(t,e={}){throw new r.NotSupported(this.id+" fetchLeverages() is not supported yet")}async setPositionMode(t,e,i={}){throw new r.NotSupported(this.id+" setPositionMode() is not supported yet")}async addMargin(t,e,i={}){throw new r.NotSupported(this.id+" addMargin() is not supported yet")}async reduceMargin(t,e,i={}){throw new r.NotSupported(this.id+" reduceMargin() is not supported yet")}async setMargin(t,e,i={}){throw new r.NotSupported(this.id+" setMargin() is not supported yet")}async fetchLongShortRatio(t,e,i={}){throw new r.NotSupported(this.id+" fetchLongShortRatio() is not supported yet")}async fetchLongShortRatioHistory(t,e,i,s,o={}){throw new r.NotSupported(this.id+" fetchLongShortRatioHistory() is not supported yet")}async fetchMarginAdjustmentHistory(t,e,i,s,o={}){throw new r.NotSupported(this.id+" fetchMarginAdjustmentHistory() is not supported yet")}async setMarginMode(t,e,i={}){throw new r.NotSupported(this.id+" setMarginMode() is not supported yet")}async fetchDepositAddressesByNetwork(t,e={}){throw new r.NotSupported(this.id+" fetchDepositAddressesByNetwork() is not supported yet")}async fetchOpenInterestHistory(t,e="1h",i,s,o={}){throw new r.NotSupported(this.id+" fetchOpenInterestHistory() is not supported yet")}async fetchOpenInterest(t,e={}){throw new r.NotSupported(this.id+" fetchOpenInterest() is not supported yet")}async fetchOpenInterests(t,e={}){throw new r.NotSupported(this.id+" fetchOpenInterests() is not supported yet")}async signIn(t={}){throw new r.NotSupported(this.id+" signIn() is not supported yet")}async fetchPaymentMethods(t={}){throw new r.NotSupported(this.id+" fetchPaymentMethods() is not supported yet")}parseToInt(t){return parseInt(parseFloat(this.numberToString(t)))}parseToNumeric(t){let e=this.numberToString(t);return e.indexOf(".")>=0?parseFloat(e):parseInt(e)}isRoundNumber(t){return 0===this.parseToNumeric(t%1)}safeIntegerOmitZero(t,e,i){let s=this.safeInteger(t,e,i);if(void 0!==s&&0!==s)return s}afterConstruct(){this.createNetworksByIdObject(),this.featuresGenerator()}featuresGenerator(){if(void 0===this.features)return;let t=this.features;this.features={};let e=["spot","swap","future","option"],i=["linear","inverse"];for(let s=0;s<e.length;s++){let r=e[s];if(r in t){if("spot"===r)this.features[r]=this.featuresMapper(t,r,void 0);else{this.features[r]={};for(let e=0;e<i.length;e++){let s=i[e];this.features[r][s]=this.featuresMapper(t,r,s)}}}else this.features[r]=void 0}}featuresMapper(t,e,i){let s=void 0!==i?t[e][i]:t[e];if(void 0===s)return;let r=this.safeString(s,"extends");if(void 0!==r){s=this.omit(s,"extends");let e=this.featuresMapper(t,r);s=this.deepExtend(e,s)}if("createOrder"in s){let t=this.safeDict(s.createOrder,"attachedStopLossTakeProfit");void 0!==t&&(s.createOrder.stopLoss=t,s.createOrder.takeProfit=t),"spot"===e&&(s.createOrder.hedged=!1),void 0===this.safeBool(s.createOrder.timeInForce,"gtc")&&(s.createOrder.timeInForce.GTC=!0)}return s}orderbookChecksumMessage(t){return t+' : orderbook data checksum validation failed. You can reconnect by calling watchOrderBook again or you can mute the error by setting exchange.options["watchOrderBook"]["checksum"] = false'}createNetworksByIdObject(){let t=this.invertFlatStringDictionary(this.safeValue(this.options,"networks",{}));this.options.networksById=this.extend(t,this.safeValue(this.options,"networksById",{}))}getDefaultOptions(){return{defaultNetworkCodeReplacements:{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"},CRO:{CRC20:"CRONOS"},BRC20:{BRC20:"BTC"}}}}safeLedgerEntry(t,e){e=this.safeCurrency(void 0,e);let i=this.safeString(t,"direction"),s=this.safeString(t,"before"),r=this.safeString(t,"after"),a=this.safeString(t,"amount");void 0!==a&&(void 0===s&&void 0!==r?s=o.Y.stringSub(r,a):void 0!==s&&void 0===r&&(r=o.Y.stringAdd(s,a))),void 0!==s&&void 0!==r&&void 0===i&&(o.Y.stringGt(s,r)&&(i="out"),o.Y.stringGt(r,s)&&(i="in"));let n=this.safeValue(t,"fee");void 0!==n&&(n.cost=this.safeNumber(n,"cost"));let h=this.safeInteger(t,"timestamp"),d=this.safeDict(t,"info",{});return{id:this.safeString(t,"id"),timestamp:h,datetime:this.iso8601(h),direction:i,account:this.safeString(t,"account"),referenceId:this.safeString(t,"referenceId"),referenceAccount:this.safeString(t,"referenceAccount"),type:this.safeString(t,"type"),currency:e.code,amount:this.parseNumber(a),before:this.parseNumber(s),after:this.parseNumber(r),status:this.safeString(t,"status"),fee:n,info:d}}safeCurrencyStructure(t){return this.extend({info:void 0,id:void 0,numericId:void 0,code:void 0,precision:void 0,type:void 0,name:void 0,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,fees:{},networks:{},limits:{deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}},t)}safeMarketStructure(t){let e={id:void 0,lowercaseId:void 0,symbol:void 0,base:void 0,quote:void 0,settle:void 0,baseId:void 0,quoteId:void 0,settleId:void 0,type:void 0,spot:void 0,margin:void 0,swap:void 0,future:void 0,option:void 0,index:void 0,active:void 0,contract:void 0,linear:void 0,inverse:void 0,subType:void 0,taker:void 0,maker:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0,cost:void 0,base:void 0,quote:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},marginModes:{cross:void 0,isolated:void 0},created:void 0,info:void 0};if(void 0!==t){let i=this.extend(e,t);return i.spot&&(void 0===i.contract&&(i.contract=!1),void 0===i.swap&&(i.swap=!1),void 0===i.future&&(i.future=!1),void 0===i.option&&(i.option=!1),void 0===i.index&&(i.index=!1)),i}return e}setMarkets(t,e){let i=[];this.markets_by_id={};let s=this.sortBy(this.toArray(t),"spot",!0,!0);for(let t=0;t<s.length;t++){let e=s[t];e.id in this.markets_by_id?this.markets_by_id[e.id].push(e):this.markets_by_id[e.id]=[e];let r=this.deepExtend(this.safeMarketStructure(),{precision:this.precision,limits:this.limits},this.fees.trading,e);r.linear?r.subType="linear":r.inverse?r.subType="inverse":r.subType=void 0,i.push(r)}this.markets=this.indexBy(i,"symbol");let r=this.keysort(this.markets),o=this.keysort(this.markets_by_id);if(this.symbols=Object.keys(r),this.ids=Object.keys(o),void 0!==e)this.currencies=this.deepExtend(this.currencies,e);else{let t=[],e=[];for(let s=0;s<i.length;s++){let r=i[s],o=this.precisionMode===et?8:this.parseNumber("1e-8"),a=this.safeDict(r,"precision",{});if("base"in r){let e=this.safeCurrencyStructure({id:this.safeString2(r,"baseId","base"),numericId:this.safeInteger(r,"baseNumericId"),code:this.safeString(r,"base"),precision:this.safeValue2(a,"base","amount",o)});t.push(e)}if("quote"in r){let t=this.safeCurrencyStructure({id:this.safeString2(r,"quoteId","quote"),numericId:this.safeInteger(r,"quoteNumericId"),code:this.safeString(r,"quote"),precision:this.safeValue2(a,"quote","price",o)});e.push(t)}}t=this.sortBy(t,"code",!1,""),e=this.sortBy(e,"code",!1,""),this.baseCurrencies=this.indexBy(t,"code"),this.quoteCurrencies=this.indexBy(e,"code");let s=this.arrayConcat(t,e),r=this.groupBy(s,"code"),o=Object.keys(r),a=[];for(let t=0;t<o.length;t++){let e=o[t],i=this.safeList(r,e,[]),s=this.safeValue(i,0);for(let t=1;t<i.length;t++){let e=i[t];s=this.precisionMode===ei?e.precision<s.precision?e:s:e.precision>s.precision?e:s}a.push(s)}let n=this.sortBy(a,"code");this.currencies=this.deepExtend(this.currencies,this.indexBy(n,"code"))}this.currencies_by_id=this.indexBy(this.currencies,"id");let a=this.keysort(this.currencies);return this.codes=Object.keys(a),this.markets}getDescribeForExtendedWsExchange(t,e,i){let s=this.deepExtend(e.describe(),t.describe());return this.deepExtend(s,i)}safeBalance(t){let e=Object.keys(this.omit(t,["info","timestamp","datetime","free","used","total"]));t.free={},t.used={},t.total={};let i={};for(let s=0;s<e.length;s++){let r=e[s],a=this.safeString(t[r],"total"),n=this.safeString(t[r],"free"),h=this.safeString(t[r],"used"),d=this.safeString(t[r],"debt");void 0===a&&void 0!==n&&void 0!==h&&(a=o.Y.stringAdd(n,h)),void 0===n&&void 0!==a&&void 0!==h&&(n=o.Y.stringSub(a,h)),void 0===h&&void 0!==a&&void 0!==n&&(h=o.Y.stringSub(a,n)),t[r].free=this.parseNumber(n),t[r].used=this.parseNumber(h),t[r].total=this.parseNumber(a),t.free[r]=t[r].free,t.used[r]=t[r].used,t.total[r]=t[r].total,void 0!==d&&(t[r].debt=this.parseNumber(d),i[r]=t[r].debt)}return Object.keys(i).length&&(t.debt=i),t}safeOrder(t,e){let i=this.omitZero(this.safeString(t,"amount")),s=this.safeString(t,"remaining"),r=this.safeString(t,"filled"),a=this.safeString(t,"cost"),n=this.omitZero(this.safeString(t,"average")),h=this.omitZero(this.safeString(t,"price")),d=this.safeInteger(t,"lastTradeTimestamp"),c=this.safeString(t,"symbol"),p=this.safeString(t,"side"),l=this.safeString(t,"status"),u=void 0===r,f=void 0===a,y=void 0===d,m=this.safeValue(t,"fee"),w=void 0===m,g=void 0===this.safeValue(t,"fees"),v=void 0===c,S=void 0===p,b=w||g,k=this.safeList(t,"fees",[]),O=[],N=void 0!==this.safeString(t,"triggerPrice")||void 0!==this.safeString(t,"stopLossPrice")||void 0!==this.safeString(t,"takeProfitPrice");if(u||f||b){let i=this.safeValue(t,"trades",O),s=this.safeValue(i,0);O=void 0!==s&&"info"in s&&"id"in s?i:this.parseTrades(i,e);let n=0,h=Array.isArray(O);if(h&&(n=O.length),h&&n>0){void 0===t.symbol&&(t.symbol=O[0].symbol),void 0===t.side&&(t.side=O[0].side),void 0===t.type&&(t.type=O[0].type),void 0===t.id&&(t.id=O[0].order),u&&(r="0"),f&&(a="0");for(let t=0;t<O.length;t++){let e=O[t],i=this.safeString(e,"amount");u&&void 0!==i&&(r=o.Y.stringAdd(r,i));let s=this.safeString(e,"cost");f&&void 0!==s&&(a=o.Y.stringAdd(a,s)),v&&(c=this.safeString(e,"symbol")),S&&(p=this.safeString(e,"side"));let n=this.safeValue(e,"timestamp");if(y&&void 0!==n&&(d=void 0===d?n:Math.max(d,n)),b){let t=this.safeValue(e,"fees");if(void 0!==t)for(let e=0;e<t.length;e++){let i=t[e];k.push(this.extend({},i))}else{let t=this.safeValue(e,"fee");void 0!==t&&k.push(this.extend({},t))}}}}}if(b){let e=this.reduceFees?this.reduceFeesByCurrency(k):k,i=e.length;for(let t=0;t<i;t++)e[t].cost=this.safeNumber(e[t],"cost"),"rate"in e[t]&&(e[t].rate=this.safeNumber(e[t],"rate"));if(!w&&0===i){let t=this.deepExtend(m);t.cost=this.safeNumber(t,"cost"),"rate"in t&&(t.rate=this.safeNumber(t,"rate")),e.push(t)}t.fees=e,w&&1===i&&(t.fee=e[0])}void 0===i&&(void 0!==r&&void 0!==s?i=o.Y.stringAdd(r,s):"closed"===l&&(i=r)),void 0===r&&(void 0!==i&&void 0!==s?r=o.Y.stringSub(i,s):"closed"===l&&void 0!==i&&(r=i)),void 0===s&&(void 0!==i&&void 0!==r?s=o.Y.stringSub(i,r):"closed"===l&&(s="0"));let P=this.safeBool(e,"inverse",!1),x=this.numberToString(this.safeValue(e,"contractSize",1));if(void 0===n&&void 0!==r&&void 0!==a&&o.Y.stringGt(r,"0")){let t=o.Y.stringMul(r,x);n=P?o.Y.stringDiv(t,a):o.Y.stringDiv(a,t)}let T=void 0!==n||void 0!==h;if(f&&void 0!==r&&T){let t;t=void 0===n?h:n;let e=o.Y.stringMul(r,x);a=P?o.Y.stringDiv(e,t):o.Y.stringMul(e,t)}let A=this.safeValue(t,"type");(void 0===h||o.Y.stringEquals(h,"0"))&&"market"===A&&(h=n);for(let t=0;t<O.length;t++){let e=O[t];e.amount=this.safeNumber(e,"amount"),e.price=this.safeNumber(e,"price"),e.cost=this.safeNumber(e,"cost");let i=this.safeDict(e,"fee",{});i.cost=this.safeNumber(i,"cost"),"rate"in i&&(i.rate=this.safeNumber(i,"rate"));let s=this.safeList(e,"fees",[]);for(let t=0;t<s.length;t++)s[t].cost=this.safeNumber(s[t],"cost");e.fees=s,e.fee=i}let M=this.safeString(t,"timeInForce"),L=this.safeValue(t,"postOnly");void 0===M?(N||"market"!==this.safeString(t,"type")||(M="IOC"),L&&(M="PO")):void 0===L&&(L="PO"===M);let C=this.safeInteger(t,"timestamp"),B=this.safeInteger(t,"lastUpdateTimestamp"),W=this.safeString(t,"datetime");void 0===W&&(W=this.iso8601(C));let I=this.parseNumber(this.safeString2(t,"triggerPrice","stopPrice")),R=this.parseNumber(this.safeString(t,"takeProfitPrice")),F=this.parseNumber(this.safeString(t,"stopLossPrice"));return this.extend(t,{id:this.safeString(t,"id"),clientOrderId:this.safeString(t,"clientOrderId"),timestamp:C,datetime:W,symbol:c,type:this.safeString(t,"type"),side:p,lastTradeTimestamp:d,lastUpdateTimestamp:B,price:this.parseNumber(h),amount:this.parseNumber(i),cost:this.parseNumber(a),average:this.parseNumber(n),filled:this.parseNumber(r),remaining:this.parseNumber(s),timeInForce:M,postOnly:L,trades:O,reduceOnly:this.safeValue(t,"reduceOnly"),stopPrice:I,triggerPrice:I,takeProfitPrice:R,stopLossPrice:F,status:l,fee:this.safeValue(t,"fee")})}parseOrders(t,e,i,s,r={}){let o=[];if(Array.isArray(t))for(let i=0;i<t.length;i++){let s=this.extend(this.parseOrder(t[i],e),r);o.push(s)}else{let i=Object.keys(t);for(let s=0;s<i.length;s++){let a=i[s],n=this.extend(this.parseOrder(this.extend({id:a},t[a]),e),r);o.push(n)}}o=this.sortBy(o,"timestamp");let a=void 0!==e?e.symbol:void 0;return this.filterBySymbolSinceLimit(o,a,i,s)}calculateFee(t,e,i,s,a,n="taker",h={}){let d,c;if("market"===e&&"maker"===n)throw new r.ArgumentsRequired(this.id+' calculateFee() - you have provided incompatible arguments - "market" type order can not be "maker". Change either the "type" or the "takerOrMaker" argument to calculate the fee.');let p=this.markets[t],l=this.safeString(p,"feeSide","quote");d="get"===l?"sell"===i:"give"===l?"buy"===i:"quote"===l;let u=this.numberToString(s);if(d){let t=this.numberToString(a);u=o.Y.stringMul(u,t),c="quote"}else c="base";p.spot||(c="settle"),"market"===e&&(n="taker");let f=this.safeString(p,n);return u=o.Y.stringMul(u,f),{type:n,currency:p[c],rate:this.parseNumber(f),cost:this.parseNumber(u)}}safeLiquidation(t,e){let i=this.safeString(t,"contracts"),s=this.safeString(e,"contractSize"),r=this.safeString(t,"price"),a=this.safeString(t,"baseValue"),n=this.safeString(t,"quoteValue");return void 0===a&&void 0!==i&&void 0!==s&&void 0!==r&&(a=o.Y.stringMul(i,s)),void 0===n&&void 0!==a&&void 0!==r&&(n=o.Y.stringMul(a,r)),t.contracts=this.parseNumber(i),t.contractSize=this.parseNumber(s),t.price=this.parseNumber(r),t.baseValue=this.parseNumber(a),t.quoteValue=this.parseNumber(n),t}safeTrade(t,e){let i=this.safeString(t,"amount"),s=this.safeString(t,"price"),r=this.safeString(t,"cost");if(void 0===r){let t=this.safeString(e,"contractSize"),a=s;void 0!==t&&(this.safeBool(e,"inverse",!1)&&(a=o.Y.stringDiv("1",s)),a=o.Y.stringMul(a,t)),r=o.Y.stringMul(a,i)}let[a,n]=this.parsedFeeAndFees(t);return t.fee=a,t.fees=n,t.amount=this.parseNumber(i),t.price=this.parseNumber(s),t.cost=this.parseNumber(r),t}parsedFeeAndFees(t){let e=this.safeDict(t,"fee"),i=this.safeList(t,"fees"),s=void 0!==e,r=void 0!==i;if(s||r){s&&(e=this.parseFeeNumeric(e)),r||(i=[e]);let t=this.reduceFees?this.reduceFeesByCurrency(i):i,o=t.length;for(let e=0;e<o;e++)t[e]=this.parseFeeNumeric(t[e]);i=t,1===o?e=t[0]:0===o&&(e=void 0)}return void 0===e&&(e={cost:void 0,currency:void 0}),void 0===i&&(i=[]),[e,i]}parseFeeNumeric(t){return t.cost=this.safeNumber(t,"cost"),"rate"in t&&(t.rate=this.safeNumber(t,"rate")),t}findNearestCeiling(t,e){let i=t.length;for(let s=0;s<i;s++){let i=t[s];if(e<=i)return i}return t[i-1]}invertFlatStringDictionary(t){let e={},i=Object.keys(t);for(let s=0;s<i.length;s++){let r=i[s],o=t[r];"string"==typeof o&&(e[o]=r)}return e}reduceFeesByCurrency(t){let e={};for(let i=0;i<t.length;i++){let s=t[i],r=this.safeString(s,"currency"),a=void 0!==r?r:i.toString();if(void 0!==a){let t=this.safeString(s,"rate"),i=this.safeString(s,"cost");if(void 0===i)continue;a in e||(e[a]={});let n=void 0===t?"":t;n in e[a]?e[a][n].cost=o.Y.stringAdd(e[a][n].cost,i):(e[a][n]={currency:r,cost:i},void 0!==t&&(e[a][n].rate=t))}}let i=[],s=Object.values(e);for(let t=0;t<s.length;t++){let e=Object.values(s[t]);i=this.arrayConcat(i,e)}return i}safeTicker(t,e){let i=this.omitZero(this.safeString(t,"open")),s=this.omitZero(this.safeString(t,"close")),r=this.omitZero(this.safeString(t,"last")),a=this.omitZero(this.safeString(t,"change")),n=this.omitZero(this.safeString(t,"percentage")),h=this.omitZero(this.safeString(t,"average")),d=this.omitZero(this.safeString(t,"vwap")),c=this.safeString(t,"baseVolume"),p=this.safeString(t,"quoteVolume");if(void 0===d&&(d=o.Y.stringDiv(this.omitZero(p),c)),void 0!==r&&void 0===s?s=r:void 0===r&&void 0!==s&&(r=s),void 0!==r&&void 0!==i&&(void 0===a&&(a=o.Y.stringSub(r,i)),void 0===h)){let t=18;if(void 0!==e&&this.isTickPrecision()){let i=this.safeDict(e,"precision"),s=this.safeString(i,"price");void 0!==s&&(t=this.precisionFromString(s))}h=o.Y.stringDiv(o.Y.stringAdd(r,i),"2",t)}return void 0===n&&void 0!==a&&void 0!==i&&o.Y.stringGt(i,"0")&&(n=o.Y.stringMul(o.Y.stringDiv(a,i),"100")),void 0===a&&void 0!==n&&void 0!==i&&(a=o.Y.stringDiv(o.Y.stringMul(n,i),"100")),void 0===i&&void 0!==r&&void 0!==a&&(i=o.Y.stringSub(r,a)),this.extend(t,{bid:this.parseNumber(this.omitZero(this.safeString(t,"bid"))),bidVolume:this.safeNumber(t,"bidVolume"),ask:this.parseNumber(this.omitZero(this.safeString(t,"ask"))),askVolume:this.safeNumber(t,"askVolume"),high:this.parseNumber(this.omitZero(this.safeString(t,"high"))),low:this.parseNumber(this.omitZero(this.safeString(t,"low"))),open:this.parseNumber(this.omitZero(i)),close:this.parseNumber(this.omitZero(s)),last:this.parseNumber(this.omitZero(r)),change:this.parseNumber(a),percentage:this.parseNumber(n),average:this.parseNumber(h),vwap:this.parseNumber(d),baseVolume:this.parseNumber(c),quoteVolume:this.parseNumber(p),previousClose:this.safeNumber(t,"previousClose"),indexPrice:this.safeNumber(t,"indexPrice"),markPrice:this.safeNumber(t,"markPrice")})}async fetchBorrowRate(t,e,i={}){throw new r.NotSupported(this.id+" fetchBorrowRate is deprecated, please use fetchCrossBorrowRate or fetchIsolatedBorrowRate instead")}async repayCrossMargin(t,e,i={}){throw new r.NotSupported(this.id+" repayCrossMargin is not support yet")}async repayIsolatedMargin(t,e,i,s={}){throw new r.NotSupported(this.id+" repayIsolatedMargin is not support yet")}async borrowCrossMargin(t,e,i={}){throw new r.NotSupported(this.id+" borrowCrossMargin is not support yet")}async borrowIsolatedMargin(t,e,i,s={}){throw new r.NotSupported(this.id+" borrowIsolatedMargin is not support yet")}async borrowMargin(t,e,i,s={}){throw new r.NotSupported(this.id+" borrowMargin is deprecated, please use borrowCrossMargin or borrowIsolatedMargin instead")}async repayMargin(t,e,i,s={}){throw new r.NotSupported(this.id+" repayMargin is deprecated, please use repayCrossMargin or repayIsolatedMargin instead")}async fetchOHLCV(t,e="1m",i,s,o={}){let a="";throw this.has.fetchTrades&&(a='. If you want to build OHLCV candles from trade executions data, visit https://github.com/ccxt/ccxt/tree/master/examples/ and see "build-ohlcv-bars" file'),new r.NotSupported(this.id+" fetchOHLCV() is not supported yet"+a)}async fetchOHLCVWs(t,e="1m",i,s,o={}){let a="";throw this.has.fetchTradesWs&&(a='. If you want to build OHLCV candles from trade executions data, visit https://github.com/ccxt/ccxt/tree/master/examples/ and see "build-ohlcv-bars" file'),new r.NotSupported(this.id+" fetchOHLCVWs() is not supported yet. Try using fetchOHLCV instead."+a)}async watchOHLCV(t,e="1m",i,s,o={}){throw new r.NotSupported(this.id+" watchOHLCV() is not supported yet")}convertTradingViewToOHLCV(t,e="t",i="o",s="h",r="l",o="c",a="v",n=!1){let h=[],d=this.safeList(t,e,[]),c=this.safeList(t,i,[]),p=this.safeList(t,s,[]),l=this.safeList(t,r,[]),u=this.safeList(t,o,[]),f=this.safeList(t,a,[]);for(let t=0;t<d.length;t++)h.push([n?this.safeInteger(d,t):this.safeTimestamp(d,t),this.safeValue(c,t),this.safeValue(p,t),this.safeValue(l,t),this.safeValue(u,t),this.safeValue(f,t)]);return h}convertOHLCVToTradingView(t,e="t",i="o",s="h",r="l",o="c",a="v",n=!1){let h={};h[e]=[],h[i]=[],h[s]=[],h[r]=[],h[o]=[],h[a]=[];for(let d=0;d<t.length;d++){let c=n?t[d][0]:this.parseToInt(t[d][0]/1e3);h[e].push(c),h[i].push(t[d][1]),h[s].push(t[d][2]),h[r].push(t[d][3]),h[o].push(t[d][4]),h[a].push(t[d][5])}return h}async fetchWebEndpoint(t,e,i,s,o){let a="",n=this.safeValue(this.options,t,{}),h=this.safeBool(n,"webApiMuteFailure",!0);try{let t;if(!0!==this.safeBool(n,"webApiEnable",!0))return;let a=this.safeValue(n,"webApiRetries",10),h=0;for(;h<a;)try{t=await this[e]({});break}catch(t){if((h+=1)===a)throw t}let d=t;if(void 0!==s&&(d=d.split(s)[1]),void 0!==o&&(d=d.split(o)[0]),!i||"string"!=typeof d)return d;{let t=this.parseJson(d.trim());if(t)return t;throw new r.BadResponse("could not parse the response into json")}}catch(e){a=this.id+" "+t+"() failed to fetch correct data from website. Probably webpage markup has been changed, breaking the page custom parser."}if(!h)throw new r.BadResponse(a)}marketIds(t){if(void 0===t)return t;let e=[];for(let i=0;i<t.length;i++)e.push(this.marketId(t[i]));return e}currencyIds(t){if(void 0===t)return t;let e=[];for(let i=0;i<t.length;i++)e.push(this.currencyId(t[i]));return e}marketsForSymbols(t){if(void 0===t)return t;let e=[];for(let i=0;i<t.length;i++)e.push(this.market(t[i]));return e}marketSymbols(t,e,i=!0,s=!1,o=!1){let a,n;if(void 0===t||0===t.length){if(!i)throw new r.ArgumentsRequired(this.id+" empty list of symbols is not supported");return t}let h=[];for(let i=0;i<t.length;i++){let d=this.market(t[i]);if(s&&void 0!==a&&d.type!==a)throw new r.BadRequest(this.id+" symbols must be of the same type, either "+a+" or "+d.type+".");if(o&&void 0!==n&&d.linear!==n)throw new r.BadRequest(this.id+" symbols must be of the same subType, either linear or inverse.");if(void 0!==e&&d.type!==e)throw new r.BadRequest(this.id+" symbols must be of the same type "+e+". If the type is incorrect you can change it in options or the params of the request");a=d.type,d.spot||(n=d.linear);let c=this.safeString(d,"symbol",t[i]);h.push(c)}return h}marketCodes(t){if(void 0===t)return t;let e=[];for(let i=0;i<t.length;i++)e.push(this.commonCurrencyCode(t[i]));return e}parseBidsAsks(t,e=0,i=1,s=2){t=this.toArray(t);let r=[];for(let o=0;o<t.length;o++)r.push(this.parseBidAsk(t[o],e,i,s));return r}async fetchL2OrderBook(t,e,i={}){let s=await this.fetchOrderBook(t,e,i);return this.extend(s,{asks:this.sortBy(this.aggregate(s.asks),0),bids:this.sortBy(this.aggregate(s.bids),0,!0)})}filterBySymbol(t,e){if(void 0===e)return t;let i=[];for(let s=0;s<t.length;s++)this.safeString(t[s],"symbol")===e&&i.push(t[s]);return i}parseOHLCV(t,e){return Array.isArray(t)?[this.safeInteger(t,0),this.safeNumber(t,1),this.safeNumber(t,2),this.safeNumber(t,3),this.safeNumber(t,4),this.safeNumber(t,5)]:t}networkCodeToId(t,e){if(void 0===t)return;let i=this.safeValue(this.options,"networks",{}),s=this.safeString(i,t);if(void 0===s){if(void 0===e){let e=Object.values(this.currencies);for(let i=0;i<e.length;i++){let r=e[i],o=this.safeDict(r,"networks"),a=this.safeDict(o,t);if(void 0!==(s=this.safeString(a,"id")))break}}else{let r=this.safeValue(this.options,"defaultNetworkCodeReplacements",{});if(e in r){let o=r[e],a=Object.keys(o);for(let e=0;e<a.length;e++){let r=a[e];if(o[r]===t){s=this.safeString(i,r);break}}}else{let i=this.safeDict(this.currencies,e),r=this.safeDict(i,"networks"),o=this.safeDict(r,t);s=this.safeString(o,"id")}}void 0===s&&(s=t)}return s}networkIdToCode(t,e){if(void 0===t)return;let i=this.safeDict(this.options,"networksById",{}),s=this.safeString(i,t,t);if(void 0!==e){let t=this.safeDict(this.options,"defaultNetworkCodeReplacements",{});if(e in t){let i=this.safeDict(t,e,{});s=this.safeString(i,s,s)}}return s}handleNetworkCodeAndParams(t){let e=this.safeString2(t,"networkCode","network");return void 0!==e&&(t=this.omit(t,["networkCode","network"])),[e,t]}defaultNetworkCode(t){let e;let i=this.safeDict(this.options,"defaultNetworks",{});if(t in i)e=i[t];else{let t=this.safeString(this.options,"defaultNetwork");void 0!==t&&(e=t)}return e}selectNetworkCodeFromUnifiedNetworks(t,e,i){return this.selectNetworkKeyFromNetworks(t,e,i,!0)}selectNetworkIdFromRawNetworks(t,e,i){return this.selectNetworkKeyFromNetworks(t,e,i,!1)}selectNetworkKeyFromNetworks(t,e,i,s=!1){let o;let a=Object.keys(i),n=a.length;if(void 0!==e){if(0===n)throw new r.NotSupported(this.id+" - "+e+" network did not return any result for "+t);{let n=s?e:this.networkCodeToId(e,t);if(n in i)o=n;else throw new r.NotSupported(this.id+" - "+n+" network was not found for "+t+", use one of "+a.join(", "))}}else{if(0===n)throw new r.NotSupported(this.id+" - no networks were returned for "+t);{let e=this.defaultNetworkCode(t),r=s?e:this.networkCodeToId(e,t);o=r in i?r:a[0]}}return o}safeNumber2(t,e,i,s){let r=this.safeString2(t,e,i);return this.parseNumber(r,s)}parseOrderBook(t,e,i,s="bids",r="asks",o=0,a=1,n=2){let h=this.parseBidsAsks(this.safeValue(t,s,[]),o,a,n),d=this.parseBidsAsks(this.safeValue(t,r,[]),o,a,n);return{symbol:e,bids:this.sortBy(h,0,!0),asks:this.sortBy(d,0),timestamp:i,datetime:this.iso8601(i),nonce:void 0}}parseOHLCVs(t,e,i="1m",s,r,o=!1){let a=[];for(let i=0;i<t.length;i++)a.push(this.parseOHLCV(t[i],e));let n=this.sortBy(a,0);return this.filterBySinceLimit(n,s,r,0,o)}parseLeverageTiers(t,e,i){e=this.marketSymbols(e);let s={},r=0;void 0!==e&&(r=e.length);let o=void 0===e||0===r;if(Array.isArray(t))for(let r=0;r<t.length;r++){let a=t[r],n=this.safeString(a,i),h=this.safeMarket(n,void 0,void 0,"swap"),d=h.symbol;this.safeBool(h,"contract",!1)&&(o||this.inArray(d,e))&&(s[d]=this.parseMarketLeverageTiers(a,h))}else{let i=Object.keys(t);for(let r=0;r<i.length;r++){let a=i[r],n=t[a],h=this.safeMarket(a,void 0,void 0,"swap"),d=h.symbol;this.safeBool(h,"contract",!1)&&(o||this.inArray(d,e))&&(s[d]=this.parseMarketLeverageTiers(n,h))}}return s}async loadTradingLimits(t,e=!1,i={}){if(this.has.fetchTradingLimits&&(e||!("limitsLoaded"in this.options))){let e=await this.fetchTradingLimits(t);for(let i=0;i<t.length;i++){let s=t[i];this.markets[s]=this.deepExtend(this.markets[s],e[s])}this.options.limitsLoaded=this.milliseconds()}return this.markets}safePosition(t){let e;let i=this.safeString(t,"unrealisedPnl"),s=this.safeString(t,"initialMargin");if(void 0===this.safeValue(t,"percentage")&&void 0!==i&&void 0!==s){let e=o.Y.stringMul(o.Y.stringDiv(i,s,4),"100");t.percentage=this.parseNumber(e)}let r=this.safeNumber(t,"contractSize"),a=this.safeString(t,"symbol");return void 0!==a&&(e=this.safeValue(this.markets,a)),void 0===r&&void 0!==e&&(r=this.safeNumber(e,"contractSize"),t.contractSize=r),t}parsePositions(t,e,i={}){e=this.marketSymbols(e),t=this.toArray(t);let s=[];for(let e=0;e<t.length;e++){let r=this.extend(this.parsePosition(t[e],void 0),i);s.push(r)}return this.filterByArrayPositions(s,"symbol",e,!1)}parseAccounts(t,e={}){t=this.toArray(t);let i=[];for(let s=0;s<t.length;s++){let r=this.extend(this.parseAccount(t[s]),e);i.push(r)}return i}parseTrades(t,e,i,s,r={}){t=this.toArray(t);let o=[];for(let i=0;i<t.length;i++){let s=this.extend(this.parseTrade(t[i],e),r);o.push(s)}o=this.sortBy2(o,"timestamp","id");let a=void 0!==e?e.symbol:void 0;return this.filterBySymbolSinceLimit(o,a,i,s)}parseTransactions(t,e,i,s,r={}){t=this.toArray(t);let o=[];for(let i=0;i<t.length;i++){let s=this.extend(this.parseTransaction(t[i],e),r);o.push(s)}o=this.sortBy(o,"timestamp");let a=void 0!==e?e.code:void 0;return this.filterByCurrencySinceLimit(o,a,i,s)}parseTransfers(t,e,i,s,r={}){t=this.toArray(t);let o=[];for(let i=0;i<t.length;i++){let s=this.extend(this.parseTransfer(t[i],e),r);o.push(s)}o=this.sortBy(o,"timestamp");let a=void 0!==e?e.code:void 0;return this.filterByCurrencySinceLimit(o,a,i,s)}parseLedger(t,e,i,s,r={}){let o=[],a=this.toArray(t);for(let t=0;t<a.length;t++){let i=this.parseLedgerEntry(a[t],e);if(Array.isArray(i))for(let t=0;t<i.length;t++)o.push(this.extend(i[t],r));else o.push(this.extend(i,r))}o=this.sortBy(o,"timestamp");let n=void 0!==e?e.code:void 0;return this.filterByCurrencySinceLimit(o,n,i,s)}nonce(){return this.seconds()}setHeaders(t){return t}currencyId(t){let e=this.safeDict(this.currencies,t);return(void 0===e&&(e=this.safeCurrency(t)),void 0!==e)?e.id:t}marketId(t){let e=this.market(t);return void 0!==e?e.id:t}symbol(t){let e=this.market(t);return this.safeString(e,"symbol",t)}handleParamString(t,e,i){let s=this.safeString(t,e,i);return void 0!==s&&(t=this.omit(t,e)),[s,t]}handleParamString2(t,e,i,s){let r=this.safeString2(t,e,i,s);return void 0!==r&&(t=this.omit(t,[e,i])),[r,t]}handleParamInteger(t,e,i){let s=this.safeInteger(t,e,i);return void 0!==s&&(t=this.omit(t,e)),[s,t]}handleParamInteger2(t,e,i,s){let r=this.safeInteger2(t,e,i,s);return void 0!==r&&(t=this.omit(t,[e,i])),[r,t]}handleParamBool(t,e,i){let s=this.safeBool(t,e,i);return void 0!==s&&(t=this.omit(t,e)),[s,t]}handleParamBool2(t,e,i,s){let r=this.safeBool2(t,e,i,s);return void 0!==r&&(t=this.omit(t,[e,i])),[r,t]}resolvePath(t,e){return[this.implodeParams(t,e),this.omit(e,this.extractParams(t))]}getListFromObjectValues(t,e){let i=t;Array.isArray(t)||(i=this.toArray(t));let s=[];for(let t=0;t<i.length;t++)s.push(i[t][e]);return s}getSymbolsForMarketType(t,e,i=!0,s=!0){let r=this.markets;void 0!==t&&(r=this.filterBy(r,"type",t)),void 0!==e&&(this.checkRequiredArgument("getSymbolsForMarketType",e,"subType",["linear","inverse","quanto"]),r=this.filterBy(r,"subType",e));let o=[];return i&&o.push(!0),s&&o.push(void 0),r=this.filterByArray(r,"active",o,!1),this.getListFromObjectValues(r,"symbol")}filterByArray(t,e,i,s=!0){if(t=this.toArray(t),void 0===i||!i)return s?this.indexBy(t,e):t;let r=[];for(let s=0;s<t.length;s++)this.inArray(t[s][e],i)&&r.push(t[s]);return s?this.indexBy(r,e):r}async fetch2(t,e="public",i="GET",s={},o,a,n={}){let h,d;if(this.enableRateLimit){let r=this.calculateRateLimiterCost(e,i,t,s,n);await this.throttle(r)}this.lastRestRequestTimestamp=this.milliseconds();let c=this.sign(t,e,i,s,o,a);this.last_request_headers=c.headers,this.last_request_body=c.body,this.last_request_url=c.url,[h,s]=this.handleOptionAndParams(s,t,"maxRetriesOnFailure",0),[d,s]=this.handleOptionAndParams(s,t,"maxRetriesOnFailureDelay",0);for(let t=0;t<h+1;t++)try{return await this.fetch(c.url,c.method,c.headers,c.body)}catch(e){if(e instanceof r.NetworkError&&t<h){this.verbose&&this.log("Request failed with the error: "+e.toString()+", retrying "+(t+1).toString()+" of "+h.toString()+"..."),void 0!==d&&0!==d&&await this.sleep(d);continue}throw e}}async request(t,e="public",i="GET",s={},r,o,a={}){return await this.fetch2(t,e,i,s,r,o,a)}async loadAccounts(t=!1,e={}){if(t)this.accounts=await this.fetchAccounts(e);else{if(this.accounts)return this.accounts;this.accounts=await this.fetchAccounts(e)}return this.accountsById=this.indexBy(this.accounts,"id"),this.accounts}buildOHLCVC(t,e="1m",i=0,s=0x7fffffff){let r=1e3*this.parseTimeframe(e),o=[],a=Math.min(t.length,s);for(let e=0;e<a;e++){let s=t[e],a=s.timestamp;if(a<i)continue;let n=Math.floor(a/r)*r;if(n<i)continue;let h=o.length-1;-1===h||n>=this.sum(o[h][0],r)?o.push([n,s.price,s.price,s.price,s.price,s.amount,1]):(o[h][2]=Math.max(o[h][2],s.price),o[h][3]=Math.min(o[h][3],s.price),o[h][4]=s.price,o[h][5]=this.sum(o[h][5],s.amount),o[h][6]=this.sum(o[h][6],1))}return o}parseTradingViewOHLCV(t,e,i="1m",s,r){let o=this.convertTradingViewToOHLCV(t);return this.parseOHLCVs(o,e,i,s,r)}async editLimitBuyOrder(t,e,i,s,r={}){return await this.editLimitOrder(t,e,"buy",i,s,r)}async editLimitSellOrder(t,e,i,s,r={}){return await this.editLimitOrder(t,e,"sell",i,s,r)}async editLimitOrder(t,e,i,s,r,o={}){return await this.editOrder(t,e,"limit",i,s,r,o)}async editOrder(t,e,i,s,r,o,a={}){return await this.cancelOrder(t,e),await this.createOrder(e,i,s,r,o,a)}async editOrderWs(t,e,i,s,r,o,a={}){return await this.cancelOrderWs(t,e),await this.createOrderWs(e,i,s,r,o,a)}async fetchPosition(t,e={}){throw new r.NotSupported(this.id+" fetchPosition() is not supported yet")}async fetchPositionWs(t,e={}){throw new r.NotSupported(this.id+" fetchPositionWs() is not supported yet")}async watchPosition(t,e={}){throw new r.NotSupported(this.id+" watchPosition() is not supported yet")}async watchPositions(t,e,i,s={}){throw new r.NotSupported(this.id+" watchPositions() is not supported yet")}async watchPositionForSymbols(t,e,i,s={}){return await this.watchPositions(t,e,i,s)}async fetchPositionsForSymbol(t,e={}){throw new r.NotSupported(this.id+" fetchPositionsForSymbol() is not supported yet")}async fetchPositionsForSymbolWs(t,e={}){throw new r.NotSupported(this.id+" fetchPositionsForSymbol() is not supported yet")}async fetchPositions(t,e={}){throw new r.NotSupported(this.id+" fetchPositions() is not supported yet")}async fetchPositionsWs(t,e={}){throw new r.NotSupported(this.id+" fetchPositions() is not supported yet")}async fetchPositionsRisk(t,e={}){throw new r.NotSupported(this.id+" fetchPositionsRisk() is not supported yet")}async fetchBidsAsks(t,e={}){throw new r.NotSupported(this.id+" fetchBidsAsks() is not supported yet")}async fetchBorrowInterest(t,e,i,s,o={}){throw new r.NotSupported(this.id+" fetchBorrowInterest() is not supported yet")}async fetchLedger(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchLedger() is not supported yet")}async fetchLedgerEntry(t,e,i={}){throw new r.NotSupported(this.id+" fetchLedgerEntry() is not supported yet")}parseBidAsk(t,e=0,i=1,s=2){let r=this.safeNumber(t,e),o=this.safeNumber(t,i),a=this.safeInteger(t,s),n=[r,o];return void 0!==a&&n.push(a),n}safeCurrency(t,e){if(void 0===t&&void 0!==e)return e;if(void 0!==this.currencies_by_id&&t in this.currencies_by_id&&void 0!==this.currencies_by_id[t])return this.currencies_by_id[t];let i=t;return void 0!==t&&(i=this.commonCurrencyCode(t.toUpperCase())),this.safeCurrencyStructure({id:t,code:i,precision:void 0})}safeMarket(t,e,i,s){let o=this.safeMarketStructure({symbol:t,marketId:t});if(void 0!==t){if(void 0!==this.markets_by_id&&t in this.markets_by_id){let i=this.markets_by_id[t];if(1===i.length)return i[0];if(void 0===s){if(void 0===e)throw new r.ArgumentsRequired(this.id+" safeMarket() requires a fourth argument for "+t+" to disambiguate between different markets with the same market id");s=e.type}for(let t=0;t<i.length;t++){let e=i[t];if(e[s])return e}}else if(void 0!==i&&""!==i){let e=t.split(i);return 2===e.length&&(o.baseId=this.safeString(e,0),o.quoteId=this.safeString(e,1),o.base=this.safeCurrencyCode(o.baseId),o.quote=this.safeCurrencyCode(o.quoteId),o.symbol=o.base+"/"+o.quote),o}}return void 0!==e?e:o}checkRequiredCredentials(t=!0){let e=Object.keys(this.requiredCredentials);for(let i=0;i<e.length;i++){let s=e[i];if(this.requiredCredentials[s]&&!this[s]){if(!t)return!1;throw new r.AuthenticationError(this.id+' requires "'+s+'" credential')}}return!0}oath(){if(void 0!==this.twofa)return(0,c.A)(this.twofa);throw new r.ExchangeError(this.id+" exchange.twofa has not been set for 2FA Two-Factor Authentication")}async fetchBalance(t={}){throw new r.NotSupported(this.id+" fetchBalance() is not supported yet")}async fetchBalanceWs(t={}){throw new r.NotSupported(this.id+" fetchBalanceWs() is not supported yet")}parseBalance(t){throw new r.NotSupported(this.id+" parseBalance() is not supported yet")}async watchBalance(t={}){throw new r.NotSupported(this.id+" watchBalance() is not supported yet")}async fetchPartialBalance(t,e={}){return(await this.fetchBalance(e))[t]}async fetchFreeBalance(t={}){return await this.fetchPartialBalance("free",t)}async fetchUsedBalance(t={}){return await this.fetchPartialBalance("used",t)}async fetchTotalBalance(t={}){return await this.fetchPartialBalance("total",t)}async fetchStatus(t={}){throw new r.NotSupported(this.id+" fetchStatus() is not supported yet")}async fetchTransactionFee(t,e={}){if(!this.has.fetchTransactionFees)throw new r.NotSupported(this.id+" fetchTransactionFee() is not supported yet");return await this.fetchTransactionFees([t],e)}async fetchTransactionFees(t,e={}){throw new r.NotSupported(this.id+" fetchTransactionFees() is not supported yet")}async fetchDepositWithdrawFees(t,e={}){throw new r.NotSupported(this.id+" fetchDepositWithdrawFees() is not supported yet")}async fetchDepositWithdrawFee(t,e={}){if(!this.has.fetchDepositWithdrawFees)throw new r.NotSupported(this.id+" fetchDepositWithdrawFee() is not supported yet");let i=await this.fetchDepositWithdrawFees([t],e);return this.safeValue(i,t)}getSupportedMapping(t,e={}){if(t in e)return e[t];throw new r.NotSupported(this.id+" "+t+" does not have a value in mapping")}async fetchCrossBorrowRate(t,e={}){if(await this.loadMarkets(),!this.has.fetchBorrowRates)throw new r.NotSupported(this.id+" fetchCrossBorrowRate() is not supported yet");let i=await this.fetchCrossBorrowRates(e),s=this.safeValue(i,t);if(void 0===s)throw new r.ExchangeError(this.id+" fetchCrossBorrowRate() could not find the borrow rate for currency code "+t);return s}async fetchIsolatedBorrowRate(t,e={}){if(await this.loadMarkets(),!this.has.fetchBorrowRates)throw new r.NotSupported(this.id+" fetchIsolatedBorrowRate() is not supported yet");let i=await this.fetchIsolatedBorrowRates(e),s=this.safeDict(i,t);if(void 0===s)throw new r.ExchangeError(this.id+" fetchIsolatedBorrowRate() could not find the borrow rate for market symbol "+t);return s}handleOptionAndParams(t,e,i,s){let r="default"+this.capitalize(i),o=this.safeValue2(t,i,r);if(void 0!==o)t=this.omit(t,[i,r]);else{[e,t]=this.handleParamString(t,"callerMethodName",e);let a=this.safeValue(this.options,e);void 0!==a&&(o=this.safeValue2(a,i,r)),void 0===o&&(o=this.safeValue2(this.options,i,r)),o=void 0!==o?o:s}return[o,t]}handleOptionAndParams2(t,e,i,s,r){let o,a;return([o,t]=this.handleOptionAndParams(t,e,i),void 0!==o)?[o,t=this.omit(t,s)]:([a,t]=this.handleOptionAndParams(t,e,s,r),[a,t])}handleOption(t,e,i){let[s,r]=this.handleOptionAndParams({},t,e,i);return s}handleMarketTypeAndParams(t,e,i={},s){let r=this.safeString2(this.options,"defaultType","type","spot");void 0===s&&(s=r);let o=this.safeDict(this.options,t),a=s;void 0!==o&&(a="string"==typeof o?o:this.safeString2(o,"defaultType","type",a));let n=void 0===e?a:e.type;return[this.safeString2(i,"defaultType","type",n),i=this.omit(i,["defaultType","type"])]}handleSubTypeAndParams(t,e,i={},s){let r;let o=this.safeString2(i,"subType","defaultSubType");return void 0!==o?(r=o,i=this.omit(i,["subType","defaultSubType"])):(void 0!==e&&(e.linear?r="linear":e.inverse&&(r="inverse")),void 0===r&&(r=this.handleOptionAndParams({},t,"subType",s)[0])),[r,i]}handleMarginModeAndParams(t,e={},i){return this.handleOptionAndParams(e,t,"marginMode",i)}throwExactlyMatchedException(t,e,i){if(void 0!==e&&e in t)throw new t[e](i)}throwBroadlyMatchedException(t,e,i){let s=this.findBroadlyMatchedKey(t,e);if(void 0!==s)throw new t[s](i)}findBroadlyMatchedKey(t,e){let i=Object.keys(t);for(let t=0;t<i.length;t++){let s=i[t];if(void 0!==e&&e.indexOf(s)>=0)return s}}handleErrors(t,e,i,s,r,o,a,n,h){}calculateRateLimiterCost(t,e,i,s,r={}){return this.safeValue(r,"cost",1)}async fetchTicker(t,e={}){if(this.has.fetchTickers){await this.loadMarkets(),t=this.market(t).symbol;let i=await this.fetchTickers([t],e),s=this.safeDict(i,t);if(void 0!==s)return s;throw new r.NullResponse(this.id+" fetchTickers() could not find a ticker for "+t)}throw new r.NotSupported(this.id+" fetchTicker() is not supported yet")}async fetchMarkPrice(t,e={}){if(this.has.fetchMarkPrices){await this.loadMarkets(),t=this.market(t).symbol;let i=await this.fetchMarkPrices([t],e),s=this.safeDict(i,t);if(void 0!==s)return s;throw new r.NullResponse(this.id+" fetchMarkPrices() could not find a ticker for "+t)}throw new r.NotSupported(this.id+" fetchMarkPrices() is not supported yet")}async fetchTickerWs(t,e={}){if(this.has.fetchTickersWs){await this.loadMarkets(),t=this.market(t).symbol;let i=await this.fetchTickersWs([t],e),s=this.safeDict(i,t);if(void 0!==s)return s;throw new r.NullResponse(this.id+" fetchTickerWs() could not find a ticker for "+t)}throw new r.NotSupported(this.id+" fetchTickerWs() is not supported yet")}async watchTicker(t,e={}){throw new r.NotSupported(this.id+" watchTicker() is not supported yet")}async fetchTickers(t,e={}){throw new r.NotSupported(this.id+" fetchTickers() is not supported yet")}async fetchMarkPrices(t,e={}){throw new r.NotSupported(this.id+" fetchMarkPrices() is not supported yet")}async fetchTickersWs(t,e={}){throw new r.NotSupported(this.id+" fetchTickers() is not supported yet")}async fetchOrderBooks(t,e,i={}){throw new r.NotSupported(this.id+" fetchOrderBooks() is not supported yet")}async watchBidsAsks(t,e={}){throw new r.NotSupported(this.id+" watchBidsAsks() is not supported yet")}async watchTickers(t,e={}){throw new r.NotSupported(this.id+" watchTickers() is not supported yet")}async unWatchTickers(t,e={}){throw new r.NotSupported(this.id+" unWatchTickers() is not supported yet")}async fetchOrder(t,e,i={}){throw new r.NotSupported(this.id+" fetchOrder() is not supported yet")}async fetchOrderWs(t,e,i={}){throw new r.NotSupported(this.id+" fetchOrderWs() is not supported yet")}async fetchOrderStatus(t,e,i={}){return(await this.fetchOrder(t,e,i)).status}async fetchUnifiedOrder(t,e={}){return await this.fetchOrder(this.safeString(t,"id"),this.safeString(t,"symbol"),e)}async createOrder(t,e,i,s,o,a={}){throw new r.NotSupported(this.id+" createOrder() is not supported yet")}async createTrailingAmountOrder(t,e,i,s,o,a,n,h={}){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createTrailingAmountOrder() requires a trailingAmount argument");if(h.trailingAmount=a,void 0!==n&&(h.trailingTriggerPrice=n),this.has.createTrailingAmountOrder)return await this.createOrder(t,e,i,s,o,h);throw new r.NotSupported(this.id+" createTrailingAmountOrder() is not supported yet")}async createTrailingAmountOrderWs(t,e,i,s,o,a,n,h={}){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createTrailingAmountOrderWs() requires a trailingAmount argument");if(h.trailingAmount=a,void 0!==n&&(h.trailingTriggerPrice=n),this.has.createTrailingAmountOrderWs)return await this.createOrderWs(t,e,i,s,o,h);throw new r.NotSupported(this.id+" createTrailingAmountOrderWs() is not supported yet")}async createTrailingPercentOrder(t,e,i,s,o,a,n,h={}){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createTrailingPercentOrder() requires a trailingPercent argument");if(h.trailingPercent=a,void 0!==n&&(h.trailingTriggerPrice=n),this.has.createTrailingPercentOrder)return await this.createOrder(t,e,i,s,o,h);throw new r.NotSupported(this.id+" createTrailingPercentOrder() is not supported yet")}async createTrailingPercentOrderWs(t,e,i,s,o,a,n,h={}){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createTrailingPercentOrderWs() requires a trailingPercent argument");if(h.trailingPercent=a,void 0!==n&&(h.trailingTriggerPrice=n),this.has.createTrailingPercentOrderWs)return await this.createOrderWs(t,e,i,s,o,h);throw new r.NotSupported(this.id+" createTrailingPercentOrderWs() is not supported yet")}async createMarketOrderWithCost(t,e,i,s={}){if(this.has.createMarketOrderWithCost||this.has.createMarketBuyOrderWithCost&&this.has.createMarketSellOrderWithCost)return await this.createOrder(t,"market",e,i,1,s);throw new r.NotSupported(this.id+" createMarketOrderWithCost() is not supported yet")}async createMarketBuyOrderWithCost(t,e,i={}){if(this.options.createMarketBuyOrderRequiresPrice||this.has.createMarketBuyOrderWithCost)return await this.createOrder(t,"market","buy",e,1,i);throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() is not supported yet")}async createMarketSellOrderWithCost(t,e,i={}){if(this.options.createMarketSellOrderRequiresPrice||this.has.createMarketSellOrderWithCost)return await this.createOrder(t,"market","sell",e,1,i);throw new r.NotSupported(this.id+" createMarketSellOrderWithCost() is not supported yet")}async createMarketOrderWithCostWs(t,e,i,s={}){if(this.has.createMarketOrderWithCostWs||this.has.createMarketBuyOrderWithCostWs&&this.has.createMarketSellOrderWithCostWs)return await this.createOrderWs(t,"market",e,i,1,s);throw new r.NotSupported(this.id+" createMarketOrderWithCostWs() is not supported yet")}async createTriggerOrder(t,e,i,s,o,a,n={}){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createTriggerOrder() requires a triggerPrice argument");if(n.triggerPrice=a,this.has.createTriggerOrder)return await this.createOrder(t,e,i,s,o,n);throw new r.NotSupported(this.id+" createTriggerOrder() is not supported yet")}async createTriggerOrderWs(t,e,i,s,o,a,n={}){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createTriggerOrderWs() requires a triggerPrice argument");if(n.triggerPrice=a,this.has.createTriggerOrderWs)return await this.createOrderWs(t,e,i,s,o,n);throw new r.NotSupported(this.id+" createTriggerOrderWs() is not supported yet")}async createStopLossOrder(t,e,i,s,o,a,n={}){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createStopLossOrder() requires a stopLossPrice argument");if(n.stopLossPrice=a,this.has.createStopLossOrder)return await this.createOrder(t,e,i,s,o,n);throw new r.NotSupported(this.id+" createStopLossOrder() is not supported yet")}async createStopLossOrderWs(t,e,i,s,o,a,n={}){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createStopLossOrderWs() requires a stopLossPrice argument");if(n.stopLossPrice=a,this.has.createStopLossOrderWs)return await this.createOrderWs(t,e,i,s,o,n);throw new r.NotSupported(this.id+" createStopLossOrderWs() is not supported yet")}async createTakeProfitOrder(t,e,i,s,o,a,n={}){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createTakeProfitOrder() requires a takeProfitPrice argument");if(n.takeProfitPrice=a,this.has.createTakeProfitOrder)return await this.createOrder(t,e,i,s,o,n);throw new r.NotSupported(this.id+" createTakeProfitOrder() is not supported yet")}async createTakeProfitOrderWs(t,e,i,s,o,a,n={}){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createTakeProfitOrderWs() requires a takeProfitPrice argument");if(n.takeProfitPrice=a,this.has.createTakeProfitOrderWs)return await this.createOrderWs(t,e,i,s,o,n);throw new r.NotSupported(this.id+" createTakeProfitOrderWs() is not supported yet")}async createOrderWithTakeProfitAndStopLoss(t,e,i,s,o,a,n,h={}){if(h=this.setTakeProfitAndStopLossParams(t,e,i,s,o,a,n,h),this.has.createOrderWithTakeProfitAndStopLoss)return await this.createOrder(t,e,i,s,o,h);throw new r.NotSupported(this.id+" createOrderWithTakeProfitAndStopLoss() is not supported yet")}setTakeProfitAndStopLossParams(t,e,i,s,o,a,n,h={}){if(void 0===a&&void 0===n)throw new r.ArgumentsRequired(this.id+" createOrderWithTakeProfitAndStopLoss() requires either a takeProfit or stopLoss argument");void 0!==a&&(h.takeProfit={triggerPrice:a}),void 0!==n&&(h.stopLoss={triggerPrice:n});let d=this.safeString(h,"takeProfitType"),c=this.safeString(h,"takeProfitPriceType"),p=this.safeString(h,"takeProfitLimitPrice"),l=this.safeString(h,"takeProfitAmount"),u=this.safeString(h,"stopLossType"),f=this.safeString(h,"stopLossPriceType"),y=this.safeString(h,"stopLossLimitPrice"),m=this.safeString(h,"stopLossAmount");return void 0!==d&&(h.takeProfit.type=d),void 0!==c&&(h.takeProfit.priceType=c),void 0!==p&&(h.takeProfit.price=this.parseToNumeric(p)),void 0!==l&&(h.takeProfit.amount=this.parseToNumeric(l)),void 0!==u&&(h.stopLoss.type=u),void 0!==f&&(h.stopLoss.priceType=f),void 0!==y&&(h.stopLoss.price=this.parseToNumeric(y)),void 0!==m&&(h.stopLoss.amount=this.parseToNumeric(m)),h=this.omit(h,["takeProfitType","takeProfitPriceType","takeProfitLimitPrice","takeProfitAmount","stopLossType","stopLossPriceType","stopLossLimitPrice","stopLossAmount"])}async createOrderWithTakeProfitAndStopLossWs(t,e,i,s,o,a,n,h={}){if(h=this.setTakeProfitAndStopLossParams(t,e,i,s,o,a,n,h),this.has.createOrderWithTakeProfitAndStopLossWs)return await this.createOrderWs(t,e,i,s,o,h);throw new r.NotSupported(this.id+" createOrderWithTakeProfitAndStopLossWs() is not supported yet")}async createOrders(t,e={}){throw new r.NotSupported(this.id+" createOrders() is not supported yet")}async createOrderWs(t,e,i,s,o,a={}){throw new r.NotSupported(this.id+" createOrderWs() is not supported yet")}async cancelOrder(t,e,i={}){throw new r.NotSupported(this.id+" cancelOrder() is not supported yet")}async cancelOrderWs(t,e,i={}){throw new r.NotSupported(this.id+" cancelOrderWs() is not supported yet")}async cancelOrdersWs(t,e,i={}){throw new r.NotSupported(this.id+" cancelOrdersWs() is not supported yet")}async cancelAllOrders(t,e={}){throw new r.NotSupported(this.id+" cancelAllOrders() is not supported yet")}async cancelAllOrdersAfter(t,e={}){throw new r.NotSupported(this.id+" cancelAllOrdersAfter() is not supported yet")}async cancelOrdersForSymbols(t,e={}){throw new r.NotSupported(this.id+" cancelOrdersForSymbols() is not supported yet")}async cancelAllOrdersWs(t,e={}){throw new r.NotSupported(this.id+" cancelAllOrdersWs() is not supported yet")}async cancelUnifiedOrder(t,e={}){return this.cancelOrder(this.safeString(t,"id"),this.safeString(t,"symbol"),e)}async fetchOrders(t,e,i,s={}){if(this.has.fetchOpenOrders&&this.has.fetchClosedOrders)throw new r.NotSupported(this.id+" fetchOrders() is not supported yet, consider using fetchOpenOrders() and fetchClosedOrders() instead");throw new r.NotSupported(this.id+" fetchOrders() is not supported yet")}async fetchOrdersWs(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchOrdersWs() is not supported yet")}async fetchOrderTrades(t,e,i,s,o={}){throw new r.NotSupported(this.id+" fetchOrderTrades() is not supported yet")}async watchOrders(t,e,i,s={}){throw new r.NotSupported(this.id+" watchOrders() is not supported yet")}async fetchOpenOrders(t,e,i,s={}){if(this.has.fetchOrders){let r=await this.fetchOrders(t,e,i,s);return this.filterBy(r,"status","open")}throw new r.NotSupported(this.id+" fetchOpenOrders() is not supported yet")}async fetchOpenOrdersWs(t,e,i,s={}){if(this.has.fetchOrdersWs){let r=await this.fetchOrdersWs(t,e,i,s);return this.filterBy(r,"status","open")}throw new r.NotSupported(this.id+" fetchOpenOrdersWs() is not supported yet")}async fetchClosedOrders(t,e,i,s={}){if(this.has.fetchOrders){let r=await this.fetchOrders(t,e,i,s);return this.filterBy(r,"status","closed")}throw new r.NotSupported(this.id+" fetchClosedOrders() is not supported yet")}async fetchCanceledAndClosedOrders(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchCanceledAndClosedOrders() is not supported yet")}async fetchClosedOrdersWs(t,e,i,s={}){if(this.has.fetchOrdersWs){let r=await this.fetchOrdersWs(t,e,i,s);return this.filterBy(r,"status","closed")}throw new r.NotSupported(this.id+" fetchClosedOrdersWs() is not supported yet")}async fetchMyTrades(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchMyTrades() is not supported yet")}async fetchMyLiquidations(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchMyLiquidations() is not supported yet")}async fetchLiquidations(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchLiquidations() is not supported yet")}async fetchMyTradesWs(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchMyTradesWs() is not supported yet")}async watchMyTrades(t,e,i,s={}){throw new r.NotSupported(this.id+" watchMyTrades() is not supported yet")}async fetchGreeks(t,e={}){throw new r.NotSupported(this.id+" fetchGreeks() is not supported yet")}async fetchOptionChain(t,e={}){throw new r.NotSupported(this.id+" fetchOptionChain() is not supported yet")}async fetchOption(t,e={}){throw new r.NotSupported(this.id+" fetchOption() is not supported yet")}async fetchConvertQuote(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchConvertQuote() is not supported yet")}async fetchDepositsWithdrawals(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchDepositsWithdrawals() is not supported yet")}async fetchDeposits(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchDeposits() is not supported yet")}async fetchWithdrawals(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchWithdrawals() is not supported yet")}async fetchDepositsWs(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchDepositsWs() is not supported yet")}async fetchWithdrawalsWs(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchWithdrawalsWs() is not supported yet")}async fetchFundingRateHistory(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchFundingRateHistory() is not supported yet")}async fetchFundingHistory(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchFundingHistory() is not supported yet")}async closePosition(t,e,i={}){throw new r.NotSupported(this.id+" closePosition() is not supported yet")}async closeAllPositions(t={}){throw new r.NotSupported(this.id+" closeAllPositions() is not supported yet")}async fetchL3OrderBook(t,e,i={}){throw new r.BadRequest(this.id+" fetchL3OrderBook() is not supported yet")}parseLastPrice(t,e){throw new r.NotSupported(this.id+" parseLastPrice() is not supported yet")}async fetchDepositAddress(t,e={}){if(this.has.fetchDepositAddresses){let i=await this.fetchDepositAddresses([t],e),s=this.safeValue(i,t);if(void 0!==s)return s;throw new r.InvalidAddress(this.id+" fetchDepositAddress() could not find a deposit address for "+t+", make sure you have created a corresponding deposit address in your wallet on the exchange website")}if(this.has.fetchDepositAddressesByNetwork){let i=this.safeString(e,"network");e=this.omit(e,"network");let s=await this.fetchDepositAddressesByNetwork(t,e);if(void 0!==i)return this.safeDict(s,i);{let t=Object.keys(s),e=this.safeString(t,0);return this.safeDict(s,e)}}throw new r.NotSupported(this.id+" fetchDepositAddress() is not supported yet")}account(){return{free:void 0,used:void 0,total:void 0}}commonCurrencyCode(t){return this.substituteCommonCurrencyCodes?this.safeString(this.commonCurrencies,t,t):t}currency(t){if(void 0===this.currencies)throw new r.ExchangeError(this.id+" currencies not loaded");if("string"==typeof t){if(t in this.currencies)return this.currencies[t];if(t in this.currencies_by_id)return this.currencies_by_id[t]}throw new r.ExchangeError(this.id+" does not have currency code "+t)}market(t){if(void 0===this.markets)throw new r.ExchangeError(this.id+" markets not loaded");if(t in this.markets)return this.markets[t];if(t in this.markets_by_id){let e=this.markets_by_id[t],i=this.safeString2(this.options,"defaultType","defaultSubType","spot");for(let t=0;t<e.length;t++){let s=e[t];if(s[i])return s}return e[0]}if(t.endsWith("-C")||t.endsWith("-P")||t.startsWith("C-")||t.startsWith("P-"))return this.createExpiredOptionMarket(t);throw new r.BadSymbol(this.id+" does not have market symbol "+t)}createExpiredOptionMarket(t){throw new r.NotSupported(this.id+" createExpiredOptionMarket () is not supported yet")}handleWithdrawTagAndParams(t,e){return void 0!==t&&"object"==typeof t&&(e=this.extend(t,e),t=void 0),void 0===t&&void 0!==(t=this.safeString(e,"tag"))&&(e=this.omit(e,"tag")),[t,e]}async createLimitOrder(t,e,i,s,r={}){return await this.createOrder(t,"limit",e,i,s,r)}async createLimitOrderWs(t,e,i,s,r={}){return await this.createOrderWs(t,"limit",e,i,s,r)}async createMarketOrder(t,e,i,s,r={}){return await this.createOrder(t,"market",e,i,s,r)}async createMarketOrderWs(t,e,i,s,r={}){return await this.createOrderWs(t,"market",e,i,s,r)}async createLimitBuyOrder(t,e,i,s={}){return await this.createOrder(t,"limit","buy",e,i,s)}async createLimitBuyOrderWs(t,e,i,s={}){return await this.createOrderWs(t,"limit","buy",e,i,s)}async createLimitSellOrder(t,e,i,s={}){return await this.createOrder(t,"limit","sell",e,i,s)}async createLimitSellOrderWs(t,e,i,s={}){return await this.createOrderWs(t,"limit","sell",e,i,s)}async createMarketBuyOrder(t,e,i={}){return await this.createOrder(t,"market","buy",e,void 0,i)}async createMarketBuyOrderWs(t,e,i={}){return await this.createOrderWs(t,"market","buy",e,void 0,i)}async createMarketSellOrder(t,e,i={}){return await this.createOrder(t,"market","sell",e,void 0,i)}async createMarketSellOrderWs(t,e,i={}){return await this.createOrderWs(t,"market","sell",e,void 0,i)}costToPrecision(t,e){let i=this.market(t);return this.decimalToPrecision(e,t8,i.precision.price,this.precisionMode,this.paddingMode)}priceToPrecision(t,e){let i=this.market(t),s=this.decimalToPrecision(e,t9,i.precision.price,this.precisionMode,this.paddingMode);if("0"===s)throw new r.InvalidOrder(this.id+" price of "+i.symbol+" must be greater than minimum price precision of "+this.numberToString(i.precision.price));return s}amountToPrecision(t,e){let i=this.market(t),s=this.decimalToPrecision(e,t8,i.precision.amount,this.precisionMode,this.paddingMode);if("0"===s)throw new r.InvalidOrder(this.id+" amount of "+i.symbol+" must be greater than minimum amount precision of "+this.numberToString(i.precision.amount));return s}feeToPrecision(t,e){let i=this.market(t);return this.decimalToPrecision(e,t9,i.precision.price,this.precisionMode,this.paddingMode)}currencyToPrecision(t,e,i){let s=this.currencies[t],r=this.safeValue(s,"precision");if(void 0!==i){let t=this.safeDict(s,"networks",{}),e=this.safeDict(t,i,{});r=this.safeValue(e,"precision",r)}if(void 0===r)return this.forceString(e);{let t=this.safeInteger(this.options,"currencyToPrecisionRoundingMode",t9);return this.decimalToPrecision(e,t,r,this.precisionMode,this.paddingMode)}}forceString(t){return"string"!=typeof t?this.numberToString(t):t}isTickPrecision(){return this.precisionMode===ei}isDecimalPrecision(){return this.precisionMode===et}isSignificantPrecision(){return this.precisionMode===es}safeNumber(t,e,i){let s=this.safeString(t,e);return this.parseNumber(s,i)}safeNumberN(t,e,i){let s=this.safeStringN(t,e);return this.parseNumber(s,i)}parsePrecision(t){if(void 0===t)return;let e=parseInt(t);if(0===e)return"1";let i="0.";for(let t=0;t<e-1;t++)i+="0";return i+"1"}integerPrecisionToAmount(t){if(void 0!==t){if(o.Y.stringGe(t,"0"))return this.parsePrecision(t);{let e=parseInt(o.Y.stringAbs(t)),i="1";for(let t=0;t<e-1;t++)i+="0";return i+"0"}}}async loadTimeDifference(t={}){let e=await this.fetchTime(t),i=this.milliseconds();return this.options.timeDifference=i-e,this.options.timeDifference}implodeHostname(t){return this.implodeParams(t,{hostname:this.hostname})}async fetchMarketLeverageTiers(t,e={}){if(this.has.fetchLeverageTiers){if(!this.market(t).contract)throw new r.BadSymbol(this.id+" fetchMarketLeverageTiers() supports contract markets only");let e=await this.fetchLeverageTiers([t]);return this.safeValue(e,t)}throw new r.NotSupported(this.id+" fetchMarketLeverageTiers() is not supported yet")}async createPostOnlyOrder(t,e,i,s,o,a={}){if(!this.has.createPostOnlyOrder)throw new r.NotSupported(this.id+"createPostOnlyOrder() is not supported yet");let n=this.extend(a,{postOnly:!0});return await this.createOrder(t,e,i,s,o,n)}async createPostOnlyOrderWs(t,e,i,s,o,a={}){if(!this.has.createPostOnlyOrderWs)throw new r.NotSupported(this.id+"createPostOnlyOrderWs() is not supported yet");let n=this.extend(a,{postOnly:!0});return await this.createOrderWs(t,e,i,s,o,n)}async createReduceOnlyOrder(t,e,i,s,o,a={}){if(!this.has.createReduceOnlyOrder)throw new r.NotSupported(this.id+"createReduceOnlyOrder() is not supported yet");let n=this.extend(a,{reduceOnly:!0});return await this.createOrder(t,e,i,s,o,n)}async createReduceOnlyOrderWs(t,e,i,s,o,a={}){if(!this.has.createReduceOnlyOrderWs)throw new r.NotSupported(this.id+"createReduceOnlyOrderWs() is not supported yet");let n=this.extend(a,{reduceOnly:!0});return await this.createOrderWs(t,e,i,s,o,n)}async createStopOrder(t,e,i,s,o,a,n={}){if(!this.has.createStopOrder)throw new r.NotSupported(this.id+" createStopOrder() is not supported yet");if(void 0===a)throw new r.ArgumentsRequired(this.id+" create_stop_order() requires a stopPrice argument");let h=this.extend(n,{stopPrice:a});return await this.createOrder(t,e,i,s,o,h)}async createStopOrderWs(t,e,i,s,o,a,n={}){if(!this.has.createStopOrderWs)throw new r.NotSupported(this.id+" createStopOrderWs() is not supported yet");if(void 0===a)throw new r.ArgumentsRequired(this.id+" createStopOrderWs() requires a stopPrice argument");let h=this.extend(n,{stopPrice:a});return await this.createOrderWs(t,e,i,s,o,h)}async createStopLimitOrder(t,e,i,s,o,a={}){if(!this.has.createStopLimitOrder)throw new r.NotSupported(this.id+" createStopLimitOrder() is not supported yet");let n=this.extend(a,{stopPrice:o});return await this.createOrder(t,"limit",e,i,s,n)}async createStopLimitOrderWs(t,e,i,s,o,a={}){if(!this.has.createStopLimitOrderWs)throw new r.NotSupported(this.id+" createStopLimitOrderWs() is not supported yet");let n=this.extend(a,{stopPrice:o});return await this.createOrderWs(t,"limit",e,i,s,n)}async createStopMarketOrder(t,e,i,s,o={}){if(!this.has.createStopMarketOrder)throw new r.NotSupported(this.id+" createStopMarketOrder() is not supported yet");let a=this.extend(o,{stopPrice:s});return await this.createOrder(t,"market",e,i,void 0,a)}async createStopMarketOrderWs(t,e,i,s,o={}){if(!this.has.createStopMarketOrderWs)throw new r.NotSupported(this.id+" createStopMarketOrderWs() is not supported yet");let a=this.extend(o,{stopPrice:s});return await this.createOrderWs(t,"market",e,i,void 0,a)}safeCurrencyCode(t,e){return(e=this.safeCurrency(t,e)).code}filterBySymbolSinceLimit(t,e,i,s,r=!1){return this.filterByValueSinceLimit(t,"symbol",e,i,s,"timestamp",r)}filterByCurrencySinceLimit(t,e,i,s,r=!1){return this.filterByValueSinceLimit(t,"currency",e,i,s,"timestamp",r)}filterBySymbolsSinceLimit(t,e,i,s,r=!1){let o=this.filterByArray(t,"symbol",e,!1);return this.filterBySinceLimit(o,i,s,"timestamp",r)}parseLastPrices(t,e,i={}){let s=[];if(Array.isArray(t))for(let e=0;e<t.length;e++){let r=this.extend(this.parseLastPrice(t[e]),i);s.push(r)}else{let e=Object.keys(t);for(let r=0;r<e.length;r++){let o=e[r],a=this.safeMarket(o),n=this.extend(this.parseLastPrice(t[o],a),i);s.push(n)}}return e=this.marketSymbols(e),this.filterByArray(s,"symbol",e)}parseTickers(t,e,i={}){let s=[];if(Array.isArray(t))for(let e=0;e<t.length;e++){let r=this.extend(this.parseTicker(t[e]),i);s.push(r)}else{let e=Object.keys(t);for(let r=0;r<e.length;r++){let o=e[r],a=this.safeMarket(o),n=this.extend(this.parseTicker(t[o],a),i);s.push(n)}}return e=this.marketSymbols(e),this.filterByArray(s,"symbol",e)}parseDepositAddresses(t,e,i=!0,s={}){let r=[];for(let e=0;e<t.length;e++){let i=this.extend(this.parseDepositAddress(t[e]),s);r.push(i)}return void 0!==e&&(r=this.filterByArray(r,"currency",e,!1)),i&&(r=this.filterByArray(r,"currency",void 0,i)),r}parseBorrowInterests(t,e){let i=[];for(let s=0;s<t.length;s++){let r=t[s];i.push(this.parseBorrowInterest(r,e))}return i}parseBorrowRate(t,e){throw new r.NotSupported(this.id+" parseBorrowRate() is not supported yet")}parseBorrowRateHistory(t,e,i,s){let r=[];for(let e=0;e<t.length;e++){let i=t[e],s=this.parseBorrowRate(i);r.push(s)}let o=this.sortBy(r,"timestamp");return this.filterByCurrencySinceLimit(o,e,i,s)}parseIsolatedBorrowRates(t){let e={};for(let i=0;i<t.length;i++){let s=t[i],r=this.parseIsolatedBorrowRate(s);e[this.safeString(r,"symbol")]=r}return e}parseFundingRateHistories(t,e,i,s){let r=[];for(let i=0;i<t.length;i++){let s=t[i];r.push(this.parseFundingRateHistory(s,e))}let o=this.sortBy(r,"timestamp"),a=void 0===e?void 0:e.symbol;return this.filterBySymbolSinceLimit(o,a,i,s)}safeSymbol(t,e,i,s){return(e=this.safeMarket(t,e,i,s)).symbol}parseFundingRate(t,e){throw new r.NotSupported(this.id+" parseFundingRate() is not supported yet")}parseFundingRates(t,e){let i={};for(let e=0;e<t.length;e++){let s=t[e],r=this.parseFundingRate(s);i[r.symbol]=r}return this.filterByArray(i,"symbol",e)}parseLongShortRatio(t,e){throw new r.NotSupported(this.id+" parseLongShortRatio() is not supported yet")}parseLongShortRatioHistory(t,e,i,s){let r=[];for(let i=0;i<t.length;i++){let s=t[i];r.push(this.parseLongShortRatio(s,e))}let o=this.sortBy(r,"timestamp"),a=void 0===e?void 0:e.symbol;return this.filterBySymbolSinceLimit(o,a,i,s)}handleTriggerAndParams(t){let e=this.safeBool2(t,"trigger","stop");return e&&(t=this.omit(t,["trigger","stop"])),[e,t]}isTriggerOrder(t){return this.handleTriggerAndParams(t)}isPostOnly(t,e,i={}){let s=this.safeStringUpper(i,"timeInForce"),o=this.safeBool2(i,"postOnly","post_only",!1);if(!(o=o||"PO"===s||e))return!1;if("IOC"===s||"FOK"===s)throw new r.InvalidOrder(this.id+" postOnly orders cannot have timeInForce equal to "+s);if(!t)return!0;throw new r.InvalidOrder(this.id+" market orders cannot be postOnly")}handlePostOnly(t,e,i={}){let s=this.safeStringUpper(i,"timeInForce"),o=this.safeBool(i,"postOnly",!1),a="PO"===s;if(o=o||a||e){if("IOC"===s||"FOK"===s)throw new r.InvalidOrder(this.id+" postOnly orders cannot have timeInForce equal to "+s);if(!t)return a&&(i=this.omit(i,"timeInForce")),[!0,i=this.omit(i,"postOnly")];throw new r.InvalidOrder(this.id+" market orders cannot be postOnly")}return[!1,i]}async fetchLastPrices(t,e={}){throw new r.NotSupported(this.id+" fetchLastPrices() is not supported yet")}async fetchTradingFees(t={}){throw new r.NotSupported(this.id+" fetchTradingFees() is not supported yet")}async fetchTradingFeesWs(t={}){throw new r.NotSupported(this.id+" fetchTradingFeesWs() is not supported yet")}async fetchTradingFee(t,e={}){if(!this.has.fetchTradingFees)throw new r.NotSupported(this.id+" fetchTradingFee() is not supported yet");let i=await this.fetchTradingFees(e);return this.safeDict(i,t)}async fetchConvertCurrencies(t={}){throw new r.NotSupported(this.id+" fetchConvertCurrencies() is not supported yet")}parseOpenInterest(t,e){throw new r.NotSupported(this.id+" parseOpenInterest () is not supported yet")}parseOpenInterests(t,e){let i={};for(let e=0;e<t.length;e++){let s=t[e],r=this.parseOpenInterest(s);i[r.symbol]=r}return this.filterByArray(i,"symbol",e)}parseOpenInterestsHistory(t,e,i,s){let r=[];for(let i=0;i<t.length;i++){let s=t[i],o=this.parseOpenInterest(s,e);r.push(o)}let o=this.sortBy(r,"timestamp"),a=this.safeString(e,"symbol");return this.filterBySymbolSinceLimit(o,a,i,s)}async fetchFundingRate(t,e={}){if(this.has.fetchFundingRates){await this.loadMarkets();let i=this.market(t);if(t=i.symbol,!i.contract)throw new r.BadSymbol(this.id+" fetchFundingRate() supports contract markets only");let s=await this.fetchFundingRates([t],e),o=this.safeValue(s,t);if(void 0!==o)return o;throw new r.NullResponse(this.id+" fetchFundingRate () returned no data for "+t)}throw new r.NotSupported(this.id+" fetchFundingRate () is not supported yet")}async fetchFundingInterval(t,e={}){if(this.has.fetchFundingIntervals){await this.loadMarkets();let i=this.market(t);if(t=i.symbol,!i.contract)throw new r.BadSymbol(this.id+" fetchFundingInterval() supports contract markets only");let s=await this.fetchFundingIntervals([t],e),o=this.safeValue(s,t);if(void 0!==o)return o;throw new r.NullResponse(this.id+" fetchFundingInterval() returned no data for "+t)}throw new r.NotSupported(this.id+" fetchFundingInterval() is not supported yet")}async fetchMarkOHLCV(t,e="1m",i,s,o={}){if(this.has.fetchMarkOHLCV)return await this.fetchOHLCV(t,e,i,s,this.extend({price:"mark"},o));throw new r.NotSupported(this.id+" fetchMarkOHLCV () is not supported yet")}async fetchIndexOHLCV(t,e="1m",i,s,o={}){if(this.has.fetchIndexOHLCV)return await this.fetchOHLCV(t,e,i,s,this.extend({price:"index"},o));throw new r.NotSupported(this.id+" fetchIndexOHLCV () is not supported yet")}async fetchPremiumIndexOHLCV(t,e="1m",i,s,o={}){if(this.has.fetchPremiumIndexOHLCV)return await this.fetchOHLCV(t,e,i,s,this.extend({price:"premiumIndex"},o));throw new r.NotSupported(this.id+" fetchPremiumIndexOHLCV () is not supported yet")}handleTimeInForce(t={}){let e=this.safeStringUpper(t,"timeInForce");if(void 0!==e){let t=this.safeString(this.options.timeInForce,e);if(void 0===t)throw new r.ExchangeError(this.id+' does not support timeInForce "'+e+'"');return t}}convertTypeToAccount(t){let e=this.safeDict(this.options,"accountsByType",{}),i=t.toLowerCase();return i in e?e[i]:t in this.markets||t in this.markets_by_id?this.market(t).id:t}checkRequiredArgument(t,e,i,s=[]){let o=s.length;if(void 0===e||o>0&&!this.inArray(e,s)){let e=s.join(", "),o=this.id+" "+t+"() requires a "+i+" argument";throw""!==e&&(o+=", one of ("+e+")"),new r.ArgumentsRequired(o)}}checkRequiredMarginArgument(t,e,i){if("isolated"===i&&void 0===e)throw new r.ArgumentsRequired(this.id+" "+t+"() requires a symbol argument for isolated margin");if("cross"===i&&void 0!==e)throw new r.ArgumentsRequired(this.id+" "+t+"() cannot have a symbol argument for cross margin")}parseDepositWithdrawFees(t,e,i){let s={},r=Array.isArray(t),o=t;r||(o=Object.keys(t));for(let a=0;a<o.length;a++){let n=o[a],h=r?n:t[n],d=r?this.safeString(h,i):n,c=this.safeCurrency(d),p=this.safeString(c,"code");(void 0===e||this.inArray(p,e))&&(s[p]=this.parseDepositWithdrawFee(h,c))}return s}parseDepositWithdrawFee(t,e){throw new r.NotSupported(this.id+" parseDepositWithdrawFee() is not supported yet")}depositWithdrawFee(t){return{info:t,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}}}assignDefaultDepositWithdrawFees(t,e){let i=Object.keys(t.networks),s=i.length;if(1===s)return t.withdraw=t.networks[i[0]].withdraw,t.deposit=t.networks[i[0]].deposit,t;let r=this.safeString(e,"code");for(let e=0;e<s;e++)i[e]===r&&(t.withdraw=t.networks[i[e]].withdraw,t.deposit=t.networks[i[e]].deposit);return t}parseIncome(t,e){throw new r.NotSupported(this.id+" parseIncome () is not supported yet")}parseIncomes(t,e,i,s){let r=[];for(let i=0;i<t.length;i++){let s=t[i],o=this.parseIncome(s,e);r.push(o)}let o=this.sortBy(r,"timestamp");return this.filterBySinceLimit(o,i,s)}getMarketFromSymbols(t){if(void 0===t)return;let e=this.safeString(t,0);return this.market(e)}parseWsOHLCVs(t,e,i="1m",s,r){let o=[];for(let i=0;i<t.length;i++)o.push(this.parseWsOHLCV(t[i],e));return o}async fetchTransactions(t,e,i,s={}){if(this.has.fetchDepositsWithdrawals)return await this.fetchDepositsWithdrawals(t,e,i,s);throw new r.NotSupported(this.id+" fetchTransactions () is not supported yet")}filterByArrayPositions(t,e,i,s=!0){return this.filterByArray(t,e,i,s)}filterByArrayTickers(t,e,i,s=!0){return this.filterByArray(t,e,i,s)}createOHLCVObject(t,e,i){let s={};return s[t]={},s[t][e]=i,s}handleMaxEntriesPerRequestAndParams(t,e,i={}){let s;return[s,i]=this.handleOptionAndParams(i,t,"maxEntriesPerRequest"),void 0!==s&&s!==e&&(e=s),void 0===e&&(e=1e3),[e,i]}async fetchPaginatedCallDynamic(t,e,i,s,o={},a,n=!0){let h,d,c,p;[h,o]=this.handleOptionAndParams(o,t,"paginationCalls",10),[d,o]=this.handleOptionAndParams(o,t,"maxRetries",3),[c,o]=this.handleOptionAndParams(o,t,"paginationDirection","backward");let l=n;[l,o]=this.handleOptionAndParams(o,t,"removeRepeated",n);let u=0,f=[],y=0,m=this.safeInteger2(o,"untill","till");if([a,o]=this.handleMaxEntriesPerRequestAndParams(t,a,o),"forward"===c){if(void 0===i)throw new r.ArgumentsRequired(this.id+" pagination requires a since argument when paginationDirection set to forward");p=i}for(;u<h;){u+=1;try{if("backward"===c){void 0!==p&&(o.until=p-1);let s=await this[t](e,void 0,a,o),r=s.length;if(this.verbose){let e="Dynamic pagination call "+this.numberToString(u)+" method "+t+" response length "+this.numberToString(r);void 0!==p&&(e+=" timestamp "+this.numberToString(p)),this.log(e)}if(0===r)break;y=0,f=this.arrayConcat(f,s);let n=this.safeValue(s,0);if(p=this.safeInteger2(n,"timestamp",0),void 0!==i&&p<=i)break}else{let i=await this[t](e,p,a,o),s=i.length;if(this.verbose){let e="Dynamic pagination call "+this.numberToString(u)+" method "+t+" response length "+this.numberToString(s);void 0!==p&&(e+=" timestamp "+this.numberToString(p)),this.log(e)}if(0===s)break;y=0,f=this.arrayConcat(f,i);let r=this.safeValue(i,s-1);if(p=this.safeInteger(r,"timestamp")+1,void 0!==m&&p>=m)break}}catch(t){if((y+=1)>d)throw t}}let w=f;l&&(w=this.removeRepeatedElementsFromArray(f));let g="fetchOHLCV"===t?0:"timestamp";return this.filterBySinceLimit(w,i,s,g)}async safeDeterministicCall(t,e,i,s,o,a={}){let n;[n,a]=this.handleOptionAndParams(a,t,"maxRetries",3);let h=0;for(;h<=n;)try{if(o&&"fetchFundingRateHistory"!==t)return await this[t](e,o,i,s,a);return await this[t](e,i,s,a)}catch(t){if(t instanceof r.RateLimitExceeded||(h+=1)>n)throw t}return[]}async fetchPaginatedCallDeterministic(t,e,i,s,o,a={},n){let h;[h,a]=this.handleOptionAndParams(a,t,"paginationCalls",10),[n,a]=this.handleMaxEntriesPerRequestAndParams(t,n,a);let d=this.milliseconds(),c=[],p=1e3*this.parseTimeframe(o)*n,l=d-h*p-1;l=void 0!==i?Math.max(l,i):Math.max(l,1241440531e3);let u=this.safeInteger2(a,"until","till");if(void 0!==u){let t=Math.ceil((u-i)/p);if(t>h)throw new r.BadRequest(this.id+" the number of required calls is greater than the max number of calls allowed, either increase the paginationCalls or decrease the since-until gap. Current paginationCalls limit is "+h.toString()+" required calls is "+t.toString())}for(let i=0;i<h&&(void 0===u||!(l>=u))&&!(l>=d);i++)c.push(this.safeDeterministicCall(t,e,l,n,o,a)),l=this.sum(l,p)-1;let f=await Promise.all(c),y=[];for(let t=0;t<f.length;t++)y=this.arrayConcat(y,f[t]);let m=this.removeRepeatedElementsFromArray(y),w="fetchOHLCV"===t?0:"timestamp";return this.filterBySinceLimit(m,i,s,w)}async fetchPaginatedCallCursor(t,e,i,s,r={},o,a,n,h){let d,c,p;[d,r]=this.handleOptionAndParams(r,t,"paginationCalls",10),[c,r]=this.handleOptionAndParams(r,t,"maxRetries",3),[h,r]=this.handleMaxEntriesPerRequestAndParams(t,h,r);let l=0,u=0,f=[],y=this.safeString(r,"timeframe");for(r=this.omit(r,"timeframe");l<d;){try{let s;void 0!==p&&(void 0!==n&&(p=this.parseToInt(p)+n),r[a]=p),s="fetchAccounts"===t?await this[t](r):"getLeverageTiersPaginated"===t||"fetchPositions"===t?await this[t](e,r):"fetchOpenInterestHistory"===t?await this[t](e,y,i,h,r):await this[t](e,i,h,r),u=0;let d=s.length;if(this.verbose){let e=void 0===p?"":p,i=l+1,s="Cursor pagination call "+i.toString()+" method "+t+" response length "+d.toString()+" cursor "+e;this.log(s)}if(0===d)break;f=this.arrayConcat(f,s);let c=this.safeDict(s,d-1);p=void 0;for(let t=0;t<d;t++){let e=d-t-1,i=this.safeDict(s,e),r=this.safeDict(i,"info"),a=this.safeValue(r,o);if(void 0!==a){p=a;break}}if(void 0===p)break;let m=this.safeInteger(c,"timestamp");if(void 0!==m&&m<i)break}catch(t){if((u+=1)>c)throw t}l+=1}let m=this.sortCursorPaginatedResult(f),w="fetchOHLCV"===t?0:"timestamp";return this.filterBySinceLimit(m,i,s,w)}async fetchPaginatedCallIncremental(t,e,i,s,r={},o,a){let n,h;[n,r]=this.handleOptionAndParams(r,t,"paginationCalls",10),[h,r]=this.handleOptionAndParams(r,t,"maxRetries",3),[a,r]=this.handleMaxEntriesPerRequestAndParams(t,a,r);let d=0,c=0,p=[];for(;d<n;){try{r[o]=d+1;let s=await this[t](e,i,a,r);c=0;let n=s.length;if(this.verbose){let e=(d+1).toString(),i="Incremental pagination call "+e+" method "+t+" response length "+n.toString();this.log(i)}if(0===n)break;p=this.arrayConcat(p,s)}catch(t){if((c+=1)>h)throw t}d+=1}let l=this.sortCursorPaginatedResult(p),u="fetchOHLCV"===t?0:"timestamp";return this.filterBySinceLimit(l,i,s,u)}sortCursorPaginatedResult(t){let e=this.safeValue(t,0);if(void 0!==e){if("timestamp"in e)return this.sortBy(t,"timestamp",!0);if("id"in e)return this.sortBy(t,"id",!0)}return t}removeRepeatedElementsFromArray(t){let e={};for(let i=0;i<t.length;i++){let s=t[i],r=this.safeString(s,"id");if(void 0!==r)void 0===this.safeString(e,r)&&(e[r]=s);else{let t=this.safeInteger2(s,"timestamp",0);void 0!==t&&void 0===this.safeString(e,t)&&(e[t]=s)}}let i=Object.values(e);return i.length>0?i:t}handleUntilOption(t,e,i,s=1){let r=this.safeInteger2(i,"until","till");return void 0!==r&&(e[t]=this.parseToInt(r*s),i=this.omit(i,["until","till"])),[e,i]}safeOpenInterest(t,e){let i=this.safeString(t,"symbol");return void 0===i&&(i=this.safeString(e,"symbol")),this.extend(t,{symbol:i,baseVolume:this.safeNumber(t,"baseVolume"),quoteVolume:this.safeNumber(t,"quoteVolume"),openInterestAmount:this.safeNumber(t,"openInterestAmount"),openInterestValue:this.safeNumber(t,"openInterestValue"),timestamp:this.safeInteger(t,"timestamp"),datetime:this.safeString(t,"datetime"),info:this.safeValue(t,"info")})}parseLiquidation(t,e){throw new r.NotSupported(this.id+" parseLiquidation () is not supported yet")}parseLiquidations(t,e,i,s){let r=[];for(let i=0;i<t.length;i++){let s=t[i],o=this.parseLiquidation(s,e);r.push(o)}let o=this.sortBy(r,"timestamp"),a=this.safeString(e,"symbol");return this.filterBySymbolSinceLimit(o,a,i,s)}parseGreeks(t,e){throw new r.NotSupported(this.id+" parseGreeks () is not supported yet")}parseOption(t,e,i){throw new r.NotSupported(this.id+" parseOption () is not supported yet")}parseOptionChain(t,e,i){let s={};for(let r=0;r<t.length;r++){let o=t[r],a=this.safeString(o,e),n=this.safeCurrency(a),h=this.safeString(o,i),d=this.safeMarket(h,void 0,void 0,"option");s[d.symbol]=this.parseOption(o,n,d)}return s}parseMarginModes(t,e,i,s){let r={};void 0===s&&(s="swap");for(let o=0;o<t.length;o++){let a=t[o],n=this.safeString(a,i),h=this.safeMarket(n,void 0,void 0,s);(void 0===e||this.inArray(h.symbol,e))&&(r[h.symbol]=this.parseMarginMode(a,h))}return r}parseMarginMode(t,e){throw new r.NotSupported(this.id+" parseMarginMode () is not supported yet")}parseLeverages(t,e,i,s){let r={};void 0===s&&(s="swap");for(let o=0;o<t.length;o++){let a=t[o],n=this.safeString(a,i),h=this.safeMarket(n,void 0,void 0,s);(void 0===e||this.inArray(h.symbol,e))&&(r[h.symbol]=this.parseLeverage(a,h))}return r}parseLeverage(t,e){throw new r.NotSupported(this.id+" parseLeverage () is not supported yet")}parseConversions(t,e,i,s,r,o,a={}){let n,h;t=this.toArray(t);let d=[];for(let e=0;e<t.length;e++){let r=t[e],o=this.safeString(r,i),c=this.safeString(r,s);void 0!==o&&(n=this.safeCurrency(o)),void 0!==c&&(h=this.safeCurrency(c));let p=this.extend(this.parseConversion(r,n,h),a);d.push(p)}let c=this.sortBy(d,"timestamp");if(void 0!==e&&(e=this.safeCurrency(e).code),void 0===e)return this.filterBySinceLimit(c,r,o);let p=this.filterBy(c,"fromCurrency",e),l=this.filterBy(c,"toCurrency",e),u=this.arrayConcat(p,l);return this.filterBySinceLimit(u,r,o)}parseConversion(t,e,i){throw new r.NotSupported(this.id+" parseConversion () is not supported yet")}convertExpireDate(t){let e=t.slice(0,2);return"20"+e+"-"+t.slice(2,4)+"-"+t.slice(4,6)+"T00:00:00Z"}convertExpireDateToMarketIdDate(t){let e;let i=t.slice(0,2),s=t.slice(2,4);return"01"===s?e="JAN":"02"===s?e="FEB":"03"===s?e="MAR":"04"===s?e="APR":"05"===s?e="MAY":"06"===s?e="JUN":"07"===s?e="JUL":"08"===s?e="AUG":"09"===s?e="SEP":"10"===s?e="OCT":"11"===s?e="NOV":"12"===s&&(e="DEC"),t.slice(4,6)+e+i}convertMarketIdExpireDate(t){6===t.length&&(t="0"+t);let e=t.slice(0,2),i=t.slice(2,5),s=this.safeString({JAN:"01",FEB:"02",MAR:"03",APR:"04",MAY:"05",JUN:"06",JUL:"07",AUG:"08",SEP:"09",OCT:"10",NOV:"11",DEC:"12"},i);return t.slice(5,7)+s+e}async fetchPositionHistory(t,e,i,s={}){if(this.has.fetchPositionsHistory)return await this.fetchPositionsHistory([t],e,i,s);throw new r.NotSupported(this.id+" fetchPositionHistory () is not supported yet")}async fetchPositionsHistory(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchPositionsHistory () is not supported yet")}parseMarginModification(t,e){throw new r.NotSupported(this.id+" parseMarginModification() is not supported yet")}parseMarginModifications(t,e,i,s){let r=[];for(let o=0;o<t.length;o++){let a=t[o],n=this.safeString(a,i),h=this.safeMarket(n,void 0,void 0,s);(void 0===e||this.inArray(h.symbol,e))&&r.push(this.parseMarginModification(a,h))}return r}async fetchTransfer(t,e,i={}){throw new r.NotSupported(this.id+" fetchTransfer () is not supported yet")}async fetchTransfers(t,e,i,s={}){throw new r.NotSupported(this.id+" fetchTransfers () is not supported yet")}cleanUnsubscription(t,e,i){if(i in t.subscriptions&&delete t.subscriptions[i],e in t.subscriptions&&delete t.subscriptions[e],e in t.futures){let i=new r.UnsubscribeError(this.id+" "+e);t.reject(i,e)}t.resolve(!0,i)}cleanCache(t){let e=this.safeString(t,"topic"),i=this.safeList(t,"symbols",[]),s=i.length;if("ohlcv"===e){let e=this.safeList(t,"symbolsAndTimeframes",[]);for(let t=0;t<e.length;t++){let i=e[t],s=this.safeString(i,0),r=this.safeString(i,1);s in this.ohlcvs&&r in this.ohlcvs[s]&&delete this.ohlcvs[s][r]}}else if(s>0)for(let t=0;t<i.length;t++){let s=i[t];"trades"===e?s in this.trades&&delete this.trades[s]:"orderbook"===e?s in this.orderbooks&&delete this.orderbooks[s]:"ticker"===e&&s in this.tickers&&delete this.tickers[s]}else if("myTrades"===e){let t=Object.keys(this.myTrades);for(let e=0;e<t.length;e++){let i=t[e];i in this.myTrades&&delete this.myTrades[i]}}else if("orders"===e){let t=Object.keys(this.orders);for(let e=0;e<t.length;e++){let i=t[e];i in this.orders&&delete this.orders[i]}}else if("ticker"===e){let t=Object.keys(this.tickers);for(let e=0;e<t.length;e++){let i=t[e];i in this.tickers&&delete this.tickers[i]}}}}}}]);