"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[652],{3919:(e,t,i)=>{i.d(t,{A:()=>d});var s=i(8778),a=i(8119),r=i(3675),n=i(6077),o=i(5432);class d extends s.A{describe(){return this.deepExtend(super.describe(),{id:"digifinex",name:"DigiFinex",countries:["SG"],version:"v3",rateLimit:900,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!0,cancelOrder:!0,cancelOrders:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!0,fetchCrossBorrowRates:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingInterval:!0,fetchFundingIntervals:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMargin:!1,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","12h":"720","1d":"1D","1w":"1W"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87443315-01283a00-c5fe-11ea-8628-c2a0feaf07ac.jpg",api:{rest:"https://openapi.digifinex.com"},www:"https://www.digifinex.com",doc:["https://docs.digifinex.com"],fees:"https://digifinex.zendesk.com/hc/en-us/articles/360000328422-Fee-Structure-on-DigiFinex",referral:"https://www.digifinex.com/en-ww/from/DhOzBg?channelCode=ljaUPp"},api:{public:{spot:{get:["{market}/symbols","kline","margin/currencies","margin/symbols","markets","order_book","ping","spot/symbols","time","trades","trades/symbols","ticker","currencies"]},swap:{get:["public/api_weight","public/candles","public/candles_history","public/depth","public/funding_rate","public/funding_rate_history","public/instrument","public/instruments","public/ticker","public/tickers","public/time","public/trades"]}},private:{spot:{get:["{market}/financelog","{market}/mytrades","{market}/order","{market}/order/detail","{market}/order/current","{market}/order/history","margin/assets","margin/financelog","margin/mytrades","margin/order","margin/order/current","margin/order/history","margin/positions","otc/financelog","spot/assets","spot/financelog","spot/mytrades","spot/order","spot/order/current","spot/order/history","deposit/address","deposit/history","withdraw/history"],post:["{market}/order/cancel","{market}/order/new","{market}/order/batch_new","margin/order/cancel","margin/order/new","margin/position/close","spot/order/cancel","spot/order/new","transfer","withdraw/new","withdraw/cancel"]},swap:{get:["account/balance","account/positions","account/finance_record","account/trading_fee_rate","account/transfer_record","account/funding_fee","trade/history_orders","trade/history_trades","trade/open_orders","trade/order_info"],post:["account/transfer","account/leverage","account/position_mode","account/position_margin","trade/batch_cancel_order","trade/batch_order","trade/cancel_order","trade/order_place","follow/sponsor_order","follow/close_order","follow/cancel_order","follow/user_center_current","follow/user_center_history","follow/expert_current_open_order","follow/add_algo","follow/cancel_algo","follow/account_available","follow/plan_task","follow/instrument_list"]}}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:r.kb,exceptions:{exact:{10001:[a.BadRequest,"Wrong request method, please check it's a GET ot POST request"],10002:[a.AuthenticationError,"Invalid ApiKey"],10003:[a.AuthenticationError,"Sign doesn't match"],10004:[a.BadRequest,"Illegal request parameters"],10005:[a.DDoSProtection,"Request frequency exceeds the limit"],10006:[a.PermissionDenied,"Unauthorized to execute this request"],10007:[a.PermissionDenied,"IP address Unauthorized"],10008:[a.InvalidNonce,"Timestamp for this request is invalid, timestamp must within 1 minute"],10009:[a.NetworkError,"Unexist endpoint, please check endpoint URL"],10011:[a.AccountSuspended,"ApiKey expired. Please go to client side to re-create an ApiKey"],20001:[a.PermissionDenied,"Trade is not open for this trading pair"],20002:[a.PermissionDenied,"Trade of this trading pair is suspended"],20003:[a.InvalidOrder,"Invalid price or amount"],20007:[a.InvalidOrder,"Price precision error"],20008:[a.InvalidOrder,"Amount precision error"],20009:[a.InvalidOrder,"Amount is less than the minimum requirement"],20010:[a.InvalidOrder,"Cash Amount is less than the minimum requirement"],20011:[a.InsufficientFunds,"Insufficient balance"],20012:[a.BadRequest,"Invalid trade type, valid value: buy/sell)"],20013:[a.InvalidOrder,"No order info found"],20014:[a.BadRequest,"Invalid date, Valid format: 2018-07-25)"],20015:[a.BadRequest,"Date exceeds the limit"],20018:[a.PermissionDenied,"Your trading rights have been banned by the system"],20019:[a.BadSymbol,'Wrong trading pair symbol. Correct format:"usdt_btc". Quote asset is in the front'],20020:[a.DDoSProtection,"You have violated the API operation trading rules and temporarily forbid trading. At present, we have certain restrictions on the user's transaction rate and withdrawal rate."],5e4:[a.ExchangeError,"Exception error"],20021:[a.BadRequest,"Invalid currency"],20022:[a.BadRequest,"The ending timestamp must be larger than the starting timestamp"],20023:[a.BadRequest,"Invalid transfer type"],20024:[a.BadRequest,"Invalid amount"],20025:[a.BadRequest,"This currency is not transferable at the moment"],20026:[a.InsufficientFunds,"Transfer amount exceed your balance"],20027:[a.PermissionDenied,"Abnormal account status"],20028:[a.PermissionDenied,"Blacklist for transfer"],20029:[a.PermissionDenied,"Transfer amount exceed your daily limit"],20030:[a.BadRequest,"You have no position on this trading pair"],20032:[a.PermissionDenied,"Withdrawal limited"],20033:[a.BadRequest,"Wrong Withdrawal ID"],20034:[a.PermissionDenied,"Withdrawal service of this crypto has been closed"],20035:[a.PermissionDenied,"Withdrawal limit"],20036:[a.ExchangeError,"Withdrawal cancellation failed"],20037:[a.InvalidAddress,"The withdrawal address, Tag or chain type is not included in the withdrawal management list"],20038:[a.InvalidAddress,"The withdrawal address is not on the white list"],20039:[a.ExchangeError,"Can't be canceled in current status"],20040:[a.RateLimitExceeded,"Withdraw too frequently; limitation: 3 times a minute, 100 times a day"],20041:[a.PermissionDenied,"Beyond the daily withdrawal limit"],20042:[a.BadSymbol,"Current trading pair does not support API trading"],400002:[a.BadRequest,"Invalid Parameter"]},broad:{}},options:{defaultType:"spot",types:["spot","margin","otc"],createMarketBuyOrderRequiresPrice:!0,accountsByType:{spot:"1",margin:"2",OTC:"3"},networks:{ARBITRUM:"Arbitrum",AVALANCEC:"AVAX-CCHAIN",AVALANCEX:"AVAX-XCHAIN",BEP20:"BEP20",BSC:"BEP20",CARDANO:"Cardano",CELO:"Celo",CHILIZ:"Chiliz",COSMOS:"COSMOS",CRC20:"Crypto.com",CRONOS:"Crypto.com",DOGECOIN:"DogeChain",ERC20:"ERC20",ETH:"ERC20",ETHW:"ETHW",IOTA:"MIOTA",KLAYTN:"KLAY",MATIC:"Polygon",METIS:"MetisDAO",MOONBEAM:"GLMR",MOONRIVER:"Moonriver",OPTIMISM:"OPETH",POLYGON:"Polygon",RIPPLE:"XRP",SOLANA:"SOL",STELLAR:"Stella",TERRACLASSIC:"TerraClassic",TERRA:"Terra",TON:"Ton",TRC20:"TRC20",TRON:"TRC20",TRX:"TRC20",VECHAIN:"Vechain"}},commonCurrencies:{BHT:"Black House Test",EPS:"Epanus",FREE:"FreeRossDAO",MBN:"Mobilian Coin",TEL:"TEL666"}})}async fetchCurrencies(e={}){let t=await this.publicSpotGetCurrencies(e),i=this.safeValue(t,"data",[]),s={};for(let e=0;e<i.length;e++){let t;let a=i[e],r=this.safeString(a,"currency"),o=this.safeCurrencyCode(r),d=this.safeInteger(a,"deposit_status",1),h=this.safeInteger(a,"withdraw_status",1),l=d>0,c=h>0,m=l&&c,p=this.safeString(a,"min_withdraw_fee"),u=this.safeString(a,"min_withdraw_amount"),f=this.safeString(a,"min_deposit_amount"),g=this.parseNumber(f),w=this.parseNumber(u),y=this.parseNumber(p),v=n.Y.stringMin(p,n.Y.stringMin(f,u)),S=this.parseNumber(v),b=this.safeString(a,"chain");void 0!==b&&(t=this.networkIdToCode(b));let k={info:a,id:b,network:t,active:m,fee:y,precision:S,deposit:l,withdraw:c,limits:{amount:{min:void 0,max:void 0},withdraw:{min:w,max:void 0},deposit:{min:g,max:void 0}}};o in s?(Array.isArray(s[o].info)?s[o].info.push(a):s[o].info=[s[o].info,a],c&&(s[o].withdraw=!0,s[o].limits.withdraw.min=Math.min(s[o].limits.withdraw.min,w)),l&&(s[o].deposit=!0,s[o].limits.deposit.min=Math.min(s[o].limits.deposit.min,g)),m&&(s[o].active=!0)):s[o]={id:r,code:o,info:a,type:void 0,name:void 0,active:m,deposit:l,withdraw:c,fee:this.parseNumber(p),precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:w,max:void 0},deposit:{min:g,max:void 0}},networks:{}},void 0!==b?s[o].networks[b]=k:(s[o].active=m,s[o].fee=this.parseNumber(p),s[o].deposit=l,s[o].withdraw=c,s[o].limits={amount:{min:void 0,max:void 0},withdraw:{min:w,max:void 0},deposit:{min:g,max:void 0}}),s[o].precision=void 0===s[o].precision?S:Math.max(s[o].precision,S)}return s}async fetchMarkets(e={}){let t=this.safeValue(this.options,"fetchMarkets",{});return"fetch_markets_v2"===this.safeString(t,"method","fetch_markets_v2")?await this.fetchMarketsV2(e):await this.fetchMarketsV1(e)}async fetchMarketsV2(e={}){let t=this.safeString(this.options,"defaultType"),[i,s]=this.handleMarginModeAndParams("fetchMarketsV2",e),a=[];void 0!==i?a.push(this.publicSpotGetMarginSymbols(s)):a.push(this.publicSpotGetTradesSymbols(s)),a.push(this.publicSwapGetPublicInstruments(e));let r=await Promise.all(a),n=r[0],o=r[1],d=this.safeValue(n,"symbol_list",[]),h=this.safeValue(o,"data",[]),l=this.arrayConcat(d,h),c=[];for(let e=0;e<l.length;e++){let s,a;let r=l[e],n=this.safeString2(r,"symbol","instrument_id"),o=this.safeString2(r,"base_asset","base_currency"),d=this.safeString2(r,"quote_asset","quote_currency"),h=this.safeString(r,"clear_currency"),m=this.safeCurrencyCode(o),p=this.safeCurrencyCode(d),u=this.safeCurrencyCode(h),f=this.safeInteger(r,"is_allow",1),g="margin"===t?"margin":"spot",w=void 0===u,y=!w,v=void 0!==i||void 0,S=m+"/"+p;y&&(g="swap",S=m+"/"+p+":"+u,a=!(s=this.safeValue(r,"is_inverse")),this.safeValue(r,"isTrading")&&(f=1)),c.push({id:n,symbol:S,base:m,quote:p,settle:u,baseId:o,quoteId:d,settleId:h,type:g,spot:w,margin:v,swap:y,future:!1,option:!1,active:!!f,contract:y,linear:a,inverse:s,contractSize:this.safeNumber(r,"contract_value"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(r,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber2(r,"minimum_amount","min_order_amount"),max:void 0},price:{min:this.safeNumber(r,"tick_size"),max:void 0},cost:{min:this.safeNumber(r,"minimum_value"),max:void 0}},created:void 0,info:r})}return c}async fetchMarketsV1(e={}){let t=await this.publicSpotGetMarkets(e),i=this.safeValue(t,"data",[]),s=[];for(let e=0;e<i.length;e++){let t=i[e],a=this.safeString(t,"market"),[r,n]=a.split("_"),o=this.safeCurrencyCode(r),d=this.safeCurrencyCode(n);s.push({id:a,symbol:o+"/"+d,base:o,quote:d,settle:void 0,baseId:r,quoteId:n,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(t,"price_precision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(t,"volume_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"min_volume"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(t,"min_amount"),max:void 0}},info:t})}return s}parseBalance(e){let t={info:e};for(let i=0;i<e.length;i++){let s=e[i],a=this.safeString(s,"currency"),r=this.safeCurrencyCode(a),o=this.account(),d=this.safeString2(s,"free","avail_balance"),h=this.safeString2(s,"total","equity");o.free=d,o.used=n.Y.stringSub(h,d),o.total=h,t[r]=o}return this.safeBalance(t)}async fetchBalance(e={}){let t,i;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);let[s,r]=this.handleMarginModeAndParams("fetchBalance",e);if(void 0!==s||"margin"===t)t="margin",i=await this.privateSpotGetMarginAssets(r);else if("spot"===t)i=await this.privateSpotGetSpotAssets(r);else if("swap"===t)i=await this.privateSwapGetAccountBalance(r);else throw new a.NotSupported(this.id+" fetchBalance() not support this market type");let n="swap"===t?"data":"list",o=this.safeValue(i,n,[]);return this.parseBalance(o)}async fetchOrderBook(e,t,i={}){let s,a,r;await this.loadMarkets();let n=this.market(e),[o,d]=this.handleMarketTypeAndParams("fetchOrderBook",n,i),h={};return void 0!==t&&(h.limit=t),"swap"===o?(h.instrument_id=n.id,s=await this.publicSwapGetPublicDepth(this.extend(h,d))):(h.symbol=n.id,s=await this.publicSpotGetOrderBook(this.extend(h,d))),"swap"===o?(r=this.safeValue(s,"data",{}),a=this.safeInteger(r,"timestamp")):(r=s,a=this.safeTimestamp(s,"date")),this.parseOrderBook(r,n.symbol,a)}async fetchTickers(e,t={}){let i,s,a;await this.loadMarkets(),e=this.marketSymbols(e);let r=this.safeString(e,0);void 0!==r&&(i=this.market(r)),[s,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);let n={};a="swap"===s?await this.publicSwapGetPublicTickers(this.extend(n,t)):await this.publicSpotGetTicker(this.extend(n,t));let o={},d=this.safeValue2(a,"ticker","data",[]),h=this.safeInteger(a,"date");for(let e=0;e<d.length;e++){let t=this.extend({date:h},d[e]),i=this.parseTicker(t);o[i.symbol]=i}return this.filterByArrayTickers(o,"symbol",e)}async fetchTicker(e,t={}){let i,s;await this.loadMarkets();let a=this.market(e),r={};a.swap?(r.instrument_id=a.id,i=await this.publicSwapGetPublicTicker(this.extend(r,t))):(r.symbol=a.id,i=await this.publicSpotGetTicker(this.extend(r,t)));let n=this.safeInteger(i,"date"),o=this.safeValue(i,"ticker",[]),d=this.safeValue(i,"data",{}),h=this.safeValue(o,0,{});return s=a.swap?d:this.extend({date:n},h),this.parseTicker(s,a)}parseTicker(e,t){let i=this.safeNumber(e,"index_price"),s=void 0!==i?"contract":"spot",a=this.safeStringUpper2(e,"symbol","instrument_id"),r=this.safeSymbol(a,t,void 0,s);t=this.safeMarket(a,t,void 0,s);let n=this.safeTimestamp(e,"date");t.swap&&(n=this.safeInteger(e,"timestamp"));let o=this.safeString(e,"last");return this.safeTicker({symbol:r,timestamp:n,datetime:this.iso8601(n),high:this.safeString2(e,"high","high_24h"),low:this.safeString2(e,"low","low_24h"),bid:this.safeString2(e,"buy","best_bid"),bidVolume:this.safeString(e,"best_bid_size"),ask:this.safeString2(e,"sell","best_ask"),askVolume:this.safeString(e,"best_ask_size"),vwap:void 0,open:this.safeString(e,"open_24h"),close:o,last:o,previousClose:void 0,change:void 0,percentage:this.safeString2(e,"change","price_change_percent"),average:void 0,baseVolume:this.safeString2(e,"vol","volume_24h"),quoteVolume:this.safeString(e,"base_vol"),markPrice:this.safeString(e,"mark_price"),indexPrice:i,info:e},t)}parseTrade(e,t){let i,s,a;let r=this.safeString2(e,"id","trade_id"),n=this.safeString(e,"order_id"),o=this.safeString(e,"price"),d=this.safeStringN(e,["amount","volume","size"]),h=this.safeStringUpper2(e,"symbol","instrument_id"),l=this.safeSymbol(h,t);void 0===t&&(t=this.safeMarket(h));let c=this.safeTimestamp2(e,"date","timestamp"),m=this.safeString2(e,"type","side");if("swap"===t.type){c=this.safeInteger(e,"trade_time");let t=this.safeString(e,"order_type"),a=this.safeString(e,"match_role"),r=this.safeString(e,"direction");void 0!==t&&(i="0"===t?"limit":void 0),s="1"===a?"taker":"2"===a?"maker":void 0,"1"===m||"1"===r?m="buy":"2"===m||"2"===r?m="sell":"3"===m||"3"===r?m="sell":("4"===m||"4"===r)&&(m="buy")}else{let t=m.split("_");m=this.safeString(t,0),void 0===(i=this.safeString(t,1))&&(i="limit"),s=this.safeValue(e,"is_maker")?"maker":"taker"}let p=this.safeString(e,"fee");if(void 0!==p){let t;let i=this.safeString(e,"fee_currency");void 0!==i&&(t=this.safeCurrencyCode(i)),a={cost:p,currency:t}}return this.safeTrade({id:r,info:e,timestamp:c,datetime:this.iso8601(c),symbol:l,type:i,order:n,side:m,price:o,amount:d,cost:void 0,takerOrMaker:s,fee:a},t)}async fetchTime(e={}){let t=await this.publicSpotGetTime(e);return this.safeTimestamp(t,"server_time")}async fetchStatus(e={}){let t=await this.publicSpotGetPing(e);return{status:0===this.safeInteger(t,"code")?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTrades(e,t,i,s={}){let a;await this.loadMarkets();let r=this.market(e),n={};void 0!==i&&(n.limit=r.swap?Math.min(i,100):i),r.swap?(n.instrument_id=r.id,a=await this.publicSwapGetPublicTrades(this.extend(n,s))):(n.symbol=r.id,a=await this.publicSpotGetTrades(this.extend(n,s)));let o=this.safeList(a,"data",[]);return this.parseTrades(o,r,t,i)}parseOHLCV(e,t){return t.swap?[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:[this.safeTimestamp(e,0),this.safeNumber(e,5),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,1)]}async fetchOHLCV(e,t="1m",i,s,a={}){let r,n;await this.loadMarkets();let o=this.market(e),d={};if(o.swap)d.instrument_id=o.id,d.granularity=t,void 0!==s&&(d.limit=Math.min(s,100)),r=await this.publicSwapGetPublicCandles(this.extend(d,a));else{if(d.symbol=o.id,d.period=this.safeString(this.timeframes,t,t),void 0!==i){let e=this.parseToInt(i/1e3);if(d.start_time=e,void 0!==s){let i=this.parseTimeframe(t);d.end_time=this.sum(e,s*i)}}else if(void 0!==s){let e=this.seconds(),i=this.parseTimeframe(t);d.start_time=this.sum(e,-s*i)}r=await this.publicSpotGetKline(this.extend(d,a))}if(o.swap){let e=this.safeValue(r,"data",{});n=this.safeValue(e,"candles",[])}else n=this.safeValue(r,"data",[]);return this.parseOHLCVs(n,o,t,i,s)}async createOrder(e,t,i,s,a,r={}){let n;await this.loadMarkets();let o=this.market(e),d=this.handleMarginModeAndParams("createOrder",r)[0],h=this.createOrderRequest(e,t,i,s,a,r);n=o.swap?await this.privateSwapPostTradeOrderPlace(h):void 0!==d?await this.privateSpotPostMarginOrderNew(h):await this.privateSpotPostSpotOrderNew(h);let l=this.parseOrder(n,o);return l.symbol=o.symbol,l.type=t,l.side=i,l.amount=s,l.price=a,l}async createOrders(e,t={}){let i,s,r;await this.loadMarkets();let n=[];for(let t=0;t<e.length;t++){let r=e[t],o=this.safeString(r,"symbol");if(void 0===i)i=o;else if(i!==o)throw new a.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");let d=this.safeString(r,"type"),h=this.safeString(r,"side"),l=this.safeValue(r,"amount"),c=this.safeValue(r,"price"),m=this.safeValue(r,"params",{}),p=this.handleMarginModeAndParams("createOrders",m)[0];if(void 0!==p){if(void 0===s)s=p;else if(s!==p)throw new a.BadRequest(this.id+" createOrders() requires all orders to have the same margin mode (isolated or cross)")}let u=this.createOrderRequest(o,d,h,l,c,m);n.push(u)}let o=this.market(i),d={};o.swap?r=await this.privateSwapPostTradeBatchOrder(n):(d.market=void 0!==s?"margin":"spot",d.symbol=o.id,d.list=this.json(n),r=await this.privateSpotPostMarketOrderBatchNew(d));let h=[];h=o.swap?this.safeValue(r,"data",[]):this.safeValue(r,"order_ids",[]);let l=[];for(let t=0;t<e.length;t++){let i=e[t],s={};s.order_id=h[t],s.instrument_id=o.id,s.amount=this.safeNumber(i,"amount"),s.price=this.safeNumber(i,"price"),l.push(s)}return this.parseOrders(l,o)}createOrderRequest(e,t,i,s,r,o={}){let d,h,l;let c=this.market(e);[d,o]=this.handleMarketTypeAndParams("createOrderRequest",c,o),[h,o]=this.handleMarginModeAndParams("createOrderRequest",o),void 0!==h&&(d="margin");let m={},p="swap"===d,u="market"===t;m[p?"instrument_id":"symbol"]=c.id;let f=this.isPostOnly(u,!1,o);if(p){let a;let n=this.safeBool(o,"reduceOnly",!1),d=this.safeString(o,"timeInForce");"buy"===i?m.type=n?4:1:m.type=n?3:2,"limit"===t&&(a=0),"FOK"===d?a=u?15:9:"IOC"===d?a=u?13:4:"GTC"===d||u?a=14:"PO"===d&&(f=!0),void 0!==r&&(m.price=this.priceToPrecision(e,r)),m.order_type=a,m.size=s,o=this.omit(o,["reduceOnly","timeInForce"])}else{let h;l=!0===f?1:2,m.market=d;let c="";"market"===t?c="_market":m.price=this.priceToPrecision(e,r),m.type=i+c;let p=!0;if([p,o]=this.handleOptionAndParams(o,"createOrderRequest","createMarketBuyOrderRequiresPrice",!0),u&&"buy"===i){let t=this.safeNumber(o,"cost");if(o=this.omit(o,"cost"),void 0!==t)h=this.costToPrecision(e,t);else if(p){if(void 0===r)throw new a.InvalidOrder(this.id+" createOrder() requires a price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{let t=this.numberToString(s),i=this.numberToString(r),a=this.parseNumber(n.Y.stringMul(t,i));h=this.costToPrecision(e,a)}}else h=this.costToPrecision(e,s)}else h=this.amountToPrecision(e,s);m.amount=h}return f&&(l?m.post_only=l:m.post_only=f),o=this.omit(o,["postOnly"]),this.extend(m,o)}async createMarketBuyOrderWithCost(e,t,i={}){if(await this.loadMarkets(),!this.market(e).spot)throw new a.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return i.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,i)}async cancelOrder(e,t,i={}){let s,r,n;await this.loadMarkets(),void 0!==t&&(s=this.market(t)),e=e.toString(),[r,i]=this.handleMarketTypeAndParams("cancelOrder",s,i);let o={order_id:e};if("swap"===r){if(void 0===t)throw new a.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");o.instrument_id=s.id}else o.market=r;let[d,h]=this.handleMarginModeAndParams("cancelOrder",i);if(void 0!==d||"margin"===r)r="margin",n=await this.privateSpotPostMarginOrderCancel(this.extend(o,h));else if("spot"===r)n=await this.privateSpotPostSpotOrderCancel(this.extend(o,h));else if("swap"===r)n=await this.privateSwapPostTradeCancelOrder(this.extend(o,h));else throw new a.NotSupported(this.id+" cancelOrder() not support this market type");if("spot"!==r&&"margin"!==r)return this.safeOrder({info:n,orderId:this.safeString(n,"data")});{if(1!==this.safeValue(n,"success",[]).length)throw new a.OrderNotFound(this.id+" cancelOrder() "+e+" not found");let t=this.parseCancelOrders(n);return this.safeDict(t,0)}}parseCancelOrders(e){let t=this.safeList(e,"success"),i=this.safeList(e,"error"),s=[];for(let e=0;e<t.length;e++){let i=t[e];s.push(this.safeOrder({info:i,id:i,status:"canceled"}))}for(let e=0;e<i.length;e++){let t=i[e];s.push(this.safeOrder({info:t,id:this.safeString2(t,"order-id","order_id"),status:"failed",clientOrderId:this.safeString(t,"client-order-id")}))}return s}async cancelOrders(e,t,i={}){await this.loadMarkets();let s=this.safeString(this.options,"defaultType","spot"),a=this.safeString(i,"type",s);i=this.omit(i,"type");let r={market:a,order_id:e.join(",")},n=await this.privateSpotPostSpotOrderCancel(this.extend(r,i));return this.parseCancelOrders(n)}parseOrderStatus(e){return this.safeString({0:"open",1:"open",2:"closed",3:"canceled",4:"canceled"},e,e)}parseOrder(e,t){let i,s,a,r;let n=this.safeString(e,"type"),o=this.safeString2(e,"symbol","instrument_id"),d=this.safeSymbol(o,t);if("swap"===(t=this.market(d)).type){let t=this.safeInteger(e,"order_type");void 0!==t&&(9===t||10===t||11===t||12===t||15===t?a="FOK":1===t||2===t||3===t||4===t||13===t?a="IOC":(6===t||7===t||8===t||14===t)&&(a="GTC"),r=0===t||1===t||4===t||5===t||9===t||10===t?"limit":"market"),"1"===n?n="open long":"2"===n?n="open short":"3"===n?n="close long":"4"===n&&(n="close short"),i=this.safeInteger(e,"insert_time"),s=this.safeInteger(e,"time_stamp")}else if(i=this.safeTimestamp(e,"created_date"),s=this.safeTimestamp(e,"finished_date"),void 0!==n){let e=n.split("_");e.length>1?(n=e[0],r=e[1]):r="limit"}return this.safeOrder({info:e,id:this.safeString2(e,"order_id","data"),clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:s,symbol:d,type:r,timeInForce:a,postOnly:void 0,side:n,price:this.safeNumber(e,"price"),triggerPrice:void 0,amount:this.safeNumber2(e,"amount","size"),filled:this.safeNumber2(e,"executed_amount","filled_qty"),remaining:void 0,cost:void 0,average:this.safeNumber2(e,"avg_price","price_avg"),status:this.parseOrderStatus(this.safeString2(e,"status","state")),fee:{cost:this.safeNumber(e,"fee")},trades:void 0},t)}async fetchOpenOrders(e,t,i,s={}){let r,n,o;await this.loadMarkets(),void 0!==e&&(r=this.market(e)),[n,s]=this.handleMarketTypeAndParams("fetchOpenOrders",r,s);let[d,h]=this.handleMarginModeAndParams("fetchOpenOrders",s),l={},c="swap"===n;if(c?(void 0!==t&&(l.start_timestamp=t),void 0!==i&&(l.limit=i)):l.market=n,void 0!==r&&(l[c?"instrument_id":"symbol"]=r.id),void 0!==d||"margin"===n)n="margin",o=await this.privateSpotGetMarginOrderCurrent(this.extend(l,h));else if("spot"===n)o=await this.privateSpotGetSpotOrderCurrent(this.extend(l,h));else if("swap"===n)o=await this.privateSwapGetTradeOpenOrders(this.extend(l,h));else throw new a.NotSupported(this.id+" fetchOpenOrders() not support this market type");let m=this.safeList(o,"data",[]);return this.parseOrders(m,r,t,i)}async fetchOrders(e,t,i,s={}){let r,n,o;await this.loadMarkets(),void 0!==e&&(r=this.market(e)),[n,s]=this.handleMarketTypeAndParams("fetchOrders",r,s);let[d,h]=this.handleMarginModeAndParams("fetchOrders",s),l={};if("swap"===n?void 0!==t&&(l.start_timestamp=t):(l.market=n,void 0!==t&&(l.start_time=this.parseToInt(t/1e3))),void 0!==r&&(l["swap"===n?"instrument_id":"symbol"]=r.id),void 0!==i&&(l.limit=i),void 0!==d||"margin"===n)n="margin",o=await this.privateSpotGetMarginOrderHistory(this.extend(l,h));else if("spot"===n)o=await this.privateSpotGetSpotOrderHistory(this.extend(l,h));else if("swap"===n)o=await this.privateSwapGetTradeHistoryOrders(this.extend(l,h));else throw new a.NotSupported(this.id+" fetchOrders() not support this market type");let c=this.safeList(o,"data",[]);return this.parseOrders(c,r,t,i)}async fetchOrder(e,t,i={}){let s,r,n;await this.loadMarkets(),void 0!==t&&(s=this.market(t)),[r,i]=this.handleMarketTypeAndParams("fetchOrder",s,i);let[o,d]=this.handleMarginModeAndParams("fetchOrder",i),h={order_id:e};if("swap"===r?void 0!==s&&(h.instrument_id=s.id):h.market=r,void 0!==o||"margin"===r)r="margin",n=await this.privateSpotGetMarginOrder(this.extend(h,d));else if("spot"===r)n=await this.privateSpotGetSpotOrder(this.extend(h,d));else if("swap"===r)n=await this.privateSwapGetTradeOrderInfo(this.extend(h,d));else throw new a.NotSupported(this.id+" fetchOrder() not support this market type");let l=this.safeValue(n,"data"),c="swap"===r?l:this.safeValue(l,0);if(void 0===c)throw new a.OrderNotFound(this.id+" fetchOrder() order "+e.toString()+" not found");return this.parseOrder(c,s)}async fetchMyTrades(e,t,i,s={}){let r,n,o;await this.loadMarkets();let d={};void 0!==e&&(r=this.market(e)),[n,s]=this.handleMarketTypeAndParams("fetchMyTrades",r,s);let[h,l]=this.handleMarginModeAndParams("fetchMyTrades",s);"swap"===n?void 0!==t&&(d.start_timestamp=t):(d.market=n,void 0!==t&&(d.start_time=this.parseToInt(t/1e3)));let c="swap"===n?"instrument_id":"symbol";if(void 0!==e&&(d[c]=r.id),void 0!==i&&(d.limit=i),void 0!==h||"margin"===n)n="margin",o=await this.privateSpotGetMarginMytrades(this.extend(d,l));else if("spot"===n)o=await this.privateSpotGetSpotMytrades(this.extend(d,l));else if("swap"===n)o=await this.privateSwapGetTradeHistoryTrades(this.extend(d,l));else throw new a.NotSupported(this.id+" fetchMyTrades() not support this market type");let m="swap"===n?"data":"list",p=this.safeList(o,m,[]);return this.parseTrades(p,r,t,i)}parseLedgerEntryType(e){return this.safeString({},e,e)}parseLedgerEntry(e,t){let i=this.parseLedgerEntryType(this.safeString2(e,"type","finance_type")),s=this.safeString2(e,"currency_mark","currency"),a=this.safeCurrencyCode(s,t);t=this.safeCurrency(s,t);let r=this.safeNumber2(e,"num","change"),n=this.safeNumber(e,"balance"),o=this.safeTimestamp(e,"time");return void 0===o&&(o=this.safeInteger(e,"timestamp")),this.safeLedgerEntry({info:e,id:void 0,direction:void 0,account:void 0,referenceId:void 0,referenceAccount:void 0,type:i,currency:a,amount:r,before:void 0,after:n,status:void 0,timestamp:o,datetime:this.iso8601(o),fee:void 0},t)}async fetchLedger(e,t,i,s={}){let r,n,o,d;await this.loadMarkets();let h={};[r,s]=this.handleMarketTypeAndParams("fetchLedger",void 0,s);let[l,c]=this.handleMarginModeAndParams("fetchLedger",s);"swap"===r?void 0!==t&&(h.start_timestamp=t):(h.market=r,void 0!==t&&(h.start_time=this.parseToInt(t/1e3)));let m="swap"===r?"currency":"currency_mark";if(void 0!==e&&(n=this.currency(e),h[m]=n.id),void 0!==i&&(h.limit=i),void 0!==l||"margin"===r)r="margin",o=await this.privateSpotGetMarginFinancelog(this.extend(h,c));else if("spot"===r)o=await this.privateSpotGetSpotFinancelog(this.extend(h,c));else if("swap"===r)o=await this.privateSwapGetAccountFinanceRecord(this.extend(h,c));else throw new a.NotSupported(this.id+" fetchLedger() not support this market type");if("swap"===r)d=this.safeValue(o,"data",[]);else{let e=this.safeValue(o,"data",{});d=this.safeValue(e,"finance",[])}return this.parseLedger(d,n,t,i)}parseDepositAddress(e,t){let i=this.safeString(e,"address"),s=this.safeString(e,"addressTag"),a=this.safeStringUpper(e,"currency");return{info:e,currency:this.safeCurrencyCode(a),network:void 0,address:i,tag:s}}async fetchDepositAddress(e,t={}){await this.loadMarkets();let i=this.currency(e),s={currency:i.id},r=await this.privateSpotGetDepositAddress(this.extend(s,t)),n=this.safeValue(r,"data",[]),o=this.parseDepositAddresses(n,[i.code]),d=this.safeValue(o,e);if(void 0===d)throw new a.InvalidAddress(this.id+" fetchDepositAddress() did not return an address for "+e+" - create the deposit address in the user settings on the exchange website first.");return d}async fetchTransactionsByType(e,t,i,s,a={}){let r,n;await this.loadMarkets();let o={};void 0!==t&&(r=this.currency(t),o.currency=r.id),void 0!==s&&(o.size=Math.min(500,s)),n="deposit"===e?await this.privateSpotGetDepositHistory(this.extend(o,a)):await this.privateSpotGetWithdrawHistory(this.extend(o,a));let d=this.safeList(n,"data",[]);return this.parseTransactions(d,r,i,s,{type:e})}async fetchDeposits(e,t,i,s={}){return await this.fetchTransactionsByType("deposit",e,t,i,s)}async fetchWithdrawals(e,t,i,s={}){return await this.fetchTransactionsByType("withdrawal",e,t,i,s)}parseTransactionStatus(e){return this.safeString({1:"pending",2:"pending",3:"ok",4:"failed"},e,e)}parseTransaction(e,t){let i;let s=this.safeString2(e,"id","withdraw_id"),a=this.safeString(e,"address"),r=this.safeString(e,"memo"),n=this.safeString(e,"hash"),o=this.safeStringUpper(e,"currency"),d=this.safeCurrencyCode(o,t),h=this.parse8601(this.safeString(e,"created_date")),l=this.parse8601(this.safeString(e,"finished_date")),c=this.parseTransactionStatus(this.safeString(e,"state")),m=this.safeNumber(e,"amount"),p=this.safeNumber(e,"fee");void 0!==p&&(i={currency:d,cost:p});let u=this.safeString(e,"chain");return{info:e,id:s,txid:n,timestamp:h,datetime:this.iso8601(h),network:u,address:a,addressTo:a,addressFrom:void 0,tag:r,tagTo:r,tagFrom:void 0,type:void 0,amount:m,currency:d,status:c,updated:l,internal:void 0,comment:void 0,fee:i}}parseTransferStatus(e){return this.safeString({0:"ok"},e,e)}parseTransfer(e,t){let i,s;let a=this.safeDict(e,"data",e),r=this.safeInteger(a,"type");1===r?(i="spot",s="swap"):2===r&&(i="swap",s="spot");let n=this.safeInteger(e,"timestamp");return{info:e,id:this.safeString(e,"transfer_id"),timestamp:n,datetime:this.iso8601(n),currency:this.safeCurrencyCode(this.safeString(a,"currency"),t),amount:this.safeNumber2(a,"amount","transfer_amount"),fromAccount:i,toAccount:s,status:this.parseTransferStatus(this.safeString(e,"code"))}}async transfer(e,t,i,s,r={}){let n;await this.loadMarkets();let o=this.currency(e),d=o.id,h=this.safeValue(this.options,"accountsByType",{}),l=this.safeString(h,i,i),c=this.safeString(h,s,s),m={},p="swap"===i,u="swap"===s,f=this.currencyToPrecision(e,t);if(p||u){if("1"!==l&&"1"!==c)throw new a.ExchangeError(this.id+" transfer() supports transferring between spot and swap, spot and margin, spot and OTC only");m.type=u?1:2,m.currency=d,m.transfer_amount=f,n=await this.privateSwapPostAccountTransfer(this.extend(m,r))}else m.currency_mark=d,m.num=f,m.from=l,m.to=c,n=await this.privateSpotPostTransfer(this.extend(m,r));return this.parseTransfer(n,o)}async withdraw(e,t,i,s,a={}){[s,a]=this.handleWithdrawTagAndParams(s,a),this.checkAddress(i),await this.loadMarkets();let r=this.currency(e),n={address:i,amount:this.currencyToPrecision(e,t),currency:r.id};void 0!==s&&(n.memo=s);let o=await this.privateSpotPostWithdrawNew(this.extend(n,a));return this.parseTransaction(o,r)}async fetchBorrowInterest(e,t,i,s,a={}){let r;await this.loadMarkets();let n={};void 0!==t&&(r=this.market(t),n.symbol=r.id);let o=await this.privateSpotGetMarginPositions(this.extend(n,a)),d=this.safeValue(o,"positions"),h=this.parseBorrowInterests(d,r);return this.filterByCurrencySinceLimit(h,e,i,s)}parseBorrowInterest(e,t){let i=this.safeString(e,"symbol"),s=this.safeString(e,"amount"),a=this.safeString(e,"leverage_ratio"),r=n.Y.stringDiv(s,a),o=n.Y.stringSub(s,r),d=void 0===t?void 0:t.base;return{info:e,symbol:this.safeSymbol(i,t),currency:d,interest:void 0,interestRate:.001,amountBorrowed:this.parseNumber(o),marginMode:void 0,timestamp:void 0,datetime:void 0}}async fetchCrossBorrowRate(e,t={}){await this.loadMarkets();let i=await this.privateSpotGetMarginAssets(this.extend({},t)),s=this.safeValue(i,"list",[]),a=[];for(let t=0;t<s.length;t++){let i=s[t];this.safeString(i,"currency")===e&&(a=i)}let r=this.currency(e);return this.parseBorrowRate(a,r)}async fetchCrossBorrowRates(e={}){await this.loadMarkets();let t=await this.privateSpotGetMarginAssets(e),i=this.safeValue(t,"list",[]);return this.parseBorrowRates(i,"currency")}parseBorrowRate(e,t){let i=this.milliseconds(),s=this.safeString(e,"currency");return{currency:this.safeCurrencyCode(s,t),rate:.001,period:864e5,timestamp:i,datetime:this.iso8601(i),info:e}}parseBorrowRates(e,t){let i={};for(let s=0;s<e.length;s++){let a=e[s],r=this.safeString(a,t),n=this.safeCurrencyCode(r),o=this.parseBorrowRate(a);i[n]=o}return i}async fetchFundingRate(e,t={}){await this.loadMarkets();let i=this.market(e);if(!i.swap)throw new a.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");let s={instrument_id:i.id},r=await this.publicSwapGetPublicFundingRate(this.extend(s,t)),n=this.safeDict(r,"data",{});return this.parseFundingRate(n,i)}async fetchFundingInterval(e,t={}){return await this.fetchFundingRate(e,t)}parseFundingRate(e,t){let i=this.safeString(e,"instrument_id"),s=this.safeInteger(e,"funding_time"),a=this.safeInteger(e,"next_funding_time"),r=this.safeString(e,"funding_time"),o=this.safeString(e,"next_funding_time"),d=n.Y.stringSub(o,r);return{info:e,symbol:this.safeSymbol(i,t),markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"funding_rate"),fundingTimestamp:s,fundingDatetime:this.iso8601(s),nextFundingRate:this.safeNumber(e,"next_funding_rate"),nextFundingTimestamp:a,nextFundingDatetime:this.iso8601(a),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0,interval:this.parseFundingInterval(d)}}parseFundingInterval(e){return this.safeString({36e5:"1h",144e5:"4h",288e5:"8h",576e5:"16h",864e5:"24h"},e,e)}async fetchFundingRateHistory(e,t,i,s={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let r=this.market(e);if(!r.swap)throw new a.BadSymbol(this.id+" fetchFundingRateHistory() supports swap contracts only");let n={instrument_id:r.id};void 0!==t&&(n.start_timestamp=t),void 0!==i&&(n.limit=i);let o=await this.publicSwapGetPublicFundingRateHistory(this.extend(n,s)),d=this.safeValue(o,"data",{}),h=this.safeValue(d,"funding_rates",[]),l=[];for(let e=0;e<h.length;e++){let t=h[e],i=this.safeString(d,"instrument_id"),s=this.safeSymbol(i),a=this.safeInteger(t,"time");l.push({info:t,symbol:s,fundingRate:this.safeNumber(t,"rate"),timestamp:a,datetime:this.iso8601(a)})}let c=this.sortBy(l,"timestamp");return this.filterBySymbolSinceLimit(c,e,t,i)}async fetchTradingFee(e,t={}){await this.loadMarkets();let i=this.market(e);if(!i.swap)throw new a.BadRequest(this.id+" fetchTradingFee() supports swap markets only");let s={instrument_id:i.id},r=await this.privateSwapGetAccountTradingFeeRate(this.extend(s,t)),n=this.safeValue(r,"data",{});return this.parseTradingFee(n,i)}parseTradingFee(e,t){let i=this.safeString(e,"instrument_id");return{info:e,symbol:this.safeSymbol(i,t),maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate"),percentage:void 0,tierBased:void 0}}async fetchPositions(e,t={}){let i,s,r;await this.loadMarkets();let n={};if(void 0!==(e=this.marketSymbols(e))){let t;if(Array.isArray(e)){if(e.length>1)throw new a.BadRequest(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");t=e[0]}else t=e;i=this.market(t)}[s,t]=this.handleMarketTypeAndParams("fetchPositions",i,t);let[o,d]=this.handleMarginModeAndParams("fetchPositions",t);if(void 0!==o&&(s="margin"),void 0!==i&&(n["swap"===s?"instrument_id":"symbol"]=i.id),"spot"===s||"margin"===s)r=await this.privateSpotGetMarginPositions(this.extend(n,d));else if("swap"===s)r=await this.privateSwapGetAccountPositions(this.extend(n,d));else throw new a.NotSupported(this.id+" fetchPositions() not support this market type");let h="swap"===s?"data":"positions",l=this.safeValue(r,h,[]),c=[];for(let e=0;e<l.length;e++)c.push(this.parsePosition(l[e],i));return this.filterByArrayPositions(c,"symbol",e,!1)}async fetchPosition(e,t={}){let i,s;await this.loadMarkets();let r=this.market(e),n={};[i,t]=this.handleMarketTypeAndParams("fetchPosition",r,t);let[o,d]=this.handleMarginModeAndParams("fetchPosition",t);if(void 0!==o&&(i="margin"),n["swap"===i?"instrument_id":"symbol"]=r.id,"spot"===i||"margin"===i)s=await this.privateSpotGetMarginPositions(this.extend(n,d));else if("swap"===i)s=await this.privateSwapGetAccountPositions(this.extend(n,d));else throw new a.NotSupported(this.id+" fetchPosition() not support this market type");let h="swap"===i?"data":"positions",l=this.safeValue(s,h,[]),c=this.parsePosition(l[0],r);return"swap"===i||(c.collateral=this.safeNumber(s,"margin"),c.marginRatio=this.safeNumber(s,"margin_rate")),c}parsePosition(e,t){let i=this.safeString2(e,"instrument_id","symbol"),s=(t=this.safeMarket(i,t)).symbol,a=this.safeString(e,"margin_mode");a=void 0!==a?"crossed"===a?"cross":"isolated":"crossed";let r=this.safeInteger(e,"timestamp"),n=this.safeString(e,"side");return"go_long"===n?n="long":"go_short"===n&&(n="short"),this.safePosition({info:e,id:void 0,symbol:s,notional:this.safeNumber(e,"amount"),marginMode:a,liquidationPrice:this.safeNumber(e,"liquidation_price"),entryPrice:this.safeNumber2(e,"avg_cost","entry_price"),unrealizedPnl:this.safeNumber(e,"unrealized_pnl"),contracts:this.safeNumber(e,"avail_position"),contractSize:this.safeNumber(t,"contractSize"),markPrice:this.safeNumber(e,"last"),side:n,hedged:void 0,timestamp:r,datetime:this.iso8601(r),maintenanceMargin:this.safeNumber(e,"margin"),maintenanceMarginPercentage:this.safeNumber(e,"maint_margin_ratio"),collateral:void 0,initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeNumber2(e,"leverage","leverage_ratio"),marginRatio:this.safeNumber(e,"margin_ratio"),percentage:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async setLeverage(e,t,i={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();let s=this.market(t);if("swap"!==s.type)throw new a.BadSymbol(this.id+" setLeverage() supports swap contracts only");if(e<1||e>100)throw new a.BadRequest(this.id+" leverage should be between 1 and 100");let r={instrument_id:s.id,leverage:e},n=this.safeString2(this.options,"marginMode","defaultMarginMode"),o=this.safeStringLower2(i,"marginMode","defaultMarginMode",n);if(void 0!==o&&(o="cross"===o?"crossed":"isolated",r.margin_mode=o,i=this.omit(i,["marginMode","defaultMarginMode"])),"isolated"===o){let e=this.safeString(i,"side");void 0!==e?(r.side=e,i=this.omit(i,"side")):this.checkRequiredArgument("setLeverage",e,"side",["long","short"])}return await this.privateSwapPostAccountLeverage(this.extend(r,i))}async fetchTransfers(e,t,i,s={}){let a;await this.loadMarkets();let r={};void 0!==e&&(a=this.safeCurrencyCode(e),r.currency=a.id),void 0!==t&&(r.start_timestamp=t),void 0!==i&&(r.limit=i);let n=await this.privateSwapGetAccountTransferRecord(this.extend(r,s)),o=this.safeList(n,"data",[]);return this.parseTransfers(o,a,t,i)}async fetchLeverageTiers(e,t={}){await this.loadMarkets();let i=await this.publicSwapGetPublicInstruments(t),s=this.safeValue(i,"data",[]);return e=this.marketSymbols(e),this.parseLeverageTiers(s,e,"instrument_id")}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();let i=this.market(e);if(!i.swap)throw new a.BadRequest(this.id+" fetchMarketLeverageTiers() supports swap markets only");let s={instrument_id:i.id},r=await this.publicSwapGetPublicInstrument(this.extend(s,t)),n=this.safeValue(r,"data",{});return this.parseMarketLeverageTiers(n,i)}parseMarketLeverageTiers(e,t){let i=[],s=this.safeValue(e,"open_max_limits",{});for(let a=0;a<s.length;a++){let r=s[a],n=this.safeString(e,"instrument_id");t=this.safeMarket(n,t),i.push({tier:this.sum(a,1),symbol:this.safeSymbol(n,t,void 0,"swap"),currency:t.settle,minNotional:void 0,maxNotional:this.safeNumber(r,"max_limit"),maintenanceMarginRate:void 0,maxLeverage:this.safeNumber(r,"leverage"),info:r})}return i}handleMarginModeAndParams(e,t={},i){let s;let r=this.safeString(this.options,"defaultType"),n=this.safeBool(t,"margin",!1);if([s,t]=super.handleMarginModeAndParams(e,t,i),void 0!==s){if("cross"!==s)throw new a.NotSupported(this.id+" only cross margin is supported")}else("margin"===r||!0===n)&&(s="cross");return[s,t]}async fetchDepositWithdrawFees(e,t={}){await this.loadMarkets();let i=await this.publicSpotGetCurrencies(t),s=this.safeList(i,"data");return this.parseDepositWithdrawFees(s,e)}parseDepositWithdrawFees(e,t,i){let s={};t=this.marketCodes(t);for(let i=0;i<e.length;i++){let a=e[i],r=this.safeString(a,"currency"),n=this.safeCurrencyCode(r);if(void 0===t||this.inArray(n,t)){void 0===this.safeValue(s,n)&&(s[n]=this.depositWithdrawFee({}),s[n].info=[]),s[n].info.push(a);let e=this.safeString(a,"chain"),t=this.safeValue(a,"min_withdraw_fee"),i={fee:t,percentage:void 0===t&&void 0},r={fee:void 0,percentage:void 0};if(void 0!==e){let t=this.networkIdToCode(e);s[n].networks[t]={withdraw:i,deposit:r}}else s[n].withdraw=i,s[n].deposit=r}}let a=Object.keys(s);for(let e=0;e<a.length;e++){let t=a[e],i=this.currency(t);s[t]=this.assignDefaultDepositWithdrawFees(s[t],i)}return s}async addMargin(e,t,i={}){let s=this.safeString(i,"side");return this.checkRequiredArgument("addMargin",s,"side",["long","short"]),await this.modifyMarginHelper(e,t,1,i)}async reduceMargin(e,t,i={}){let s=this.safeString(i,"side");return this.checkRequiredArgument("reduceMargin",s,"side",["long","short"]),await this.modifyMarginHelper(e,t,2,i)}async modifyMarginHelper(e,t,i,s={}){await this.loadMarkets();let a=this.safeString(s,"side"),r=this.market(e),n={instrument_id:r.id,amount:this.numberToString(t),type:i,side:a},o=await this.privateSwapPostAccountPositionMargin(this.extend(n,s)),d=this.safeInteger(o,"code"),h=this.safeValue(o,"data",{});return this.extend(this.parseMarginModification(h,r),{status:0===d?"ok":"failed"})}parseMarginModification(e,t){let i=this.safeString(e,"instrument_id"),s=this.safeInteger(e,"type");return{info:e,symbol:this.safeSymbol(i,t,void 0,"swap"),type:1===s?"add":"reduce",marginMode:"isolated",amount:this.safeNumber(e,"amount"),total:void 0,code:t.settle,status:void 0,timestamp:void 0,datetime:void 0}}async fetchFundingHistory(e,t,i,s={}){let a;await this.loadMarkets();let r={};[r,s]=this.handleUntilOption("end_timestamp",r,s),void 0!==e&&(a=this.market(e),r.instrument_id=a.id),void 0!==i&&(r.limit=i),void 0!==t&&(r.start_timestamp=t);let n=await this.privateSwapGetAccountFundingFee(this.extend(r,s)),o=this.safeList(n,"data",[]);return this.parseIncomes(o,a,t,i)}parseIncome(e,t){let i=this.safeString(e,"instrument_id"),s=this.safeString(e,"currency"),a=this.safeInteger(e,"timestamp");return{info:e,symbol:this.safeSymbol(i,t,void 0,"swap"),code:this.safeCurrencyCode(s),timestamp:a,datetime:this.iso8601(a),id:void 0,amount:this.safeNumber(e,"amount")}}async setMarginMode(e,t,i={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");await this.loadMarkets();let s=this.market(t);"cross"===(e=e.toLowerCase())&&(e="crossed");let r={instrument_id:s.id,margin_mode:e};return await this.privateSwapPostAccountPositionMode(this.extend(r,i))}sign(e,t=[],i="GET",s={},a,r){let n;let d="private"===t[0],h="spot"===t[1]?"/v3":"/swap/v2",l=h+"/"+this.implodeParams(e,s),c=this.urls.api.rest+l,m=this.omit(s,this.extractParams(e));if(n=d&&"/swap/v2"===h&&"POST"===i?JSON.stringify(s):this.urlencode(this.keysort(m)),d){let e,t;"/swap/v2"===h?(e=(t=this.milliseconds().toString())+i+l,"GET"===i?n&&(e+="?"+n):"POST"===i&&(e+=n)):(t=this.nonce().toString(),e=n);let s=this.hmac(this.encode(e),this.encode(this.secret),o.s);"GET"===i?n&&(c+="?"+n):"POST"===i&&(a={"Content-Type":"application/x-www-form-urlencoded"},n&&(r=n)),a={"ACCESS-KEY":this.apiKey,"ACCESS-SIGN":s,"ACCESS-TIMESTAMP":t}}else n&&(c+="?"+n);return{url:c,method:i,body:r,headers:a}}handleErrors(e,t,i,s,r,n,o,d,h){if(!o)return;let l=this.safeString(o,"code");if("0"===l||"200"===l)return;let c=this.id+" "+n;if(void 0===l)throw new a.BadResponse(c);let m=[a.ExchangeError,c],[p,u]=this.safeValue(this.exceptions.exact,l,m);throw new p(u)}}}}]);