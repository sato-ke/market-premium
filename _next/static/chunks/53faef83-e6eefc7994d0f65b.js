"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[886],{9482:(e,t,i)=>{i.d(t,{A:()=>h});var s=i(1965),r=i(8119),a=i(6077),o=i(3675),n=i(5432),d=i(1717);class h extends s.A{describe(){return this.deepExtend(super.describe(),{id:"coinex",name:"CoinEx",version:"v2",countries:["CN"],rateLimit:2.5,pro:!0,certified:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!0,borrowCrossMargin:!1,borrowIsolatedMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!0,createDepositAddress:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createReduceOnlyOrder:!0,createStopLossOrder:!0,createStopOrder:!0,createTakeProfitOrder:!0,createTriggerOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositWithdrawFee:!0,fetchDepositWithdrawFees:!1,fetchFundingHistory:!0,fetchFundingInterval:!0,fetchFundingIntervals:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!0,fetchIsolatedBorrowRates:!1,fetchLeverage:!0,fetchLeverages:!1,fetchLeverageTiers:!0,fetchMarginAdjustmentHistory:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!0,fetchPositionHistory:!0,fetchPositions:!0,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,repayCrossMargin:!1,repayIsolatedMargin:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","12h":"12hour","1d":"1day","3d":"3day","1w":"1week"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182089-1e05fa00-c2ec-11ea-8da9-cc73b45abbbc.jpg",api:{public:"https://api.coinex.com",private:"https://api.coinex.com",perpetualPublic:"https://api.coinex.com/perpetual",perpetualPrivate:"https://api.coinex.com/perpetual"},www:"https://www.coinex.com",doc:"https://docs.coinex.com/api/v2",fees:"https://www.coinex.com/fees",referral:"https://www.coinex.com/register?refer_code=yw5fz"},api:{v1:{public:{get:{"amm/market":1,"common/currency/rate":1,"common/asset/config":1,"common/maintain/info":1,"common/temp-maintain/info":1,"margin/market":1,"market/info":1,"market/list":1,"market/ticker":1,"market/ticker/all":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/detail":1}},private:{get:{"account/amm/balance":40,"account/investment/balance":40,"account/balance/history":40,"account/market/fee":40,"balance/coin/deposit":40,"balance/coin/withdraw":40,"balance/info":40,"balance/deposit/address/{coin_type}":40,"contract/transfer/history":40,"credit/info":40,"credit/balance":40,"investment/transfer/history":40,"margin/account":1,"margin/config":1,"margin/loan/history":40,"margin/transfer/history":40,"order/deals":40,"order/finished":40,"order/pending":8,"order/status":8,"order/status/batch":8,"order/user/deals":40,"order/stop/finished":40,"order/stop/pending":8,"order/user/trade/fee":1,"order/market/trade/info":1,"sub_account/balance":1,"sub_account/transfer/history":40,"sub_account/auth/api":40,"sub_account/auth/api/{user_auth_id}":40},post:{"balance/coin/withdraw":40,"contract/balance/transfer":40,"margin/flat":40,"margin/loan":40,"margin/transfer":40,"order/limit/batch":40,"order/ioc":13.334,"order/limit":13.334,"order/market":13.334,"order/modify":13.334,"order/stop/limit":13.334,"order/stop/market":13.334,"order/stop/modify":13.334,"sub_account/transfer":40,"sub_account/register":1,"sub_account/unfrozen":40,"sub_account/frozen":40,"sub_account/auth/api":40},put:{"balance/deposit/address/{coin_type}":40,"sub_account/unfrozen":40,"sub_account/frozen":40,"sub_account/auth/api/{user_auth_id}":40,"v1/account/settings":40},delete:{"balance/coin/withdraw":40,"order/pending/batch":40,"order/pending":13.334,"order/stop/pending":40,"order/stop/pending/{id}":13.334,"order/pending/by_client_id":40,"order/stop/pending/by_client_id":40,"sub_account/auth/api/{user_auth_id}":40,"sub_account/authorize/{id}":40}},perpetualPublic:{get:{ping:1,time:1,"market/list":1,"market/limit_config":1,"market/ticker":1,"market/ticker/all":1,"market/depth":1,"market/deals":1,"market/funding_history":1,"market/kline":1}},perpetualPrivate:{get:{"market/user_deals":1,"asset/query":40,"order/pending":8,"order/finished":40,"order/stop_finished":40,"order/stop_pending":8,"order/status":8,"order/stop_status":8,"position/finished":40,"position/pending":40,"position/funding":40,"position/adl_history":40,"market/preference":40,"position/margin_history":40,"position/settle_history":40},post:{"market/adjust_leverage":1,"market/position_expect":1,"order/put_limit":20,"order/put_market":20,"order/put_stop_limit":20,"order/put_stop_market":20,"order/modify":20,"order/modify_stop":20,"order/cancel":20,"order/cancel_all":40,"order/cancel_batch":40,"order/cancel_stop":20,"order/cancel_stop_all":40,"order/close_limit":20,"order/close_market":20,"position/adjust_margin":20,"position/stop_loss":20,"position/take_profit":20,"position/market_close":20,"order/cancel/by_client_id":20,"order/cancel_stop/by_client_id":20,"market/preference":20}}},v2:{public:{get:{"maintain/info":1,ping:1,time:1,"spot/market":1,"spot/ticker":1,"spot/depth":1,"spot/deals":1,"spot/kline":1,"spot/index":1,"futures/market":1,"futures/ticker":1,"futures/depth":1,"futures/deals":1,"futures/kline":1,"futures/index":1,"futures/funding-rate":1,"futures/funding-rate-history":1,"futures/position-level":1,"futures/liquidation-history":1,"futures/basis-history":1,"assets/deposit-withdraw-config":1,"assets/all-deposit-withdraw-config":1}},private:{get:{"account/subs":1,"account/subs/api-detail":40,"account/subs/info":1,"account/subs/api":40,"account/subs/transfer-history":40,"account/subs/spot-balance":1,"account/trade-fee-rate":40,"assets/spot/balance":40,"assets/futures/balance":40,"assets/margin/balance":1,"assets/financial/balance":40,"assets/amm/liquidity":40,"assets/credit/info":40,"assets/margin/borrow-history":40,"assets/margin/interest-limit":1,"assets/deposit-address":40,"assets/deposit-history":40,"assets/withdraw":40,"assets/transfer-history":40,"spot/order-status":8,"spot/batch-order-status":8,"spot/pending-order":8,"spot/finished-order":40,"spot/pending-stop-order":8,"spot/finished-stop-order":40,"spot/user-deals":40,"spot/order-deals":40,"futures/order-status":8,"futures/batch-order-status":1,"futures/pending-order":8,"futures/finished-order":40,"futures/pending-stop-order":8,"futures/finished-stop-order":40,"futures/user-deals":1,"futures/order-deals":1,"futures/pending-position":40,"futures/finished-position":1,"futures/position-margin-history":1,"futures/position-funding-history":40,"futures/position-adl-history":1,"futures/position-settle-history":1},post:{"account/subs":40,"account/subs/frozen":40,"account/subs/unfrozen":40,"account/subs/api":40,"account/subs/edit-api":40,"account/subs/delete-api":40,"account/subs/transfer":40,"account/settings":40,"assets/margin/borrow":40,"assets/margin/repay":40,"assets/renewal-deposit-address":40,"assets/withdraw":40,"assets/cancel-withdraw":40,"assets/transfer":40,"assets/amm/add-liquidity":1,"assets/amm/remove-liquidity":1,"spot/order":13.334,"spot/stop-order":13.334,"spot/batch-order":40,"spot/batch-stop-order":1,"spot/modify-order":13.334,"spot/modify-stop-order":13.334,"spot/cancel-all-order":1,"spot/cancel-order":6.667,"spot/cancel-stop-order":6.667,"spot/cancel-batch-order":10,"spot/cancel-batch-stop-order":10,"spot/cancel-order-by-client-id":1,"spot/cancel-stop-order-by-client-id":1,"futures/order":20,"futures/stop-order":20,"futures/batch-order":1,"futures/batch-stop-order":1,"futures/modify-order":20,"futures/modify-stop-order":20,"futures/cancel-all-order":1,"futures/cancel-order":10,"futures/cancel-stop-order":10,"futures/cancel-batch-order":20,"futures/cancel-batch-stop-order":20,"futures/cancel-order-by-client-id":1,"futures/cancel-stop-order-by-client-id":1,"futures/close-position":20,"futures/adjust-position-margin":20,"futures/adjust-position-leverage":20,"futures/set-position-stop-loss":20,"futures/set-position-take-profit":20}}}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BCH:0,BTC:.001,LTC:.001,ETH:.001,ZEC:1e-4,DASH:1e-4}}},limits:{amount:{min:.001,max:void 0}},options:{brokerId:"x-167673045",createMarketBuyOrderRequiresPrice:!0,defaultType:"spot",defaultSubType:"linear",fetchDepositAddress:{fillResponseFromRequest:!0},accountsByType:{spot:"SPOT",margin:"MARGIN",swap:"FUTURES"},accountsById:{SPOT:"spot",MARGIN:"margin",FUTURES:"swap"},networks:{BTC:"BTC",BEP20:"BSC",TRC20:"TRC20",ERC20:"ERC20",BRC20:"BRC20",SOL:"SOL",TON:"SOL",BSV:"BSV",AVAXC:"AVA_C",AVAXX:"AVA",SUI:"SUI",ACA:"ACA",CHZ:"CHILIZ",ADA:"ADA",ARB:"ARBITRUM",ARBNOVA:"ARBITRUM_NOVA",OP:"OPTIMISM",APT:"APTOS",ATOM:"ATOM",FTM:"FTM",BCH:"BCH",ASTR:"ASTR",LTC:"LTC",MATIC:"MATIC",CRONOS:"CRONOS",DASH:"DASH",DOT:"DOT",ETC:"ETC",ETHW:"ETHPOW",FIL:"FIL",ZIL:"ZIL",DOGE:"DOGE",TIA:"CELESTIA",SEI:"SEI",XRP:"XRP",XMR:"XMR"}},features:{spot:{sandbox:!1,createOrder:{marginMode:!0,triggerPrice:!0,triggerPriceType:void 0,triggerDirection:!1,stopLossPrice:!1,takeProfitPrice:!1,attachedStopLossTakeProfit:void 0,timeInForce:{IOC:!0,FOK:!0,PO:!0,GTD:!1},hedged:!1,trailing:!1,leverage:!1,marketBuyByCost:!0,marketBuyRequiresPrice:!0,selfTradePrevention:!0,iceberg:!0},createOrders:{max:5},fetchMyTrades:{marginMode:!0,limit:1e3,daysBack:void 0,untilDays:1e5},fetchOrder:{marginMode:!1,trigger:!1,trailing:!1},fetchOpenOrders:{marginMode:!0,limit:1e3,trigger:!0,trailing:!1},fetchOrders:void 0,fetchClosedOrders:{marginMode:!0,limit:1e3,daysBack:void 0,daysBackCanceled:void 0,untilDays:void 0,trigger:!0,trailing:!1},fetchOHLCV:{limit:1e3}},forDerivatives:{extends:"spot",createOrder:{marginMode:!0,stopLossPrice:!0,takeProfitPrice:!0},fetchOpenOrders:{marginMode:!1},fetchClosedOrders:{marginMode:!1}},swap:{linear:{extends:"forDerivatives"},inverse:{extends:"forDerivatives"}},future:{linear:void 0,inverse:void 0}},commonCurrencies:{ACM:"Actinium"},precisionMode:o.kb,exceptions:{exact:{23:r.PermissionDenied,24:r.AuthenticationError,25:r.AuthenticationError,34:r.AuthenticationError,35:r.ExchangeNotAvailable,36:r.RequestTimeout,213:r.RateLimitExceeded,107:r.InsufficientFunds,158:r.PermissionDenied,600:r.OrderNotFound,601:r.InvalidOrder,602:r.InvalidOrder,606:r.InvalidOrder,3008:r.RequestTimeout,3109:r.InsufficientFunds,3127:r.InvalidOrder,3600:r.OrderNotFound,3606:r.InvalidOrder,3610:r.ExchangeError,3612:r.InvalidOrder,3613:r.InvalidOrder,3614:r.InvalidOrder,3615:r.InvalidOrder,3616:r.InvalidOrder,3617:r.InvalidOrder,3618:r.InvalidOrder,3619:r.InvalidOrder,3620:r.InvalidOrder,3621:r.InvalidOrder,3622:r.InvalidOrder,3627:r.InvalidOrder,3628:r.InvalidOrder,3629:r.InvalidOrder,3632:r.InvalidOrder,3633:r.InvalidOrder,3634:r.InvalidOrder,3635:r.InvalidOrder,4001:r.ExchangeNotAvailable,4002:r.RequestTimeout,4003:r.ExchangeError,4004:r.BadRequest,4005:r.AuthenticationError,4006:r.AuthenticationError,4007:r.PermissionDenied,4008:r.AuthenticationError,4009:r.ExchangeError,4010:r.ExchangeError,4011:r.PermissionDenied,4017:r.ExchangeError,4115:r.AccountSuspended,4117:r.BadSymbol,4123:r.RateLimitExceeded,4130:r.ExchangeError,4158:r.ExchangeError,4213:r.RateLimitExceeded,4512:r.PermissionDenied},broad:{"ip not allow visit":r.PermissionDenied,"service too busy":r.ExchangeNotAvailable}}})}async fetchCurrencies(e={}){let t=await this.v2PublicGetAssetsAllDepositWithdrawConfig(e),i=this.safeList(t,"data",[]),s={};for(let e=0;e<i.length;e++){let t=i[e],r=this.safeDict(t,"asset",{}),a=this.safeList(t,"chains",[]),o=this.safeString(r,"ccy");if(void 0===o)continue;let n=this.safeCurrencyCode(o),d=this.safeBool(r,"deposit_enabled"),h=this.safeBool(r,"withdraw_enabled"),c=this.safeDict(a,0,{}),l=this.parsePrecision(this.safeString(c,"withdrawal_precision"));s[n]={id:o,code:n,name:void 0,active:d&&h,deposit:d,withdraw:h,fee:void 0,precision:this.parseNumber(l),limits:{amount:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},networks:{},info:t};for(let e=0;e<a.length;e++){let t=a[e],i=this.safeString(t,"chain"),r=this.parsePrecision(this.safeString(t,"withdrawal_precision")),o=this.safeString(t,"withdrawal_fee"),d=this.safeString(t,"min_deposit_amount"),h=this.safeString(t,"min_withdraw_amount"),c=this.safeBool(t,"deposit_enabled"),l=this.safeBool(t,"withdraw_enabled"),u={id:i,network:i,name:void 0,active:c&&l,deposit:c,withdraw:l,fee:this.parseNumber(o),precision:this.parseNumber(r),limits:{amount:{min:void 0,max:void 0},deposit:{min:this.parseNumber(d),max:void 0},withdraw:{min:this.parseNumber(h),max:void 0}},info:t},f=this.safeDict(s[n],"networks",{});f[i]=u,s[n].networks=f}}return s}async fetchMarkets(e={}){let t=[this.fetchSpotMarkets(e),this.fetchContractMarkets(e)],i=await Promise.all(t),s=i[0],r=i[1];return this.arrayConcat(s,r)}async fetchSpotMarkets(e){let t=await this.v2PublicGetSpotMarket(e),i=this.safeList(t,"data",[]),s=[];for(let e=0;e<i.length;e++){let t=i[e],r=this.safeString(t,"market"),a=this.safeString(t,"base_ccy"),o=this.safeString(t,"quote_ccy"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h=n+"/"+d;s.push({id:r,symbol:h,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(t,"taker_fee_rate"),maker:this.safeNumber(t,"maker_fee_rate"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"base_ccy_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"quote_ccy_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"min_amount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return s}async fetchContractMarkets(e){let t=await this.v2PublicGetFuturesMarket(e),i=this.safeList(t,"data",[]),s=[];for(let e=0;e<i.length;e++){let t=i[e],r=this.fees,a=this.safeList(t,"leverage",[]),o=this.safeString(t,"contract_type"),n="linear"===o,d="inverse"===o,h=this.safeString(t,"market"),c=this.safeString(t,"base_ccy"),l=this.safeString(t,"quote_ccy"),u=this.safeCurrencyCode(c),f=this.safeCurrencyCode(l),p="linear"===o?"USDT":c,m=this.safeCurrencyCode(p),g=u+"/"+f+":"+m,v=a.length;s.push({id:h,symbol:g,base:u,quote:f,settle:m,baseId:c,quoteId:l,settleId:p,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:void 0,contract:!0,linear:n,inverse:d,taker:r.trading.taker,maker:r.trading.maker,contractSize:this.parseNumber("1"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"base_ccy_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"quote_ccy_precision")))},limits:{leverage:{min:this.safeNumber(a,0),max:this.safeNumber(a,v-1)},amount:{min:this.safeNumber(t,"min_amount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return s}parseTicker(e,t){let i="mark_price"in e?"swap":"spot",s=this.safeString(e,"market"),r=this.safeSymbol(s,t,void 0,i);return this.safeTicker({symbol:r,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:this.safeString(e,"volume_buy"),ask:void 0,askVolume:this.safeString(e,"volume_sell"),vwap:void 0,open:this.safeString(e,"open"),close:this.safeString(e,"close"),last:this.safeString(e,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,markPrice:this.safeString(e,"mark_price"),indexPrice:this.safeString(e,"index_price"),info:e},t)}async fetchTicker(e,t={}){let i;await this.loadMarkets();let s=this.market(e),r={market:s.id};i=s.swap?await this.v2PublicGetFuturesTicker(this.extend(r,t)):await this.v2PublicGetSpotTicker(this.extend(r,t));let a=this.safeList(i,"data",[]),o=this.safeDict(a,0,{});return this.parseTicker(o,s)}async fetchTickers(e,t={}){let i,s;if(await this.loadMarkets(),void 0!==(e=this.marketSymbols(e))){let t=this.safeValue(e,0);i=this.market(t)}let[r,a]=this.handleMarketTypeAndParams("fetchTickers",i,t);s="swap"===r?await this.v2PublicGetFuturesTicker(a):await this.v2PublicGetSpotTicker(a);let o=this.safeList(s,"data",[]);return this.parseTickers(o,e)}async fetchTime(e={}){let t=await this.v2PublicGetTime(e),i=this.safeDict(t,"data",{});return this.safeInteger(i,"timestamp")}async fetchOrderBook(e,t=20,i={}){let s;await this.loadMarkets();let r=this.market(e);void 0===t&&(t=20);let a={market:r.id,limit:t,interval:"0"};s=r.swap?await this.v2PublicGetFuturesDepth(this.extend(a,i)):await this.v2PublicGetSpotDepth(this.extend(a,i));let o=this.safeDict(s,"data",{}),n=this.safeDict(o,"depth",{}),d=this.safeInteger(n,"updated_at");return this.parseOrderBook(n,e,d)}parseTrade(e,t){let i;let s=this.safeInteger(e,"created_at"),r=this.safeString(this.options,"defaultType");void 0!==t&&(r=t.type);let a=this.safeString(e,"market");t=this.safeMarket(a,t,void 0,r);let o=this.safeString(e,"fee");if(void 0!==o){let t=this.safeString(e,"fee_ccy");i={cost:o,currency:this.safeCurrencyCode(t)}}return this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:this.safeString(e,"deal_id"),order:this.safeString(e,"order_id"),type:void 0,side:this.safeString(e,"side"),takerOrMaker:this.safeString(e,"role"),price:this.safeString(e,"price"),amount:this.safeString(e,"amount"),cost:this.safeString(e,"deal_money"),fee:i},t)}async fetchTrades(e,t,i,s={}){let r;await this.loadMarkets();let a=this.market(e),o={market:a.id};return void 0!==i&&(o.limit=i),r=a.swap?await this.v2PublicGetFuturesDeals(this.extend(o,s)):await this.v2PublicGetSpotDeals(this.extend(o,s)),this.parseTrades(r.data,a,t,i)}async fetchTradingFee(e,t={}){let i;await this.loadMarkets();let s=this.market(e),r={market:s.id};i=s.spot?await this.v2PublicGetSpotMarket(this.extend(r,t)):await this.v2PublicGetFuturesMarket(this.extend(r,t));let a=this.safeList(i,"data",[]),o=this.safeDict(a,0,{});return this.parseTradingFee(o,s)}async fetchTradingFees(e={}){let t,i;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchTradingFees",void 0,e),i="swap"===t?await this.v2PublicGetFuturesMarket(e):await this.v2PublicGetSpotMarket(e);let s=this.safeList(i,"data",[]),r={};for(let e=0;e<s.length;e++){let i=s[e],a=this.safeString(i,"market"),o=this.safeMarket(a,void 0,void 0,t);r[o.symbol]=this.parseTradingFee(i,o)}return r}parseTradingFee(e,t){let i=this.safeValue(e,"market");return{info:e,symbol:this.safeSymbol(i,t),maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate"),percentage:!0,tierBased:!0}}parseOHLCV(e,t){return[this.safeInteger(e,"created_at"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"value")]}async fetchOHLCV(e,t="1m",i,s,r={}){let a;await this.loadMarkets();let o=this.market(e),n={market:o.id,period:this.safeString(this.timeframes,t,t)};void 0!==s&&(n.limit=s),a=o.swap?await this.v2PublicGetFuturesKline(this.extend(n,r)):await this.v2PublicGetSpotKline(this.extend(n,r));let d=this.safeList(a,"data",[]);return this.parseOHLCVs(d,o,t,i,s)}async fetchMarginBalance(e={}){await this.loadMarkets();let t=await this.v2PrivateGetAssetsMarginBalance(e),i={info:t},s=this.safeList(t,"data",[]);for(let e=0;e<s.length;e++){let t=s[e],r=this.safeDict(t,"available",{}),o=this.safeDict(t,"frozen",{}),n=this.safeDict(t,"repaid",{}),d=this.safeDict(t,"interest",{}),h=this.account(),c=this.safeString(t,"base_ccy"),l=this.safeCurrencyCode(c);h.free=this.safeString(r,"base_ccy"),h.used=this.safeString(o,"base_ccy");let u=this.safeString(n,"base_ccy"),f=this.safeString(d,"base_ccy");h.debt=a.Y.stringAdd(u,f),i[l]=h}return this.safeBalance(i)}async fetchSpotBalance(e={}){await this.loadMarkets();let t=await this.v2PrivateGetAssetsSpotBalance(e),i={info:t},s=this.safeList(t,"data",[]);for(let e=0;e<s.length;e++){let t=s[e],r=this.safeString(t,"ccy"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"available"),o.used=this.safeString(t,"frozen"),i[a]=o}return this.safeBalance(i)}async fetchSwapBalance(e={}){await this.loadMarkets();let t=await this.v2PrivateGetAssetsFuturesBalance(e),i={info:t},s=this.safeList(t,"data",[]);for(let e=0;e<s.length;e++){let t=s[e],r=this.safeString(t,"ccy"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"available"),o.used=this.safeString(t,"frozen"),i[a]=o}return this.safeBalance(i)}async fetchFinancialBalance(e={}){await this.loadMarkets();let t=await this.v2PrivateGetAssetsFinancialBalance(e),i={info:t},s=this.safeList(t,"data",[]);for(let e=0;e<s.length;e++){let t=s[e],r=this.safeString(t,"ccy"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"available"),o.used=this.safeString(t,"frozen"),i[a]=o}return this.safeBalance(i)}async fetchBalance(e={}){let t,i;return([t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[i,e]=this.handleMarginModeAndParams("fetchBalance",e),"swap"===t)?await this.fetchSwapBalance(e):"financial"===t?await this.fetchFinancialBalance(e):void 0!==i||"margin"===t?await this.fetchMarginBalance(e):await this.fetchSpotBalance(e)}parseOrderStatus(e){return this.safeString({rejected:"rejected",open:"open",not_deal:"open",part_deal:"open",done:"closed",cancel:"canceled"},e,e)}parseOrder(e,t){let i=this.safeString(e,"status"),s=this.safeInteger(e,"created_at"),r=this.safeInteger(e,"updated_at");0===r&&(r=s);let a=this.safeString(e,"market"),o=this.safeString(this.options,"defaultType"),n=this.safeStringLower(e,"market_type",o);"futures"===n&&(n="swap");let d="swap"===n?"swap":"spot";t=this.safeMarket(a,t,void 0,d);let h=this.safeString(e,"fee_ccy"),c=this.safeCurrencyCode(h);void 0===c&&(c=t.quote);let l=this.safeString(e,"side");"long"===l?l="buy":"short"===l&&(l="sell");let u=this.safeString(e,"client_id");return""===u&&(u=void 0),this.safeOrder({id:this.safeStringN(e,["position_id","order_id","stop_id"]),clientOrderId:u,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:r,status:this.parseOrderStatus(i),symbol:t.symbol,type:this.safeString(e,"type"),timeInForce:void 0,postOnly:void 0,reduceOnly:void 0,side:l,price:this.safeString(e,"price"),triggerPrice:this.safeString(e,"trigger_price"),takeProfitPrice:this.safeNumber(e,"take_profit_price"),stopLossPrice:this.safeNumber(e,"stop_loss_price"),cost:this.safeString(e,"filled_value"),average:this.safeString(e,"avg_entry_price"),amount:this.safeString(e,"amount"),filled:this.safeString(e,"filled_amount"),remaining:this.safeString(e,"unfilled_amount"),trades:void 0,fee:{currency:c,cost:this.safeString2(e,"quote_fee","fee")},info:e},t)}async createMarketBuyOrderWithCost(e,t,i={}){if(await this.loadMarkets(),!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return i.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,i)}createOrderRequest(e,t,i,s,o,n={}){let d=this.market(e),h=d.swap,c=this.safeString2(n,"client_id","clientOrderId"),l=this.safeString2(n,"stopPrice","triggerPrice"),u=this.safeString(n,"stopLossPrice"),f=this.safeString(n,"takeProfitPrice"),p=this.safeString(n,"option"),m="market"===t,g=this.isPostOnly(m,"maker_only"===p,n),v=this.safeStringUpper(n,"timeInForce"),y=this.safeBool(n,"reduceOnly");if(y&&!d.swap)throw new r.InvalidOrder(this.id+" createOrder() does not support reduceOnly for "+d.type+" orders, reduceOnly orders are supported for swap markets only");let w={market:d.id};if(void 0===c){let e=this.safeString(this.options,"brokerId","x-167673045");w.client_id=e+"-"+this.uuid16()}else w.client_id=c;if(void 0===u&&void 0===f){y||(w.side=i);let s=t;g?s="maker_only":void 0!==v&&("IOC"===v?s="ioc":"FOK"===v&&(s="fok")),m||(w.price=this.priceToPrecision(e,o)),w.type=s}if(h)w.market_type="FUTURES",u||f?u?(w.stop_loss_price=this.priceToPrecision(e,u),w.stop_loss_type=this.safeString(n,"stop_type","latest_price")):f&&(w.take_profit_price=this.priceToPrecision(e,f),w.take_profit_type=this.safeString(n,"stop_type","latest_price")):(w.amount=this.amountToPrecision(e,s),void 0!==l&&(w.trigger_price=this.priceToPrecision(e,l),w.trigger_price_type=this.safeString(n,"stop_type","latest_price")));else{let d;if([d,n]=this.handleMarginModeAndParams("createOrder",n),void 0!==d?w.market_type="MARGIN":w.market_type="SPOT","market"===t&&"buy"===i){let t=!0;[t,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);let i=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),t){if(void 0===o&&void 0===i)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{let t=this.numberToString(s),r=this.numberToString(o),n=this.parseToNumeric(a.Y.stringMul(t,r));w.amount=this.costToPrecision(e,void 0!==i?i:n)}}else w.amount=this.costToPrecision(e,s)}else w.amount=this.amountToPrecision(e,s);void 0!==l&&(w.trigger_price=this.priceToPrecision(e,l))}return n=this.omit(n,["reduceOnly","timeInForce","postOnly","stopPrice","triggerPrice","stopLossPrice","takeProfitPrice"]),this.extend(w,n)}async createOrder(e,t,i,s,r,a={}){let o;await this.loadMarkets();let n=this.market(e),d=this.safeBool(a,"reduceOnly"),h=this.safeString2(a,"stopPrice","triggerPrice"),c=this.safeString(a,"stopLossPrice"),l=this.safeString(a,"takeProfitPrice"),u=void 0!==h,f=void 0!==c,p=void 0!==l,m=this.createOrderRequest(e,t,i,s,r,a);n.spot?o=u?await this.v2PrivatePostSpotStopOrder(m):await this.v2PrivatePostSpotOrder(m):u?o=await this.v2PrivatePostFuturesStopOrder(m):f||p?f?o=await this.v2PrivatePostFuturesSetPositionStopLoss(m):p&&(o=await this.v2PrivatePostFuturesSetPositionTakeProfit(m)):o=d?await this.v2PrivatePostFuturesClosePosition(m):await this.v2PrivatePostFuturesOrder(m);let g=this.safeDict(o,"data",{});return this.parseOrder(g,n)}async createOrders(e,t={}){let i,s;await this.loadMarkets();let a=[],o=!1,n=!1,d=!1;for(let t=0;t<e.length;t++){let s=e[t],h=this.safeString(s,"symbol");if(void 0===i)i=h;else if(i!==h)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");let c=this.safeString(s,"type"),l=this.safeString(s,"side"),u=this.safeValue(s,"amount"),f=this.safeValue(s,"price"),p=this.safeValue(s,"params",{});if("limit"!==c)throw new r.NotSupported(this.id+" createOrders() does not support "+c+" orders, only limit orders are accepted");o=this.safeValue(p,"reduceOnly");let m=this.safeNumber2(p,"stopPrice","triggerPrice"),g=this.safeNumber(p,"stopLossPrice"),v=this.safeNumber(p,"takeProfitPrice");n=void 0!==m;let y=void 0!==v;d=void 0!==g||y;let w=this.createOrderRequest(h,c,l,u,f,p);a.push(w)}let h=this.market(i),c={market:h.id,orders:a};if(h.spot)s=n?await this.v2PrivatePostSpotBatchStopOrder(c):await this.v2PrivatePostSpotBatchOrder(c);else if(n)s=await this.v2PrivatePostFuturesBatchStopOrder(c);else if(d)throw new r.NotSupported(this.id+" createOrders() does not support stopLossPrice or takeProfitPrice orders");else{if(o)throw new r.NotSupported(this.id+" createOrders() does not support reduceOnly orders");s=await this.v2PrivatePostFuturesBatchOrder(c)}let l=this.safeList(s,"data",[]),u=[];for(let e=0;e<l.length;e++){let t,i;let s=l[e],r=this.safeInteger(s,"code");void 0!==r&&(t=0!==r?"rejected":"open");let a=this.safeDict(s,"data",{});h.spot&&!n?(s.status=t,i=this.parseOrder(s,h)):(a.status=t,i=this.parseOrder(a,h)),u.push(i)}return u}async cancelOrders(e,t,i={}){let s;if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();let a=this.market(t),o={market:a.id},n=this.safeBool2(i,"stop","trigger");i=this.omit(i,["stop","trigger"]);let d=[];for(let t=0;t<e.length;t++)d.push(parseInt(e[t]));n?o.stop_ids=d:o.order_ids=d,a.spot?s=n?await this.v2PrivatePostSpotCancelBatchStopOrder(this.extend(o,i)):await this.v2PrivatePostSpotCancelBatchOrder(this.extend(o,i)):(o.market_type="FUTURES",s=n?await this.v2PrivatePostFuturesCancelBatchStopOrder(this.extend(o,i)):await this.v2PrivatePostFuturesCancelBatchOrder(this.extend(o,i)));let h=this.safeList(s,"data",[]),c=[];for(let e=0;e<h.length;e++){let t=h[e],i=this.safeDict(t,"data",{}),s=this.parseOrder(i,a);c.push(s)}return c}async editOrder(e,t,i,s,a,o,n={}){let d,h;if(void 0===t)throw new r.ArgumentsRequired(this.id+" editOrder() requires a symbol argument");await this.loadMarkets();let c=this.market(t),l={market:c.id};void 0!==a&&(l.amount=this.amountToPrecision(t,a)),void 0!==o&&(l.price=this.priceToPrecision(t,o));let u=this.safeStringN(n,["stopPrice","triggerPrice","trigger_price"]);n=this.omit(n,["stopPrice","triggerPrice"]);let f=void 0!==u;f?(l.trigger_price=this.priceToPrecision(t,u),l.stop_id=this.parseToNumeric(e)):l.order_id=this.parseToNumeric(e),[h,n]=this.handleMarginModeAndParams("editOrder",n),c.spot?(void 0!==h?l.market_type="MARGIN":l.market_type="SPOT",d=f?await this.v2PrivatePostSpotModifyStopOrder(this.extend(l,n)):await this.v2PrivatePostSpotModifyOrder(this.extend(l,n))):(l.market_type="FUTURES",d=f?await this.v2PrivatePostFuturesModifyStopOrder(this.extend(l,n)):await this.v2PrivatePostFuturesModifyOrder(this.extend(l,n)));let p=this.safeDict(d,"data",{});return this.parseOrder(p,c)}async cancelOrder(e,t,i={}){let s,a,o;if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();let n=this.market(t),d=this.safeBool2(i,"stop","trigger"),h=n.swap,c={market:n.id};[s,i]=this.handleMarginModeAndParams("cancelOrder",i),h?c.market_type="FUTURES":void 0!==s?c.market_type="MARGIN":c.market_type="SPOT";let l=this.safeString2(i,"client_id","clientOrderId");if(i=this.omit(i,["stop","trigger","clientOrderId"]),void 0!==l?(c.client_id=l,a=d?h?await this.v2PrivatePostFuturesCancelStopOrderByClientId(this.extend(c,i)):await this.v2PrivatePostSpotCancelStopOrderByClientId(this.extend(c,i)):h?await this.v2PrivatePostFuturesCancelOrderByClientId(this.extend(c,i)):await this.v2PrivatePostSpotCancelOrderByClientId(this.extend(c,i))):d?(c.stop_id=this.parseToNumeric(e),a=h?await this.v2PrivatePostFuturesCancelStopOrder(this.extend(c,i)):await this.v2PrivatePostSpotCancelStopOrder(this.extend(c,i))):(c.order_id=this.parseToNumeric(e),a=h?await this.v2PrivatePostFuturesCancelOrder(this.extend(c,i)):await this.v2PrivatePostSpotCancelOrder(this.extend(c,i))),void 0!==l){let e=this.safeList(a,"data",[]);o=this.safeDict(e[0],"data",{})}else o=this.safeDict(a,"data",{});return this.parseOrder(o,n)}async cancelAllOrders(e,t={}){let i;if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();let s=this.market(e),a={market:s.id};if(s.swap)a.market_type="FUTURES",i=await this.v2PrivatePostFuturesCancelAllOrder(this.extend(a,t));else{let e;[e,t]=this.handleMarginModeAndParams("cancelAllOrders",t),void 0!==e?a.market_type="MARGIN":a.market_type="SPOT",i=await this.v2PrivatePostSpotCancelAllOrder(this.extend(a,t))}return[this.safeOrder({info:i})]}async fetchOrder(e,t,i={}){let s;if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();let a=this.market(t),o={market:a.id,order_id:this.parseToNumeric(e)};s=a.swap?await this.v2PrivateGetFuturesOrderStatus(this.extend(o,i)):await this.v2PrivateGetSpotOrderStatus(this.extend(o,i));let n=this.safeDict(s,"data",{});return this.parseOrder(n,a)}async fetchOrdersByStatus(e,t,i,s,r={}){let a,o,n;await this.loadMarkets();let d={};void 0!==t&&(a=this.market(t),d.market=a.id),void 0!==s&&(d.limit=s);let h=this.safeBool2(r,"stop","trigger");r=this.omit(r,["stop","trigger"]),[o,r]=this.handleMarketTypeAndParams("fetchOrdersByStatus",a,r);let c="finished"===e||"closed"===e;if("swap"===o)d.market_type="FUTURES",c?n=h?await this.v2PrivateGetFuturesFinishedStopOrder(this.extend(d,r)):await this.v2PrivateGetFuturesFinishedOrder(this.extend(d,r)):("pending"===e||"open"===e)&&(n=h?await this.v2PrivateGetFuturesPendingStopOrder(this.extend(d,r)):await this.v2PrivateGetFuturesPendingOrder(this.extend(d,r)));else{let t;[t,r]=this.handleMarginModeAndParams("fetchOrdersByStatus",r),void 0!==t?d.market_type="MARGIN":d.market_type="SPOT",c?n=h?await this.v2PrivateGetSpotFinishedStopOrder(this.extend(d,r)):await this.v2PrivateGetSpotFinishedOrder(this.extend(d,r)):"pending"===e&&(n=h?await this.v2PrivateGetSpotPendingStopOrder(this.extend(d,r)):await this.v2PrivateGetSpotPendingOrder(this.extend(d,r)))}let l=this.safeList(n,"data",[]);return this.parseOrders(l,a,i,s)}async fetchOpenOrders(e,t,i,s={}){let r=await this.fetchOrdersByStatus("pending",e,t,i,s);for(let e=0;e<r.length;e++)r[e].status="open";return r}async fetchClosedOrders(e,t,i,s={}){return await this.fetchOrdersByStatus("finished",e,t,i,s)}async createDepositAddress(e,t={}){await this.loadMarkets();let i=this.currency(e),s=this.safeString2(t,"chain","network");if(void 0===s)throw new r.ArgumentsRequired(this.id+" createDepositAddress() requires a network parameter");t=this.omit(t,"network");let a={ccy:i.id,chain:this.networkCodeToId(s,i.code)},o=await this.v2PrivatePostAssetsRenewalDepositAddress(this.extend(a,t)),n=this.safeDict(o,"data",{});return this.parseDepositAddress(n,i)}async fetchDepositAddress(e,t={}){let i;await this.loadMarkets();let s=this.currency(e),a={ccy:s.id};if([i,t]=this.handleNetworkCodeAndParams(t),void 0===i)throw new r.ArgumentsRequired(this.id+' fetchDepositAddress() requires a "network" parameter');a.chain=this.networkCodeToId(i);let o=await this.v2PrivateGetAssetsDepositAddress(this.extend(a,t)),n=this.safeDict(o,"data",{});return this.parseDepositAddress(n,s)}parseDepositAddress(e,t){let i,s;let r=this.safeString(e,"address"),a=r.split(":");return a.length>1&&"cfx"!==a[0]?(i=a[0],s=a[1]):i=r,{info:e,currency:this.safeCurrencyCode(void 0,t),network:void 0,address:i,tag:s}}async fetchMyTrades(e,t,i,s={}){let a;if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();let o=this.market(e),n={market:o.id};if(void 0!==i&&(n.limit=i),void 0!==t&&(n.start_time=t),[n,s]=this.handleUntilOption("end_time",n,s),o.swap)n.market_type="FUTURES",a=await this.v2PrivateGetFuturesUserDeals(this.extend(n,s));else{let e;[e,s]=this.handleMarginModeAndParams("fetchMyTrades",s),void 0!==e?n.market_type="MARGIN":n.market_type="SPOT",a=await this.v2PrivateGetSpotUserDeals(this.extend(n,s))}let d=this.safeList(a,"data",[]);return this.parseTrades(d,o,t,i)}async fetchPositions(e,t={}){let i,s,a;await this.loadMarkets(),[i,t]=this.handleOptionAndParams(t,"fetchPositions","method","v2PrivateGetFuturesPendingPosition");let o={market_type:"FUTURES"};if(void 0!==(e=this.marketSymbols(e))){let t;if(Array.isArray(e)){if(e.length>1)throw new r.BadRequest(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");t=e[0]}else t=e;s=this.market(t),o.market=s.id}a="v2PrivateGetFuturesPendingPosition"===i?await this.v2PrivateGetFuturesPendingPosition(this.extend(o,t)):await this.v2PrivateGetFuturesFinishedPosition(this.extend(o,t));let n=this.safeList(a,"data",[]),d=[];for(let e=0;e<n.length;e++)d.push(this.parsePosition(n[e],s));return this.filterByArrayPositions(d,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();let i=this.market(e),s={market_type:"FUTURES",market:i.id},r=await this.v2PrivateGetFuturesPendingPosition(this.extend(s,t)),a=this.safeList(r,"data",[]);return this.parsePosition(a[0],i)}parsePosition(e,t){let i=this.safeString(e,"market");t=this.safeMarket(i,t,void 0,"swap");let s=this.safeInteger(e,"created_at");return this.safePosition({info:e,id:this.safeInteger(e,"position_id"),symbol:t.symbol,notional:this.safeNumber(e,"settle_value"),marginMode:this.safeString(e,"margin_mode"),liquidationPrice:this.safeNumber(e,"liq_price"),entryPrice:this.safeNumber(e,"avg_entry_price"),unrealizedPnl:this.safeNumber(e,"unrealized_pnl"),realizedPnl:this.safeNumber(e,"realized_pnl"),percentage:void 0,contracts:this.safeNumber(e,"close_avbl"),contractSize:this.safeNumber(t,"contractSize"),markPrice:void 0,lastPrice:void 0,side:this.safeString(e,"side"),hedged:void 0,timestamp:s,datetime:this.iso8601(s),lastUpdateTimestamp:this.safeInteger(e,"updated_at"),maintenanceMargin:this.safeNumber(e,"maintenance_margin_value"),maintenanceMarginPercentage:this.safeNumber(e,"maintenance_margin_rate"),collateral:this.safeNumber(e,"margin_avbl"),initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeNumber(e,"leverage"),marginRatio:this.safeNumber(e,"position_margin_rate"),stopLossPrice:this.omitZero(this.safeString(e,"stop_loss_price")),takeProfitPrice:this.omitZero(this.safeString(e,"take_profit_price"))})}async setMarginMode(e,t,i={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");if("isolated"!==(e=e.toLowerCase())&&"cross"!==e)throw new r.BadRequest(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets();let s=this.market(t);if("swap"!==s.type)throw new r.BadSymbol(this.id+" setMarginMode() supports swap contracts only");let a=this.safeInteger(i,"leverage"),o=this.safeInteger(s.limits.leverage,"max",100);if(void 0===a)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a leverage parameter");if(a<1||a>o)throw new r.BadRequest(this.id+" setMarginMode() leverage should be between 1 and "+o.toString()+" for "+t);let n={market:s.id,market_type:"FUTURES",margin_mode:e,leverage:a};return await this.v2PrivatePostFuturesAdjustPositionLeverage(this.extend(n,i))}async setLeverage(e,t,i={}){let s;if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();let a=this.market(t);if(!a.swap)throw new r.BadSymbol(this.id+" setLeverage() supports swap contracts only");[s,i]=this.handleMarginModeAndParams("setLeverage",i,"cross");let o=this.safeInteger(a.limits.leverage,"min",1),n=this.safeInteger(a.limits.leverage,"max",100);if(e<o||e>n)throw new r.BadRequest(this.id+" setLeverage() leverage should be between "+o.toString()+" and "+n.toString()+" for "+t);let d={market:a.id,market_type:"FUTURES",margin_mode:s,leverage:e};return await this.v2PrivatePostFuturesAdjustPositionLeverage(this.extend(d,i))}async fetchLeverageTiers(e,t={}){await this.loadMarkets();let i={};if(void 0!==e){let t=this.marketIds(e);i.market=t.join(",")}let s=await this.v2PublicGetFuturesPositionLevel(this.extend(i,t)),r=this.safeList(s,"data",[]);return this.parseLeverageTiers(r,e,"market")}parseMarketLeverageTiers(e,t){let i=[],s=this.safeList(e,"level",[]),r=0;for(let a=0;a<s.length;a++){let o=s[a],n=this.safeString(e,"market");t=this.safeMarket(n,t,void 0,"swap");let d=this.safeNumber(o,"amount");i.push({tier:this.sum(a,1),symbol:this.safeSymbol(n,t,void 0,"swap"),currency:t.linear?t.base:t.quote,minNotional:r,maxNotional:d,maintenanceMarginRate:this.safeNumber(o,"maintenance_margin_rate"),maxLeverage:this.safeInteger(o,"leverage"),info:o}),r=d}return i}async modifyMarginHelper(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),o=this.amountToPrecision(e,t),n=o;"reduce"===i&&(n=a.Y.stringNeg(o));let d={market:r.id,market_type:"FUTURES",amount:n},h=await this.v2PrivatePostFuturesAdjustPositionMargin(this.extend(d,s)),c=this.safeDict(h,"data"),l=this.safeStringLower(h,"message");return this.extend(this.parseMarginModification(c,r),{type:"reduce"===i?"reduce":"add",amount:this.parseNumber(t),status:l})}parseMarginModification(e,t){let i=this.safeString(e,"market"),s=this.safeInteger2(e,"updated_at","created_at"),r=this.safeString(e,"margin_change");return{info:e,symbol:this.safeSymbol(i,t,void 0,"swap"),type:void 0,marginMode:"isolated",amount:this.parseNumber(a.Y.stringAbs(r)),total:this.safeNumber(e,"margin_avbl"),code:t.quote,status:void 0,timestamp:s,datetime:this.iso8601(s)}}async addMargin(e,t,i={}){return await this.modifyMarginHelper(e,t,"add",i)}async reduceMargin(e,t,i={}){return await this.modifyMarginHelper(e,t,"reduce",i)}async fetchFundingHistory(e,t,i,s={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingHistory() requires a symbol argument");await this.loadMarkets();let a={market:this.market(e).id,market_type:"FUTURES"};[a,s]=this.handleUntilOption("end_time",a,s),void 0!==t&&(a.start_time=t),void 0!==i&&(a.limit=i);let o=await this.v2PrivateGetFuturesPositionFundingHistory(this.extend(a,s)),n=this.safeList(o,"data",[]),d=[];for(let t=0;t<n.length;t++){let i=n[t],s=this.safeInteger(i,"created_at"),r=this.safeString(i,"ccy"),a=this.safeCurrencyCode(r);d.push({info:i,symbol:e,code:a,timestamp:s,datetime:this.iso8601(s),id:this.safeNumber(i,"position_id"),amount:this.safeNumber(i,"funding_value")})}return d}async fetchFundingRate(e,t={}){await this.loadMarkets();let i=this.market(e);if(!i.swap)throw new r.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");let s={market:i.id},a=await this.v2PublicGetFuturesFundingRate(this.extend(s,t)),o=this.safeList(a,"data",[]),n=this.safeDict(o,0,{});return this.parseFundingRate(n,i)}async fetchFundingInterval(e,t={}){return await this.fetchFundingRate(e,t)}parseFundingRate(e,t){let i=this.safeInteger(e,"latest_funding_time"),s=this.safeInteger(e,"next_funding_time"),r=this.safeString(e,"latest_funding_time"),o=this.safeString(e,"next_funding_time"),n=a.Y.stringSub(o,r),d=this.safeString(e,"market");return{info:e,symbol:this.safeSymbol(d,t,void 0,"swap"),markPrice:this.safeNumber(e,"mark_price"),indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"latest_funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:this.safeNumber(e,"next_funding_rate"),nextFundingTimestamp:s,nextFundingDatetime:this.iso8601(s),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0,interval:this.parseFundingInterval(n)}}parseFundingInterval(e){return this.safeString({36e5:"1h",144e5:"4h",288e5:"8h",576e5:"16h",864e5:"24h"},e,e)}async fetchFundingRates(e,t={}){await this.loadMarkets();let i={};if(void 0!==(e=this.marketSymbols(e))){let t=this.safeValue(e,0);if(!this.market(t).swap)throw new r.BadSymbol(this.id+" fetchFundingRates() supports swap contracts only");let s=this.marketIds(e);i.market=s.join(",")}let s=await this.v2PublicGetFuturesFundingRate(this.extend(i,t)),a=this.safeList(s,"data",[]);return this.parseFundingRates(a,e)}async withdraw(e,t,i,s,r={}){let a;[s,r]=this.handleWithdrawTagAndParams(s,r),this.checkAddress(i),await this.loadMarkets();let o=this.currency(e);s&&(i=i+":"+s);let n={ccy:o.id,to_address:i,amount:this.numberToString(t)};[a,r]=this.handleNetworkCodeAndParams(r),void 0!==a&&(n.chain=this.networkCodeToId(a));let d=await this.v2PrivatePostAssetsWithdraw(this.extend(n,r)),h=this.safeDict(d,"data",{});return this.parseTransaction(h,o)}parseTransactionStatus(e){return this.safeString({audit:"pending",pass:"pending",audit_required:"pending",processing:"pending",confirming:"pending",not_pass:"failed",cancel:"canceled",finish:"ok",finished:"ok",fail:"failed"},e,e)}async fetchFundingRateHistory(e,t,i,s={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let a=!1;if([a,s]=this.handleOptionAndParams(s,"fetchFundingRateHistory","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,i,"8h",s,1e3);let o=this.market(e),n={market:o.id};void 0!==t&&(n.start_time=t),void 0!==i&&(n.limit=i),[n,s]=this.handleUntilOption("end_time",n,s);let d=await this.v2PublicGetFuturesFundingRateHistory(this.extend(n,s)),h=this.safeList(d,"data",[]),c=[];for(let e=0;e<h.length;e++){let t=h[e],i=this.safeString(t,"market"),s=this.safeSymbol(i,o,void 0,"swap"),r=this.safeInteger(t,"funding_time");c.push({info:t,symbol:s,fundingRate:this.safeNumber(t,"actual_funding_rate"),timestamp:r,datetime:this.iso8601(r)})}let l=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(l,o.symbol,t,i)}parseTransaction(e,t){let i=this.safeString(e,"to_address"),s=this.safeString(e,"memo");void 0!==s&&s.length<1&&(s=void 0);let r=this.safeString(e,"remark");void 0!==r&&r.length<1&&(r=void 0);let a=this.safeString(e,"tx_id");void 0!==a&&a.length<1&&(a=void 0);let o=this.safeString(e,"ccy"),n=this.safeCurrencyCode(o,t),d=this.safeInteger(e,"created_at"),h="withdraw_id"in e?"withdrawal":"deposit",c=this.safeString(e,"chain"),l=this.safeString(e,"tx_fee"),u=this.safeStringLower2(e,"withdraw_method","deposit_method"),f=this.safeNumber(e,"actual_amount");void 0===f&&(f=this.safeNumber(e,"amount")),"deposit"===h&&(l="0");let p=this.safeString(e,"fee_asset"),m={cost:this.parseNumber(l),currency:this.safeCurrencyCode(p)};return{info:e,id:this.safeString2(e,"withdraw_id","deposit_id"),txid:a,timestamp:d,datetime:this.iso8601(d),network:this.networkIdToCode(c),address:i,addressTo:i,addressFrom:void 0,tag:s,tagTo:void 0,tagFrom:void 0,type:h,amount:f,currency:n,status:this.parseTransactionStatus(this.safeString(e,"status")),updated:void 0,fee:m,comment:r,internal:"local"===u}}async transfer(e,t,i,s,a={}){await this.loadMarkets();let o=this.currency(e),n=this.currencyToPrecision(e,t),d=this.safeDict(this.options,"accountsByType",{}),h=this.safeString(d,i,i),c=this.safeString(d,s,s),l={ccy:o.id,amount:n,from_account_type:h,to_account_type:c};if("margin"===i||"margin"===s){let e=this.safeString(a,"symbol");if(void 0===e)throw new r.ArgumentsRequired(this.id+" transfer() the symbol parameter must be defined for a margin account");a=this.omit(a,"symbol"),l.market=this.marketId(e)}if("spot"!==i&&"spot"!==s)throw new r.BadRequest(this.id+" transfer() can only be between spot and swap, or spot and margin, either the fromAccount or toAccount must be spot");let u=await this.v2PrivatePostAssetsTransfer(this.extend(l,a));return this.extend(this.parseTransfer(u,o),{amount:this.parseNumber(n),fromAccount:i,toAccount:s})}parseTransferStatus(e){return this.safeString({0:"ok",SUCCESS:"ok",OK:"ok",finished:"ok",FINISHED:"ok"},e,e)}parseTransfer(e,t){let i=this.safeInteger(e,"created_at"),s=this.safeString(e,"ccy"),r=this.safeString(e,"from_account_type"),a=this.safeString(e,"to_account_type"),o=this.safeValue(this.options,"accountsById",{});return{id:void 0,timestamp:i,datetime:this.iso8601(i),currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:this.safeString(o,r,r),toAccount:this.safeString(o,a,a),status:this.parseTransferStatus(this.safeString2(e,"code","status"))}}async fetchTransfers(e,t,i,s={}){let a;if(await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchTransfers() requires a code argument");let o=this.currency(e),n={ccy:o.id};[a,s]=this.handleMarginModeAndParams("fetchTransfers",s),void 0!==a?n.transfer_type="MARGIN":n.transfer_type="FUTURES",void 0!==t&&(n.start_time=t),void 0!==i&&(n.limit=i),[n,s]=this.handleUntilOption("end_time",n,s);let d=await this.v2PrivateGetAssetsTransferHistory(this.extend(n,s)),h=this.safeList(d,"data",[]);return this.parseTransfers(h,o,t,i)}async fetchWithdrawals(e,t,i,s={}){let r;await this.loadMarkets();let a={};void 0!==e&&(r=this.currency(e),a.ccy=r.id),void 0!==i&&(a.limit=i);let o=await this.v2PrivateGetAssetsWithdraw(this.extend(a,s)),n=this.safeList(o,"data",[]);return this.parseTransactions(n,r,t,i)}async fetchDeposits(e,t,i,s={}){let r;await this.loadMarkets();let a={};void 0!==e&&(r=this.currency(e),a.ccy=r.id),void 0!==i&&(a.limit=i);let o=await this.v2PrivateGetAssetsDepositHistory(this.extend(a,s)),n=this.safeList(o,"data",[]);return this.parseTransactions(n,r,t,i)}parseIsolatedBorrowRate(e,t){let i,s;let r=this.safeString(e,"market");t=this.safeMarket(r,t,void 0,"spot");let a=this.safeString(e,"ccy"),o=this.safeNumber(e,"daily_interest_rate");return a===t.baseId?i=o:a===t.quoteId&&(s=o),{symbol:t.symbol,base:t.base,baseRate:i,quote:t.quote,quoteRate:s,period:864e5,timestamp:void 0,datetime:void 0,info:e}}async fetchIsolatedBorrowRate(e,t={}){await this.loadMarkets();let i=this.safeString(t,"code");if(void 0===i)throw new r.ArgumentsRequired(this.id+" fetchIsolatedBorrowRate() requires a code parameter");t=this.omit(t,"code");let s=this.currency(i),a=this.market(e),o={market:a.id,ccy:s.id},n=await this.v2PrivateGetAssetsMarginInterestLimit(this.extend(o,t)),d=this.safeDict(n,"data",{});return this.parseIsolatedBorrowRate(d,a)}async fetchBorrowInterest(e,t,i,s,r={}){let a;await this.loadMarkets();let o={};void 0!==t&&(a=this.market(t),o.market=a.id),void 0!==s&&(o.limit=s);let n=await this.v2PrivateGetAssetsMarginBorrowHistory(this.extend(o,r)),d=this.safeValue(n,"data",[]),h=this.parseBorrowInterests(d,a);return this.filterByCurrencySinceLimit(h,e,i,s)}parseBorrowInterest(e,t){let i=this.safeString(e,"market");t=this.safeMarket(i,t,void 0,"spot");let s=this.safeInteger(e,"expired_at");return{info:e,symbol:t.symbol,currency:this.safeCurrencyCode(this.safeString(e,"ccy")),interest:this.safeNumber(e,"to_repaied_amount"),interestRate:this.safeNumber(e,"daily_interest_rate"),amountBorrowed:this.safeNumber(e,"borrow_amount"),marginMode:"isolated",timestamp:s,datetime:this.iso8601(s)}}async borrowIsolatedMargin(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a=this.currency(t),o=this.safeBool2(s,"isAutoRenew","is_auto_renew",!1);s=this.omit(s,"isAutoRenew");let n={market:r.id,ccy:a.id,borrow_amount:this.currencyToPrecision(t,i),is_auto_renew:o},d=await this.v2PrivatePostAssetsMarginBorrow(this.extend(n,s)),h=this.safeDict(d,"data",{}),c=this.parseMarginLoan(h,a);return this.extend(c,{amount:i,symbol:e})}async repayIsolatedMargin(e,t,i,s={}){await this.loadMarkets();let r=this.market(e),a=this.currency(t),o={market:r.id,ccy:a.id,amount:this.currencyToPrecision(t,i)},n=await this.v2PrivatePostAssetsMarginRepay(this.extend(o,s)),d=this.safeDict(n,"data",{}),h=this.parseMarginLoan(d,a);return this.extend(h,{amount:i,symbol:e})}parseMarginLoan(e,t){let i=this.safeString(e,"ccy"),s=this.safeString(e,"market"),r=this.safeInteger(e,"expired_at");return{id:this.safeInteger(e,"borrow_id"),currency:this.safeCurrencyCode(i,t),amount:this.safeString(e,"borrow_amount"),symbol:this.safeSymbol(s,void 0,void 0,"spot"),timestamp:r,datetime:this.iso8601(r),info:e}}async fetchDepositWithdrawFee(e,t={}){await this.loadMarkets();let i=this.currency(e),s={ccy:i.id},r=await this.v2PublicGetAssetsDepositWithdrawConfig(this.extend(s,t)),a=this.safeDict(r,"data",{});return this.parseDepositWithdrawFee(a,i)}parseDepositWithdrawFee(e,t){let i={info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}},s=this.safeList(e,"chains",[]),r=this.safeDict(e,"asset",{});for(let e=0;e<s.length;e++){let t=s[e];if(this.safeBool(t,"withdraw_enabled")){i.withdraw.fee=this.safeNumber(t,"withdrawal_fee"),i.withdraw.percentage=!1;let e=this.safeString(t,"chain");if(e){let s=this.networkIdToCode(e,this.safeString(r,"ccy"));i.networks[s]={withdraw:{fee:this.safeNumber(t,"withdrawal_fee"),percentage:!1},deposit:{fee:void 0,percentage:void 0}}}}}return i}async fetchLeverage(e,t={}){await this.loadMarkets();let i=this.safeString(t,"code");if(void 0===i)throw new r.ArgumentsRequired(this.id+" fetchLeverage() requires a code parameter");t=this.omit(t,"code");let s=this.currency(i),a=this.market(e),o={market:a.id,ccy:s.id},n=await this.v2PrivateGetAssetsMarginInterestLimit(this.extend(o,t)),d=this.safeDict(n,"data",{});return this.parseLeverage(d,a)}parseLeverage(e,t){let i=this.safeString(e,"market"),s=this.safeInteger(e,"leverage");return{info:e,symbol:this.safeSymbol(i,t,void 0,"spot"),marginMode:"isolated",longLeverage:s,shortLeverage:s}}async fetchPositionHistory(e,t,i,s={}){await this.loadMarkets();let r={market_type:"FUTURES",market:this.market(e).id};void 0!==i&&(r.limit=i),void 0!==t&&(r.start_time=t),[r,s]=this.handleUntilOption("end_time",r,s);let a=await this.v2PrivateGetFuturesFinishedPosition(this.extend(r,s)),o=this.safeList(a,"data",[]),n=this.parsePositions(o);return this.filterBySymbolSinceLimit(n,e,t,i)}async closePosition(e,t,i={}){await this.loadMarkets();let s=this.market(e),r=this.safeString(i,"type","market"),a={market:s.id,market_type:"FUTURES",type:r},o=this.safeString2(i,"client_id","clientOrderId");void 0!==o&&(a.client_id=o),i=this.omit(i,"clientOrderId");let n=await this.v2PrivatePostFuturesClosePosition(this.extend(a,i)),d=this.safeDict(n,"data",{});return this.parseOrder(d,s)}handleMarginModeAndParams(e,t={},i){let s;let r=this.safeString(this.options,"defaultType"),a=this.safeBool(t,"margin",!1);return[s,t]=super.handleMarginModeAndParams(e,t,i),void 0===s&&("margin"===r||!0===a)&&(s="isolated"),[s,t]}nonce(){return this.milliseconds()}sign(e,t=[],i="GET",s={},r,a){e=this.implodeParams(e,s);let o=t[0],h=t[1],c=this.urls.api[h]+"/"+o+"/"+e,l=this.omit(s,this.extractParams(e)),u=this.nonce().toString();if("POST"===i){let t=e.split("/"),i=this.safeString(t,0,""),r=t.length,a=this.safeString(t,r-1,"").split("_"),o=a.length,n=this.safeString(a,o-1,"");if("order"===i&&("limit"===n||"market"===n)&&void 0===this.safeString(s,"client_id")){let e=this.safeValue(this.options,"brokerId","x-167673045");l.client_id=e+"_"+this.uuid16()}}if("perpetualPrivate"===h){this.checkRequiredCredentials(),l=this.extend({access_id:this.apiKey,timestamp:u},l),l=this.keysort(l);let e=this.rawencode(l);r={Authorization:this.hash(this.encode(e+"&secret_key="+this.secret),n.s).toLowerCase(),AccessId:this.apiKey},"GET"===i||"PUT"===i?c+="?"+e:(r["Content-Type"]="application/x-www-form-urlencoded",a=e)}else if("public"===h||"perpetualPublic"===h)Object.keys(l).length&&(c+="?"+this.urlencode(l));else if("v1"===o){this.checkRequiredCredentials(),l=this.extend({access_id:this.apiKey,tonce:u},l),l=this.keysort(l);let e=this.rawencode(l);r={Authorization:this.hash(this.encode(e+"&secret_key="+this.secret),d.F).toUpperCase(),"Content-Type":"application/json"},"GET"===i||"DELETE"===i||"PUT"===i?c+="?"+e:a=this.json(l)}else if("v2"===o){this.checkRequiredCredentials(),l=this.keysort(l);let t=this.rawencode(l),s=i+"/"+o+"/"+e;"POST"===i?s+=a=this.json(l):t&&(s+="?"+t),s+=u+this.secret;let d=this.hash(this.encode(s),n.s);r={"Content-Type":"application/json",Accept:"application/json","X-COINEX-KEY":this.apiKey,"X-COINEX-SIGN":d,"X-COINEX-TIMESTAMP":u},"POST"!==i&&t&&(c+="?"+t)}return{url:c,method:i,body:a,headers:r}}handleErrors(e,t,i,s,a,o,n,d,h){if(void 0===n)return;let c=this.safeString(n,"code"),l=this.safeValue(n,"data"),u=this.safeString(n,"message");if("0"!==c||"Success"!==u&&"Succeeded"!==u&&"ok"!==u.toLowerCase()&&!l){let e=this.id+" "+u;throw this.throwBroadlyMatchedException(this.exceptions.broad,u,e),this.throwExactlyMatchedException(this.exceptions.exact,c,e),new r.ExchangeError(e)}}async fetchMarginAdjustmentHistory(e,t,i,s,a={}){if(await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMarginAdjustmentHistory() requires a symbol argument");let o=this.safeInteger2(a,"positionId","position_id");if(a=this.omit(a,"positionId"),void 0===o)throw new r.ArgumentsRequired(this.id+" fetchMarginAdjustmentHistory() requires a positionId parameter");let n={market:this.market(e).id,market_type:"FUTURES",position_id:o};[n,a]=this.handleUntilOption("end_time",n,a),void 0!==i&&(n.start_time=i),void 0!==s&&(n.limit=s);let d=await this.v2PrivateGetFuturesPositionMarginHistory(this.extend(n,a)),h=this.safeList(d,"data",[]),c=this.parseMarginModifications(h,void 0,"market","swap");return this.filterBySymbolSinceLimit(c,e,i,s)}}}}]);